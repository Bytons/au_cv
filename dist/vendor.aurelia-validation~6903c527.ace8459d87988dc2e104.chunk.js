(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendor.aurelia-validation~6903c527"],{

/***/ "8NeG":
/*!***********************************************************************************!*\
  !*** ./node_modules/aurelia-validation/dist/native-modules/aurelia-validation.js ***!
  \***********************************************************************************/
/*! exports provided: AureliaValidationConfiguration, configure, getTargetDOMElement, getPropertyInfo, PropertyAccessorParser, getAccessorExpression, ValidateBindingBehavior, ValidateManuallyBindingBehavior, ValidateOnBlurBindingBehavior, ValidateOnChangeBindingBehavior, ValidateOnChangeOrBlurBindingBehavior, ValidateEvent, ValidateResult, validateTrigger, ValidationController, ValidationControllerFactory, ValidationErrorsCustomAttribute, ValidationRendererCustomAttribute, Validator, Rules, StandardValidator, validationMessages, ValidationMessageProvider, ValidationMessageParser, MessageExpressionValidator, FluentRuleCustomizer, FluentRules, FluentEnsure, ValidationRules */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Promise) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AureliaValidationConfiguration\", function() { return AureliaValidationConfiguration; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"configure\", function() { return configure; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTargetDOMElement\", function() { return getTargetDOMElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPropertyInfo\", function() { return getPropertyInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PropertyAccessorParser\", function() { return PropertyAccessorParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAccessorExpression\", function() { return getAccessorExpression; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidateBindingBehavior\", function() { return ValidateBindingBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidateManuallyBindingBehavior\", function() { return ValidateManuallyBindingBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidateOnBlurBindingBehavior\", function() { return ValidateOnBlurBindingBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidateOnChangeBindingBehavior\", function() { return ValidateOnChangeBindingBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidateOnChangeOrBlurBindingBehavior\", function() { return ValidateOnChangeOrBlurBindingBehavior; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidateEvent\", function() { return ValidateEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidateResult\", function() { return ValidateResult; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateTrigger\", function() { return validateTrigger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationController\", function() { return ValidationController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationControllerFactory\", function() { return ValidationControllerFactory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationErrorsCustomAttribute\", function() { return ValidationErrorsCustomAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationRendererCustomAttribute\", function() { return ValidationRendererCustomAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Validator\", function() { return Validator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Rules\", function() { return Rules; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StandardValidator\", function() { return StandardValidator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validationMessages\", function() { return validationMessages; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationMessageProvider\", function() { return ValidationMessageProvider; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationMessageParser\", function() { return ValidationMessageParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MessageExpressionValidator\", function() { return MessageExpressionValidator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FluentRuleCustomizer\", function() { return FluentRuleCustomizer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FluentRules\", function() { return FluentRules; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FluentEnsure\", function() { return FluentEnsure; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationRules\", function() { return ValidationRules; });\n/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-pal */ \"70NS\");\n/* harmony import */ var aurelia_binding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aurelia-binding */ \"X5gX\");\n/* harmony import */ var aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aurelia-dependency-injection */ \"3U8n\");\n/* harmony import */ var aurelia_task_queue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! aurelia-task-queue */ \"K/SW\");\n/* harmony import */ var aurelia_templating__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! aurelia-templating */ \"hij8\");\n/* harmony import */ var aurelia_logging__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! aurelia-logging */ \"MP1E\");\n\n\n\n\n\n\n\n/**\r\n * Gets the DOM element associated with the data-binding. Most of the time it's\r\n * the binding.target but sometimes binding.target is an aurelia custom element,\r\n * or custom attribute which is a javascript \"class\" instance, so we need to use\r\n * the controller's container to retrieve the actual DOM element.\r\n */\r\nfunction getTargetDOMElement(binding, view) {\r\n    var target = binding.target;\r\n    // DOM element\r\n    if (target instanceof Element) {\r\n        return target;\r\n    }\r\n    // custom element or custom attribute\r\n    // tslint:disable-next-line:prefer-const\r\n    for (var i = 0, ii = view.controllers.length; i < ii; i++) {\r\n        var controller = view.controllers[i];\r\n        if (controller.viewModel === target) {\r\n            var element = controller.container.get(aurelia_pal__WEBPACK_IMPORTED_MODULE_0__[\"DOM\"].Element);\r\n            if (element) {\r\n                return element;\r\n            }\r\n            throw new Error(\"Unable to locate target element for \\\"\" + binding.sourceExpression + \"\\\".\");\r\n        }\r\n    }\r\n    throw new Error(\"Unable to locate target element for \\\"\" + binding.sourceExpression + \"\\\".\");\r\n}\n\nfunction getObject(expression, objectExpression, source) {\r\n    var value = objectExpression.evaluate(source, null);\r\n    if (value === null || value === undefined || value instanceof Object) {\r\n        return value;\r\n    }\r\n    // tslint:disable-next-line:max-line-length\r\n    throw new Error(\"The '\" + objectExpression + \"' part of '\" + expression + \"' evaluates to \" + value + \" instead of an object, null or undefined.\");\r\n}\r\n/**\r\n * Retrieves the object and property name for the specified expression.\r\n * @param expression The expression\r\n * @param source The scope\r\n */\r\nfunction getPropertyInfo(expression, source) {\r\n    var originalExpression = expression;\r\n    while (expression instanceof aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"BindingBehavior\"] || expression instanceof aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"ValueConverter\"]) {\r\n        expression = expression.expression;\r\n    }\r\n    var object;\r\n    var propertyName;\r\n    if (expression instanceof aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"AccessScope\"]) {\r\n        object = Object(aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"getContextFor\"])(expression.name, source, expression.ancestor);\r\n        propertyName = expression.name;\r\n    }\r\n    else if (expression instanceof aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"AccessMember\"]) {\r\n        object = getObject(originalExpression, expression.object, source);\r\n        propertyName = expression.name;\r\n    }\r\n    else if (expression instanceof aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"AccessKeyed\"]) {\r\n        object = getObject(originalExpression, expression.object, source);\r\n        propertyName = expression.key.evaluate(source);\r\n    }\r\n    else {\r\n        throw new Error(\"Expression '\" + originalExpression + \"' is not compatible with the validate binding-behavior.\");\r\n    }\r\n    if (object === null || object === undefined) {\r\n        return null;\r\n    }\r\n    return { object: object, propertyName: propertyName };\r\n}\n\nfunction isString(value) {\r\n    return Object.prototype.toString.call(value) === '[object String]';\r\n}\r\nfunction isNumber(value) {\r\n    return Object.prototype.toString.call(value) === '[object Number]';\r\n}\n\nvar PropertyAccessorParser = /** @class */ (function () {\r\n    function PropertyAccessorParser(parser) {\r\n        this.parser = parser;\r\n    }\r\n    PropertyAccessorParser.prototype.parse = function (property) {\r\n        if (isString(property) || isNumber(property)) {\r\n            return property;\r\n        }\r\n        var accessorText = getAccessorExpression(property.toString());\r\n        var accessor = this.parser.parse(accessorText);\r\n        if (accessor instanceof aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"AccessScope\"]\r\n            || accessor instanceof aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"AccessMember\"] && accessor.object instanceof aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"AccessScope\"]) {\r\n            return accessor.name;\r\n        }\r\n        throw new Error(\"Invalid property expression: \\\"\" + accessor + \"\\\"\");\r\n    };\r\n    PropertyAccessorParser.inject = [aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"Parser\"]];\r\n    return PropertyAccessorParser;\r\n}());\r\nfunction getAccessorExpression(fn) {\r\n    /* tslint:disable:max-line-length */\r\n    var classic = /^function\\s*\\([$_\\w\\d]+\\)\\s*\\{(?:\\s*\"use strict\";)?\\s*(?:[$_\\w\\d.['\"\\]+;]+)?\\s*return\\s+[$_\\w\\d]+\\.([$_\\w\\d]+)\\s*;?\\s*\\}$/;\r\n    /* tslint:enable:max-line-length */\r\n    var arrow = /^\\(?[$_\\w\\d]+\\)?\\s*=>\\s*[$_\\w\\d]+\\.([$_\\w\\d]+)$/;\r\n    var match = classic.exec(fn) || arrow.exec(fn);\r\n    if (match === null) {\r\n        throw new Error(\"Unable to parse accessor function:\\n\" + fn);\r\n    }\r\n    return match[1];\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\n\n/**\r\n * Validation triggers.\r\n */\r\nvar validateTrigger;\r\n(function (validateTrigger) {\r\n    /**\r\n     * Manual validation.  Use the controller's `validate()` and  `reset()` methods\r\n     * to validate all bindings.\r\n     */\r\n    validateTrigger[validateTrigger[\"manual\"] = 0] = \"manual\";\r\n    /**\r\n     * Validate the binding when the binding's target element fires a DOM \"blur\" event.\r\n     */\r\n    validateTrigger[validateTrigger[\"blur\"] = 1] = \"blur\";\r\n    /**\r\n     * Validate the binding when it updates the model due to a change in the view.\r\n     */\r\n    validateTrigger[validateTrigger[\"change\"] = 2] = \"change\";\r\n    /**\r\n     * Validate the binding when the binding's target element fires a DOM \"blur\" event and\r\n     * when it updates the model due to a change in the view.\r\n     */\r\n    validateTrigger[validateTrigger[\"changeOrBlur\"] = 3] = \"changeOrBlur\";\r\n})(validateTrigger || (validateTrigger = {}));\n\n/**\r\n * Validates objects and properties.\r\n */\r\nvar Validator = /** @class */ (function () {\r\n    function Validator() {\r\n    }\r\n    return Validator;\r\n}());\n\n/**\r\n * The result of validating an individual validation rule.\r\n */\r\nvar ValidateResult = /** @class */ (function () {\r\n    /**\r\n     * @param rule The rule associated with the result. Validator implementation specific.\r\n     * @param object The object that was validated.\r\n     * @param propertyName The name of the property that was validated.\r\n     * @param error The error, if the result is a validation error.\r\n     */\r\n    function ValidateResult(rule, object, propertyName, valid, message) {\r\n        if (message === void 0) { message = null; }\r\n        this.rule = rule;\r\n        this.object = object;\r\n        this.propertyName = propertyName;\r\n        this.valid = valid;\r\n        this.message = message;\r\n        this.id = ValidateResult.nextId++;\r\n    }\r\n    ValidateResult.prototype.toString = function () {\r\n        return this.valid ? 'Valid.' : this.message;\r\n    };\r\n    ValidateResult.nextId = 0;\r\n    return ValidateResult;\r\n}());\n\nvar ValidateEvent = /** @class */ (function () {\r\n    function ValidateEvent(\r\n    /**\r\n     * The type of validate event. Either \"validate\" or \"reset\".\r\n     */\r\n    type, \r\n    /**\r\n     * The controller's current array of errors. For an array containing both\r\n     * failed rules and passed rules, use the \"results\" property.\r\n     */\r\n    errors, \r\n    /**\r\n     * The controller's current array of validate results. This\r\n     * includes both passed rules and failed rules. For an array of only failed rules,\r\n     * use the \"errors\" property.\r\n     */\r\n    results, \r\n    /**\r\n     * The instruction passed to the \"validate\" or \"reset\" event. Will be null when\r\n     * the controller's validate/reset method was called with no instruction argument.\r\n     */\r\n    instruction, \r\n    /**\r\n     * In events with type === \"validate\", this property will contain the result\r\n     * of validating the instruction (see \"instruction\" property). Use the controllerValidateResult\r\n     * to access the validate results specific to the call to \"validate\"\r\n     * (as opposed to using the \"results\" and \"errors\" properties to access the controller's entire\r\n     * set of results/errors).\r\n     */\r\n    controllerValidateResult) {\r\n        this.type = type;\r\n        this.errors = errors;\r\n        this.results = results;\r\n        this.instruction = instruction;\r\n        this.controllerValidateResult = controllerValidateResult;\r\n    }\r\n    return ValidateEvent;\r\n}());\n\n/**\r\n * Orchestrates validation.\r\n * Manages a set of bindings, renderers and objects.\r\n * Exposes the current list of validation results for binding purposes.\r\n */\r\nvar ValidationController = /** @class */ (function () {\r\n    function ValidationController(validator, propertyParser) {\r\n        this.validator = validator;\r\n        this.propertyParser = propertyParser;\r\n        // Registered bindings (via the validate binding behavior)\r\n        this.bindings = new Map();\r\n        // Renderers that have been added to the controller instance.\r\n        this.renderers = [];\r\n        /**\r\n         * Validation results that have been rendered by the controller.\r\n         */\r\n        this.results = [];\r\n        /**\r\n         * Validation errors that have been rendered by the controller.\r\n         */\r\n        this.errors = [];\r\n        /**\r\n         *  Whether the controller is currently validating.\r\n         */\r\n        this.validating = false;\r\n        // Elements related to validation results that have been rendered.\r\n        this.elements = new Map();\r\n        // Objects that have been added to the controller instance (entity-style validation).\r\n        this.objects = new Map();\r\n        /**\r\n         * The trigger that will invoke automatic validation of a property used in a binding.\r\n         */\r\n        this.validateTrigger = validateTrigger.blur;\r\n        // Promise that resolves when validation has completed.\r\n        this.finishValidating = Promise.resolve();\r\n        this.eventCallbacks = [];\r\n    }\r\n    /**\r\n     * Subscribe to controller validate and reset events. These events occur when the\r\n     * controller's \"validate\"\" and \"reset\" methods are called.\r\n     * @param callback The callback to be invoked when the controller validates or resets.\r\n     */\r\n    ValidationController.prototype.subscribe = function (callback) {\r\n        var _this = this;\r\n        this.eventCallbacks.push(callback);\r\n        return {\r\n            dispose: function () {\r\n                var index = _this.eventCallbacks.indexOf(callback);\r\n                if (index === -1) {\r\n                    return;\r\n                }\r\n                _this.eventCallbacks.splice(index, 1);\r\n            }\r\n        };\r\n    };\r\n    /**\r\n     * Adds an object to the set of objects that should be validated when validate is called.\r\n     * @param object The object.\r\n     * @param rules Optional. The rules. If rules aren't supplied the Validator implementation will lookup the rules.\r\n     */\r\n    ValidationController.prototype.addObject = function (object, rules) {\r\n        this.objects.set(object, rules);\r\n    };\r\n    /**\r\n     * Removes an object from the set of objects that should be validated when validate is called.\r\n     * @param object The object.\r\n     */\r\n    ValidationController.prototype.removeObject = function (object) {\r\n        this.objects.delete(object);\r\n        this.processResultDelta('reset', this.results.filter(function (result) { return result.object === object; }), []);\r\n    };\r\n    /**\r\n     * Adds and renders an error.\r\n     */\r\n    ValidationController.prototype.addError = function (message, object, propertyName) {\r\n        if (propertyName === void 0) { propertyName = null; }\r\n        var resolvedPropertyName;\r\n        if (propertyName === null) {\r\n            resolvedPropertyName = propertyName;\r\n        }\r\n        else {\r\n            resolvedPropertyName = this.propertyParser.parse(propertyName);\r\n        }\r\n        var result = new ValidateResult({ __manuallyAdded__: true }, object, resolvedPropertyName, false, message);\r\n        this.processResultDelta('validate', [], [result]);\r\n        return result;\r\n    };\r\n    /**\r\n     * Removes and unrenders an error.\r\n     */\r\n    ValidationController.prototype.removeError = function (result) {\r\n        if (this.results.indexOf(result) !== -1) {\r\n            this.processResultDelta('reset', [result], []);\r\n        }\r\n    };\r\n    /**\r\n     * Adds a renderer.\r\n     * @param renderer The renderer.\r\n     */\r\n    ValidationController.prototype.addRenderer = function (renderer) {\r\n        var _this = this;\r\n        this.renderers.push(renderer);\r\n        renderer.render({\r\n            kind: 'validate',\r\n            render: this.results.map(function (result) { return ({ result: result, elements: _this.elements.get(result) }); }),\r\n            unrender: []\r\n        });\r\n    };\r\n    /**\r\n     * Removes a renderer.\r\n     * @param renderer The renderer.\r\n     */\r\n    ValidationController.prototype.removeRenderer = function (renderer) {\r\n        var _this = this;\r\n        this.renderers.splice(this.renderers.indexOf(renderer), 1);\r\n        renderer.render({\r\n            kind: 'reset',\r\n            render: [],\r\n            unrender: this.results.map(function (result) { return ({ result: result, elements: _this.elements.get(result) }); })\r\n        });\r\n    };\r\n    /**\r\n     * Registers a binding with the controller.\r\n     * @param binding The binding instance.\r\n     * @param target The DOM element.\r\n     * @param rules (optional) rules associated with the binding. Validator implementation specific.\r\n     */\r\n    ValidationController.prototype.registerBinding = function (binding, target, rules) {\r\n        this.bindings.set(binding, { target: target, rules: rules, propertyInfo: null });\r\n    };\r\n    /**\r\n     * Unregisters a binding with the controller.\r\n     * @param binding The binding instance.\r\n     */\r\n    ValidationController.prototype.unregisterBinding = function (binding) {\r\n        this.resetBinding(binding);\r\n        this.bindings.delete(binding);\r\n    };\r\n    /**\r\n     * Interprets the instruction and returns a predicate that will identify\r\n     * relevant results in the list of rendered validation results.\r\n     */\r\n    ValidationController.prototype.getInstructionPredicate = function (instruction) {\r\n        var _this = this;\r\n        if (instruction) {\r\n            var object_1 = instruction.object, propertyName_1 = instruction.propertyName, rules_1 = instruction.rules;\r\n            var predicate_1;\r\n            if (instruction.propertyName) {\r\n                predicate_1 = function (x) { return x.object === object_1 && x.propertyName === propertyName_1; };\r\n            }\r\n            else {\r\n                predicate_1 = function (x) { return x.object === object_1; };\r\n            }\r\n            if (rules_1) {\r\n                return function (x) { return predicate_1(x) && _this.validator.ruleExists(rules_1, x.rule); };\r\n            }\r\n            return predicate_1;\r\n        }\r\n        else {\r\n            return function () { return true; };\r\n        }\r\n    };\r\n    /**\r\n     * Validates and renders results.\r\n     * @param instruction Optional. Instructions on what to validate. If undefined, all\r\n     * objects and bindings will be validated.\r\n     */\r\n    ValidationController.prototype.validate = function (instruction) {\r\n        var _this = this;\r\n        // Get a function that will process the validation instruction.\r\n        var execute;\r\n        if (instruction) {\r\n            // tslint:disable-next-line:prefer-const\r\n            var object_2 = instruction.object, propertyName_2 = instruction.propertyName, rules_2 = instruction.rules;\r\n            // if rules were not specified, check the object map.\r\n            rules_2 = rules_2 || this.objects.get(object_2);\r\n            // property specified?\r\n            if (instruction.propertyName === undefined) {\r\n                // validate the specified object.\r\n                execute = function () { return _this.validator.validateObject(object_2, rules_2); };\r\n            }\r\n            else {\r\n                // validate the specified property.\r\n                execute = function () { return _this.validator.validateProperty(object_2, propertyName_2, rules_2); };\r\n            }\r\n        }\r\n        else {\r\n            // validate all objects and bindings.\r\n            execute = function () {\r\n                var promises = [];\r\n                for (var _i = 0, _a = Array.from(_this.objects); _i < _a.length; _i++) {\r\n                    var _b = _a[_i], object = _b[0], rules = _b[1];\r\n                    promises.push(_this.validator.validateObject(object, rules));\r\n                }\r\n                for (var _c = 0, _d = Array.from(_this.bindings); _c < _d.length; _c++) {\r\n                    var _e = _d[_c], binding = _e[0], rules = _e[1].rules;\r\n                    var propertyInfo = getPropertyInfo(binding.sourceExpression, binding.source);\r\n                    if (!propertyInfo || _this.objects.has(propertyInfo.object)) {\r\n                        continue;\r\n                    }\r\n                    promises.push(_this.validator.validateProperty(propertyInfo.object, propertyInfo.propertyName, rules));\r\n                }\r\n                return Promise.all(promises).then(function (resultSets) { return resultSets.reduce(function (a, b) { return a.concat(b); }, []); });\r\n            };\r\n        }\r\n        // Wait for any existing validation to finish, execute the instruction, render the results.\r\n        this.validating = true;\r\n        var returnPromise = this.finishValidating\r\n            .then(execute)\r\n            .then(function (newResults) {\r\n            var predicate = _this.getInstructionPredicate(instruction);\r\n            var oldResults = _this.results.filter(predicate);\r\n            _this.processResultDelta('validate', oldResults, newResults);\r\n            if (returnPromise === _this.finishValidating) {\r\n                _this.validating = false;\r\n            }\r\n            var result = {\r\n                instruction: instruction,\r\n                valid: newResults.find(function (x) { return !x.valid; }) === undefined,\r\n                results: newResults\r\n            };\r\n            _this.invokeCallbacks(instruction, result);\r\n            return result;\r\n        })\r\n            .catch(function (exception) {\r\n            // recover, to enable subsequent calls to validate()\r\n            _this.validating = false;\r\n            _this.finishValidating = Promise.resolve();\r\n            return Promise.reject(exception);\r\n        });\r\n        this.finishValidating = returnPromise;\r\n        return returnPromise;\r\n    };\r\n    /**\r\n     * Resets any rendered validation results (unrenders).\r\n     * @param instruction Optional. Instructions on what to reset. If unspecified all rendered results\r\n     * will be unrendered.\r\n     */\r\n    ValidationController.prototype.reset = function (instruction) {\r\n        var predicate = this.getInstructionPredicate(instruction);\r\n        var oldResults = this.results.filter(predicate);\r\n        this.processResultDelta('reset', oldResults, []);\r\n        this.invokeCallbacks(instruction, null);\r\n    };\r\n    /**\r\n     * Gets the elements associated with an object and propertyName (if any).\r\n     */\r\n    ValidationController.prototype.getAssociatedElements = function (_a) {\r\n        var object = _a.object, propertyName = _a.propertyName;\r\n        var elements = [];\r\n        for (var _i = 0, _b = Array.from(this.bindings); _i < _b.length; _i++) {\r\n            var _c = _b[_i], binding = _c[0], target = _c[1].target;\r\n            var propertyInfo = getPropertyInfo(binding.sourceExpression, binding.source);\r\n            if (propertyInfo && propertyInfo.object === object && propertyInfo.propertyName === propertyName) {\r\n                elements.push(target);\r\n            }\r\n        }\r\n        return elements;\r\n    };\r\n    ValidationController.prototype.processResultDelta = function (kind, oldResults, newResults) {\r\n        // prepare the instruction.\r\n        var instruction = {\r\n            kind: kind,\r\n            render: [],\r\n            unrender: []\r\n        };\r\n        // create a shallow copy of newResults so we can mutate it without causing side-effects.\r\n        newResults = newResults.slice(0);\r\n        var _loop_1 = function (oldResult) {\r\n            // get the elements associated with the old result.\r\n            var elements = this_1.elements.get(oldResult);\r\n            // remove the old result from the element map.\r\n            this_1.elements.delete(oldResult);\r\n            // create the unrender instruction.\r\n            instruction.unrender.push({ result: oldResult, elements: elements });\r\n            // determine if there's a corresponding new result for the old result we are unrendering.\r\n            var newResultIndex = newResults.findIndex(function (x) { return x.rule === oldResult.rule && x.object === oldResult.object && x.propertyName === oldResult.propertyName; });\r\n            if (newResultIndex === -1) {\r\n                // no corresponding new result... simple remove.\r\n                this_1.results.splice(this_1.results.indexOf(oldResult), 1);\r\n                if (!oldResult.valid) {\r\n                    this_1.errors.splice(this_1.errors.indexOf(oldResult), 1);\r\n                }\r\n            }\r\n            else {\r\n                // there is a corresponding new result...\r\n                var newResult = newResults.splice(newResultIndex, 1)[0];\r\n                // get the elements that are associated with the new result.\r\n                var elements_1 = this_1.getAssociatedElements(newResult);\r\n                this_1.elements.set(newResult, elements_1);\r\n                // create a render instruction for the new result.\r\n                instruction.render.push({ result: newResult, elements: elements_1 });\r\n                // do an in-place replacement of the old result with the new result.\r\n                // this ensures any repeats bound to this.results will not thrash.\r\n                this_1.results.splice(this_1.results.indexOf(oldResult), 1, newResult);\r\n                if (!oldResult.valid && newResult.valid) {\r\n                    this_1.errors.splice(this_1.errors.indexOf(oldResult), 1);\r\n                }\r\n                else if (!oldResult.valid && !newResult.valid) {\r\n                    this_1.errors.splice(this_1.errors.indexOf(oldResult), 1, newResult);\r\n                }\r\n                else if (!newResult.valid) {\r\n                    this_1.errors.push(newResult);\r\n                }\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        // create unrender instructions from the old results.\r\n        for (var _i = 0, oldResults_1 = oldResults; _i < oldResults_1.length; _i++) {\r\n            var oldResult = oldResults_1[_i];\r\n            _loop_1(oldResult);\r\n        }\r\n        // create render instructions from the remaining new results.\r\n        for (var _a = 0, newResults_1 = newResults; _a < newResults_1.length; _a++) {\r\n            var result = newResults_1[_a];\r\n            var elements = this.getAssociatedElements(result);\r\n            instruction.render.push({ result: result, elements: elements });\r\n            this.elements.set(result, elements);\r\n            this.results.push(result);\r\n            if (!result.valid) {\r\n                this.errors.push(result);\r\n            }\r\n        }\r\n        // render.\r\n        for (var _b = 0, _c = this.renderers; _b < _c.length; _b++) {\r\n            var renderer = _c[_b];\r\n            renderer.render(instruction);\r\n        }\r\n    };\r\n    /**\r\n     * Validates the property associated with a binding.\r\n     */\r\n    ValidationController.prototype.validateBinding = function (binding) {\r\n        if (!binding.isBound) {\r\n            return;\r\n        }\r\n        var propertyInfo = getPropertyInfo(binding.sourceExpression, binding.source);\r\n        var rules;\r\n        var registeredBinding = this.bindings.get(binding);\r\n        if (registeredBinding) {\r\n            rules = registeredBinding.rules;\r\n            registeredBinding.propertyInfo = propertyInfo;\r\n        }\r\n        if (!propertyInfo) {\r\n            return;\r\n        }\r\n        var object = propertyInfo.object, propertyName = propertyInfo.propertyName;\r\n        this.validate({ object: object, propertyName: propertyName, rules: rules });\r\n    };\r\n    /**\r\n     * Resets the results for a property associated with a binding.\r\n     */\r\n    ValidationController.prototype.resetBinding = function (binding) {\r\n        var registeredBinding = this.bindings.get(binding);\r\n        var propertyInfo = getPropertyInfo(binding.sourceExpression, binding.source);\r\n        if (!propertyInfo && registeredBinding) {\r\n            propertyInfo = registeredBinding.propertyInfo;\r\n        }\r\n        if (registeredBinding) {\r\n            registeredBinding.propertyInfo = null;\r\n        }\r\n        if (!propertyInfo) {\r\n            return;\r\n        }\r\n        var object = propertyInfo.object, propertyName = propertyInfo.propertyName;\r\n        this.reset({ object: object, propertyName: propertyName });\r\n    };\r\n    /**\r\n     * Changes the controller's validateTrigger.\r\n     * @param newTrigger The new validateTrigger\r\n     */\r\n    ValidationController.prototype.changeTrigger = function (newTrigger) {\r\n        this.validateTrigger = newTrigger;\r\n        var bindings = Array.from(this.bindings.keys());\r\n        for (var _i = 0, bindings_1 = bindings; _i < bindings_1.length; _i++) {\r\n            var binding = bindings_1[_i];\r\n            var source = binding.source;\r\n            binding.unbind();\r\n            binding.bind(source);\r\n        }\r\n    };\r\n    /**\r\n     * Revalidates the controller's current set of errors.\r\n     */\r\n    ValidationController.prototype.revalidateErrors = function () {\r\n        for (var _i = 0, _a = this.errors; _i < _a.length; _i++) {\r\n            var _b = _a[_i], object = _b.object, propertyName = _b.propertyName, rule = _b.rule;\r\n            if (rule.__manuallyAdded__) {\r\n                continue;\r\n            }\r\n            var rules = [[rule]];\r\n            this.validate({ object: object, propertyName: propertyName, rules: rules });\r\n        }\r\n    };\r\n    ValidationController.prototype.invokeCallbacks = function (instruction, result) {\r\n        if (this.eventCallbacks.length === 0) {\r\n            return;\r\n        }\r\n        var event = new ValidateEvent(result ? 'validate' : 'reset', this.errors, this.results, instruction || null, result);\r\n        for (var i = 0; i < this.eventCallbacks.length; i++) {\r\n            this.eventCallbacks[i](event);\r\n        }\r\n    };\r\n    ValidationController.inject = [Validator, PropertyAccessorParser];\r\n    return ValidationController;\r\n}());\n\n/**\r\n * Binding behavior. Indicates the bound property should be validated.\r\n */\r\nvar ValidateBindingBehaviorBase = /** @class */ (function () {\r\n    function ValidateBindingBehaviorBase(taskQueue) {\r\n        this.taskQueue = taskQueue;\r\n    }\r\n    ValidateBindingBehaviorBase.prototype.bind = function (binding, source, rulesOrController, rules) {\r\n        var _this = this;\r\n        // identify the target element.\r\n        var target = getTargetDOMElement(binding, source);\r\n        // locate the controller.\r\n        var controller;\r\n        if (rulesOrController instanceof ValidationController) {\r\n            controller = rulesOrController;\r\n        }\r\n        else {\r\n            controller = source.container.get(aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_2__[\"Optional\"].of(ValidationController));\r\n            rules = rulesOrController;\r\n        }\r\n        if (controller === null) {\r\n            throw new Error(\"A ValidationController has not been registered.\");\r\n        }\r\n        controller.registerBinding(binding, target, rules);\r\n        binding.validationController = controller;\r\n        var trigger = this.getValidateTrigger(controller);\r\n        // tslint:disable-next-line:no-bitwise\r\n        if (trigger & validateTrigger.change) {\r\n            binding.vbbUpdateSource = binding.updateSource;\r\n            // tslint:disable-next-line:only-arrow-functions\r\n            // tslint:disable-next-line:space-before-function-paren\r\n            binding.updateSource = function (value) {\r\n                this.vbbUpdateSource(value);\r\n                this.validationController.validateBinding(this);\r\n            };\r\n        }\r\n        // tslint:disable-next-line:no-bitwise\r\n        if (trigger & validateTrigger.blur) {\r\n            binding.validateBlurHandler = function () {\r\n                _this.taskQueue.queueMicroTask(function () { return controller.validateBinding(binding); });\r\n            };\r\n            binding.validateTarget = target;\r\n            target.addEventListener('blur', binding.validateBlurHandler);\r\n        }\r\n        if (trigger !== validateTrigger.manual) {\r\n            binding.standardUpdateTarget = binding.updateTarget;\r\n            // tslint:disable-next-line:only-arrow-functions\r\n            // tslint:disable-next-line:space-before-function-paren\r\n            binding.updateTarget = function (value) {\r\n                this.standardUpdateTarget(value);\r\n                this.validationController.resetBinding(this);\r\n            };\r\n        }\r\n    };\r\n    ValidateBindingBehaviorBase.prototype.unbind = function (binding) {\r\n        // reset the binding to it's original state.\r\n        if (binding.vbbUpdateSource) {\r\n            binding.updateSource = binding.vbbUpdateSource;\r\n            binding.vbbUpdateSource = null;\r\n        }\r\n        if (binding.standardUpdateTarget) {\r\n            binding.updateTarget = binding.standardUpdateTarget;\r\n            binding.standardUpdateTarget = null;\r\n        }\r\n        if (binding.validateBlurHandler) {\r\n            binding.validateTarget.removeEventListener('blur', binding.validateBlurHandler);\r\n            binding.validateBlurHandler = null;\r\n            binding.validateTarget = null;\r\n        }\r\n        binding.validationController.unregisterBinding(binding);\r\n        binding.validationController = null;\r\n    };\r\n    return ValidateBindingBehaviorBase;\r\n}());\n\n/**\r\n * Binding behavior. Indicates the bound property should be validated\r\n * when the validate trigger specified by the associated controller's\r\n * validateTrigger property occurs.\r\n */\r\nvar ValidateBindingBehavior = /** @class */ (function (_super) {\r\n    __extends(ValidateBindingBehavior, _super);\r\n    function ValidateBindingBehavior() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ValidateBindingBehavior.prototype.getValidateTrigger = function (controller) {\r\n        return controller.validateTrigger;\r\n    };\r\n    ValidateBindingBehavior.inject = [aurelia_task_queue__WEBPACK_IMPORTED_MODULE_3__[\"TaskQueue\"]];\r\n    ValidateBindingBehavior = __decorate([\r\n        Object(aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"bindingBehavior\"])('validate')\r\n    ], ValidateBindingBehavior);\r\n    return ValidateBindingBehavior;\r\n}(ValidateBindingBehaviorBase));\r\n/**\r\n * Binding behavior. Indicates the bound property will be validated\r\n * manually, by calling controller.validate(). No automatic validation\r\n * triggered by data-entry or blur will occur.\r\n */\r\nvar ValidateManuallyBindingBehavior = /** @class */ (function (_super) {\r\n    __extends(ValidateManuallyBindingBehavior, _super);\r\n    function ValidateManuallyBindingBehavior() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ValidateManuallyBindingBehavior.prototype.getValidateTrigger = function () {\r\n        return validateTrigger.manual;\r\n    };\r\n    ValidateManuallyBindingBehavior.inject = [aurelia_task_queue__WEBPACK_IMPORTED_MODULE_3__[\"TaskQueue\"]];\r\n    ValidateManuallyBindingBehavior = __decorate([\r\n        Object(aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"bindingBehavior\"])('validateManually')\r\n    ], ValidateManuallyBindingBehavior);\r\n    return ValidateManuallyBindingBehavior;\r\n}(ValidateBindingBehaviorBase));\r\n/**\r\n * Binding behavior. Indicates the bound property should be validated\r\n * when the associated element blurs.\r\n */\r\nvar ValidateOnBlurBindingBehavior = /** @class */ (function (_super) {\r\n    __extends(ValidateOnBlurBindingBehavior, _super);\r\n    function ValidateOnBlurBindingBehavior() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ValidateOnBlurBindingBehavior.prototype.getValidateTrigger = function () {\r\n        return validateTrigger.blur;\r\n    };\r\n    ValidateOnBlurBindingBehavior.inject = [aurelia_task_queue__WEBPACK_IMPORTED_MODULE_3__[\"TaskQueue\"]];\r\n    ValidateOnBlurBindingBehavior = __decorate([\r\n        Object(aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"bindingBehavior\"])('validateOnBlur')\r\n    ], ValidateOnBlurBindingBehavior);\r\n    return ValidateOnBlurBindingBehavior;\r\n}(ValidateBindingBehaviorBase));\r\n/**\r\n * Binding behavior. Indicates the bound property should be validated\r\n * when the associated element is changed by the user, causing a change\r\n * to the model.\r\n */\r\nvar ValidateOnChangeBindingBehavior = /** @class */ (function (_super) {\r\n    __extends(ValidateOnChangeBindingBehavior, _super);\r\n    function ValidateOnChangeBindingBehavior() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ValidateOnChangeBindingBehavior.prototype.getValidateTrigger = function () {\r\n        return validateTrigger.change;\r\n    };\r\n    ValidateOnChangeBindingBehavior.inject = [aurelia_task_queue__WEBPACK_IMPORTED_MODULE_3__[\"TaskQueue\"]];\r\n    ValidateOnChangeBindingBehavior = __decorate([\r\n        Object(aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"bindingBehavior\"])('validateOnChange')\r\n    ], ValidateOnChangeBindingBehavior);\r\n    return ValidateOnChangeBindingBehavior;\r\n}(ValidateBindingBehaviorBase));\r\n/**\r\n * Binding behavior. Indicates the bound property should be validated\r\n * when the associated element blurs or is changed by the user, causing\r\n * a change to the model.\r\n */\r\nvar ValidateOnChangeOrBlurBindingBehavior = /** @class */ (function (_super) {\r\n    __extends(ValidateOnChangeOrBlurBindingBehavior, _super);\r\n    function ValidateOnChangeOrBlurBindingBehavior() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ValidateOnChangeOrBlurBindingBehavior.prototype.getValidateTrigger = function () {\r\n        return validateTrigger.changeOrBlur;\r\n    };\r\n    ValidateOnChangeOrBlurBindingBehavior.inject = [aurelia_task_queue__WEBPACK_IMPORTED_MODULE_3__[\"TaskQueue\"]];\r\n    ValidateOnChangeOrBlurBindingBehavior = __decorate([\r\n        Object(aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"bindingBehavior\"])('validateOnChangeOrBlur')\r\n    ], ValidateOnChangeOrBlurBindingBehavior);\r\n    return ValidateOnChangeOrBlurBindingBehavior;\r\n}(ValidateBindingBehaviorBase));\n\n/**\r\n * Creates ValidationController instances.\r\n */\r\nvar ValidationControllerFactory = /** @class */ (function () {\r\n    function ValidationControllerFactory(container) {\r\n        this.container = container;\r\n    }\r\n    ValidationControllerFactory.get = function (container) {\r\n        return new ValidationControllerFactory(container);\r\n    };\r\n    /**\r\n     * Creates a new controller instance.\r\n     */\r\n    ValidationControllerFactory.prototype.create = function (validator) {\r\n        if (!validator) {\r\n            validator = this.container.get(Validator);\r\n        }\r\n        var propertyParser = this.container.get(PropertyAccessorParser);\r\n        return new ValidationController(validator, propertyParser);\r\n    };\r\n    /**\r\n     * Creates a new controller and registers it in the current element's container so that it's\r\n     * available to the validate binding behavior and renderers.\r\n     */\r\n    ValidationControllerFactory.prototype.createForCurrentScope = function (validator) {\r\n        var controller = this.create(validator);\r\n        this.container.registerInstance(ValidationController, controller);\r\n        return controller;\r\n    };\r\n    return ValidationControllerFactory;\r\n}());\r\nValidationControllerFactory['protocol:aurelia:resolver'] = true;\n\nvar ValidationErrorsCustomAttribute = /** @class */ (function () {\r\n    function ValidationErrorsCustomAttribute(boundaryElement, controllerAccessor) {\r\n        this.boundaryElement = boundaryElement;\r\n        this.controllerAccessor = controllerAccessor;\r\n        this.controller = null;\r\n        this.errors = [];\r\n        this.errorsInternal = [];\r\n    }\r\n    ValidationErrorsCustomAttribute.inject = function () {\r\n        return [aurelia_pal__WEBPACK_IMPORTED_MODULE_0__[\"DOM\"].Element, aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_2__[\"Lazy\"].of(ValidationController)];\r\n    };\r\n    ValidationErrorsCustomAttribute.prototype.sort = function () {\r\n        this.errorsInternal.sort(function (a, b) {\r\n            if (a.targets[0] === b.targets[0]) {\r\n                return 0;\r\n            }\r\n            // tslint:disable-next-line:no-bitwise\r\n            return a.targets[0].compareDocumentPosition(b.targets[0]) & 2 ? 1 : -1;\r\n        });\r\n    };\r\n    ValidationErrorsCustomAttribute.prototype.interestingElements = function (elements) {\r\n        var _this = this;\r\n        return elements.filter(function (e) { return _this.boundaryElement.contains(e); });\r\n    };\r\n    ValidationErrorsCustomAttribute.prototype.render = function (instruction) {\r\n        var _loop_1 = function (result) {\r\n            var index = this_1.errorsInternal.findIndex(function (x) { return x.error === result; });\r\n            if (index !== -1) {\r\n                this_1.errorsInternal.splice(index, 1);\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        for (var _i = 0, _a = instruction.unrender; _i < _a.length; _i++) {\r\n            var result = _a[_i].result;\r\n            _loop_1(result);\r\n        }\r\n        for (var _b = 0, _c = instruction.render; _b < _c.length; _b++) {\r\n            var _d = _c[_b], result = _d.result, elements = _d.elements;\r\n            if (result.valid) {\r\n                continue;\r\n            }\r\n            var targets = this.interestingElements(elements);\r\n            if (targets.length) {\r\n                this.errorsInternal.push({ error: result, targets: targets });\r\n            }\r\n        }\r\n        this.sort();\r\n        this.errors = this.errorsInternal;\r\n    };\r\n    ValidationErrorsCustomAttribute.prototype.bind = function () {\r\n        if (!this.controller) {\r\n            this.controller = this.controllerAccessor();\r\n        }\r\n        // this will call render() with the side-effect of updating this.errors\r\n        this.controller.addRenderer(this);\r\n    };\r\n    ValidationErrorsCustomAttribute.prototype.unbind = function () {\r\n        if (this.controller) {\r\n            this.controller.removeRenderer(this);\r\n        }\r\n    };\r\n    __decorate([\r\n        Object(aurelia_templating__WEBPACK_IMPORTED_MODULE_4__[\"bindable\"])({ defaultBindingMode: aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"bindingMode\"].oneWay })\r\n    ], ValidationErrorsCustomAttribute.prototype, \"controller\", void 0);\r\n    __decorate([\r\n        Object(aurelia_templating__WEBPACK_IMPORTED_MODULE_4__[\"bindable\"])({ primaryProperty: true, defaultBindingMode: aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"bindingMode\"].twoWay })\r\n    ], ValidationErrorsCustomAttribute.prototype, \"errors\", void 0);\r\n    ValidationErrorsCustomAttribute = __decorate([\r\n        Object(aurelia_templating__WEBPACK_IMPORTED_MODULE_4__[\"customAttribute\"])('validation-errors')\r\n    ], ValidationErrorsCustomAttribute);\r\n    return ValidationErrorsCustomAttribute;\r\n}());\n\nvar ValidationRendererCustomAttribute = /** @class */ (function () {\r\n    function ValidationRendererCustomAttribute() {\r\n    }\r\n    ValidationRendererCustomAttribute.prototype.created = function (view) {\r\n        this.container = view.container;\r\n    };\r\n    ValidationRendererCustomAttribute.prototype.bind = function () {\r\n        this.controller = this.container.get(ValidationController);\r\n        this.renderer = this.container.get(this.value);\r\n        this.controller.addRenderer(this.renderer);\r\n    };\r\n    ValidationRendererCustomAttribute.prototype.unbind = function () {\r\n        this.controller.removeRenderer(this.renderer);\r\n        this.controller = null;\r\n        this.renderer = null;\r\n    };\r\n    ValidationRendererCustomAttribute = __decorate([\r\n        Object(aurelia_templating__WEBPACK_IMPORTED_MODULE_4__[\"customAttribute\"])('validation-renderer')\r\n    ], ValidationRendererCustomAttribute);\r\n    return ValidationRendererCustomAttribute;\r\n}());\n\n/**\r\n * Sets, unsets and retrieves rules on an object or constructor function.\r\n */\r\nvar Rules = /** @class */ (function () {\r\n    function Rules() {\r\n    }\r\n    /**\r\n     * Applies the rules to a target.\r\n     */\r\n    Rules.set = function (target, rules) {\r\n        if (target instanceof Function) {\r\n            target = target.prototype;\r\n        }\r\n        Object.defineProperty(target, Rules.key, { enumerable: false, configurable: false, writable: true, value: rules });\r\n    };\r\n    /**\r\n     * Removes rules from a target.\r\n     */\r\n    Rules.unset = function (target) {\r\n        if (target instanceof Function) {\r\n            target = target.prototype;\r\n        }\r\n        target[Rules.key] = null;\r\n    };\r\n    /**\r\n     * Retrieves the target's rules.\r\n     */\r\n    Rules.get = function (target) {\r\n        return target[Rules.key] || null;\r\n    };\r\n    /**\r\n     * The name of the property that stores the rules.\r\n     */\r\n    Rules.key = '__rules__';\r\n    return Rules;\r\n}());\n\n// tslint:disable:no-empty\r\nvar ExpressionVisitor = /** @class */ (function () {\r\n    function ExpressionVisitor() {\r\n    }\r\n    ExpressionVisitor.prototype.visitChain = function (chain) {\r\n        this.visitArgs(chain.expressions);\r\n    };\r\n    ExpressionVisitor.prototype.visitBindingBehavior = function (behavior) {\r\n        behavior.expression.accept(this);\r\n        this.visitArgs(behavior.args);\r\n    };\r\n    ExpressionVisitor.prototype.visitValueConverter = function (converter) {\r\n        converter.expression.accept(this);\r\n        this.visitArgs(converter.args);\r\n    };\r\n    ExpressionVisitor.prototype.visitAssign = function (assign) {\r\n        assign.target.accept(this);\r\n        assign.value.accept(this);\r\n    };\r\n    ExpressionVisitor.prototype.visitConditional = function (conditional) {\r\n        conditional.condition.accept(this);\r\n        conditional.yes.accept(this);\r\n        conditional.no.accept(this);\r\n    };\r\n    ExpressionVisitor.prototype.visitAccessThis = function (access) {\r\n        access.ancestor = access.ancestor;\r\n    };\r\n    ExpressionVisitor.prototype.visitAccessScope = function (access) {\r\n        access.name = access.name;\r\n    };\r\n    ExpressionVisitor.prototype.visitAccessMember = function (access) {\r\n        access.object.accept(this);\r\n    };\r\n    ExpressionVisitor.prototype.visitAccessKeyed = function (access) {\r\n        access.object.accept(this);\r\n        access.key.accept(this);\r\n    };\r\n    ExpressionVisitor.prototype.visitCallScope = function (call) {\r\n        this.visitArgs(call.args);\r\n    };\r\n    ExpressionVisitor.prototype.visitCallFunction = function (call) {\r\n        call.func.accept(this);\r\n        this.visitArgs(call.args);\r\n    };\r\n    ExpressionVisitor.prototype.visitCallMember = function (call) {\r\n        call.object.accept(this);\r\n        this.visitArgs(call.args);\r\n    };\r\n    ExpressionVisitor.prototype.visitPrefix = function (prefix) {\r\n        prefix.expression.accept(this);\r\n    };\r\n    ExpressionVisitor.prototype.visitBinary = function (binary) {\r\n        binary.left.accept(this);\r\n        binary.right.accept(this);\r\n    };\r\n    ExpressionVisitor.prototype.visitLiteralPrimitive = function (literal) {\r\n        literal.value = literal.value;\r\n    };\r\n    ExpressionVisitor.prototype.visitLiteralArray = function (literal) {\r\n        this.visitArgs(literal.elements);\r\n    };\r\n    ExpressionVisitor.prototype.visitLiteralObject = function (literal) {\r\n        this.visitArgs(literal.values);\r\n    };\r\n    ExpressionVisitor.prototype.visitLiteralString = function (literal) {\r\n        literal.value = literal.value;\r\n    };\r\n    ExpressionVisitor.prototype.visitArgs = function (args) {\r\n        for (var i = 0; i < args.length; i++) {\r\n            args[i].accept(this);\r\n        }\r\n    };\r\n    return ExpressionVisitor;\r\n}());\n\nvar ValidationMessageParser = /** @class */ (function () {\r\n    function ValidationMessageParser(bindinqLanguage) {\r\n        this.bindinqLanguage = bindinqLanguage;\r\n        this.emptyStringExpression = new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"LiteralString\"]('');\r\n        this.nullExpression = new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"LiteralPrimitive\"](null);\r\n        this.undefinedExpression = new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"LiteralPrimitive\"](undefined);\r\n        this.cache = {};\r\n    }\r\n    ValidationMessageParser.prototype.parse = function (message) {\r\n        if (this.cache[message] !== undefined) {\r\n            return this.cache[message];\r\n        }\r\n        var parts = this.bindinqLanguage.parseInterpolation(null, message);\r\n        if (parts === null) {\r\n            return new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"LiteralString\"](message);\r\n        }\r\n        var expression = new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"LiteralString\"](parts[0]);\r\n        for (var i = 1; i < parts.length; i += 2) {\r\n            expression = new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"Binary\"]('+', expression, new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"Binary\"]('+', this.coalesce(parts[i]), new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"LiteralString\"](parts[i + 1])));\r\n        }\r\n        MessageExpressionValidator.validate(expression, message);\r\n        this.cache[message] = expression;\r\n        return expression;\r\n    };\r\n    ValidationMessageParser.prototype.coalesce = function (part) {\r\n        // part === null || part === undefined ? '' : part\r\n        return new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"Conditional\"](new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"Binary\"]('||', new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"Binary\"]('===', part, this.nullExpression), new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"Binary\"]('===', part, this.undefinedExpression)), this.emptyStringExpression, new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__[\"CallMember\"](part, 'toString', []));\r\n    };\r\n    ValidationMessageParser.inject = [aurelia_templating__WEBPACK_IMPORTED_MODULE_4__[\"BindingLanguage\"]];\r\n    return ValidationMessageParser;\r\n}());\r\nvar MessageExpressionValidator = /** @class */ (function (_super) {\r\n    __extends(MessageExpressionValidator, _super);\r\n    function MessageExpressionValidator(originalMessage) {\r\n        var _this = _super.call(this) || this;\r\n        _this.originalMessage = originalMessage;\r\n        return _this;\r\n    }\r\n    MessageExpressionValidator.validate = function (expression, originalMessage) {\r\n        var visitor = new MessageExpressionValidator(originalMessage);\r\n        expression.accept(visitor);\r\n    };\r\n    MessageExpressionValidator.prototype.visitAccessScope = function (access) {\r\n        if (access.ancestor !== 0) {\r\n            throw new Error('$parent is not permitted in validation message expressions.');\r\n        }\r\n        if (['displayName', 'propertyName', 'value', 'object', 'config', 'getDisplayName'].indexOf(access.name) !== -1) {\r\n            Object(aurelia_logging__WEBPACK_IMPORTED_MODULE_5__[\"getLogger\"])('aurelia-validation')\r\n                // tslint:disable-next-line:max-line-length\r\n                .warn(\"Did you mean to use \\\"$\" + access.name + \"\\\" instead of \\\"\" + access.name + \"\\\" in this validation message template: \\\"\" + this.originalMessage + \"\\\"?\");\r\n        }\r\n    };\r\n    return MessageExpressionValidator;\r\n}(ExpressionVisitor));\n\n/**\r\n * Dictionary of validation messages. [messageKey]: messageExpression\r\n */\r\nvar validationMessages = {\r\n    /**\r\n     * The default validation message. Used with rules that have no standard message.\r\n     */\r\n    default: \"${$displayName} is invalid.\",\r\n    required: \"${$displayName} is required.\",\r\n    matches: \"${$displayName} is not correctly formatted.\",\r\n    email: \"${$displayName} is not a valid email.\",\r\n    minLength: \"${$displayName} must be at least ${$config.length} character${$config.length === 1 ? '' : 's'}.\",\r\n    maxLength: \"${$displayName} cannot be longer than ${$config.length} character${$config.length === 1 ? '' : 's'}.\",\r\n    minItems: \"${$displayName} must contain at least ${$config.count} item${$config.count === 1 ? '' : 's'}.\",\r\n    maxItems: \"${$displayName} cannot contain more than ${$config.count} item${$config.count === 1 ? '' : 's'}.\",\r\n    equals: \"${$displayName} must be ${$config.expectedValue}.\",\r\n};\r\n/**\r\n * Retrieves validation messages and property display names.\r\n */\r\nvar ValidationMessageProvider = /** @class */ (function () {\r\n    function ValidationMessageProvider(parser) {\r\n        this.parser = parser;\r\n    }\r\n    /**\r\n     * Returns a message binding expression that corresponds to the key.\r\n     * @param key The message key.\r\n     */\r\n    ValidationMessageProvider.prototype.getMessage = function (key) {\r\n        var message;\r\n        if (key in validationMessages) {\r\n            message = validationMessages[key];\r\n        }\r\n        else {\r\n            message = validationMessages['default'];\r\n        }\r\n        return this.parser.parse(message);\r\n    };\r\n    /**\r\n     * Formulates a property display name using the property name and the configured\r\n     * displayName (if provided).\r\n     * Override this with your own custom logic.\r\n     * @param propertyName The property name.\r\n     */\r\n    ValidationMessageProvider.prototype.getDisplayName = function (propertyName, displayName) {\r\n        if (displayName !== null && displayName !== undefined) {\r\n            return (displayName instanceof Function) ? displayName() : displayName;\r\n        }\r\n        // split on upper-case letters.\r\n        var words = propertyName.toString().split(/(?=[A-Z])/).join(' ');\r\n        // capitalize first letter.\r\n        return words.charAt(0).toUpperCase() + words.slice(1);\r\n    };\r\n    ValidationMessageProvider.inject = [ValidationMessageParser];\r\n    return ValidationMessageProvider;\r\n}());\n\n/**\r\n * Validates.\r\n * Responsible for validating objects and properties.\r\n */\r\nvar StandardValidator = /** @class */ (function (_super) {\r\n    __extends(StandardValidator, _super);\r\n    function StandardValidator(messageProvider, resources) {\r\n        var _this = _super.call(this) || this;\r\n        _this.messageProvider = messageProvider;\r\n        _this.lookupFunctions = resources.lookupFunctions;\r\n        _this.getDisplayName = messageProvider.getDisplayName.bind(messageProvider);\r\n        return _this;\r\n    }\r\n    /**\r\n     * Validates the specified property.\r\n     * @param object The object to validate.\r\n     * @param propertyName The name of the property to validate.\r\n     * @param rules Optional. If unspecified, the rules will be looked up using the metadata\r\n     * for the object created by ValidationRules....on(class/object)\r\n     */\r\n    StandardValidator.prototype.validateProperty = function (object, propertyName, rules) {\r\n        return this.validate(object, propertyName, rules || null);\r\n    };\r\n    /**\r\n     * Validates all rules for specified object and it's properties.\r\n     * @param object The object to validate.\r\n     * @param rules Optional. If unspecified, the rules will be looked up using the metadata\r\n     * for the object created by ValidationRules....on(class/object)\r\n     */\r\n    StandardValidator.prototype.validateObject = function (object, rules) {\r\n        return this.validate(object, null, rules || null);\r\n    };\r\n    /**\r\n     * Determines whether a rule exists in a set of rules.\r\n     * @param rules The rules to search.\r\n     * @parem rule The rule to find.\r\n     */\r\n    StandardValidator.prototype.ruleExists = function (rules, rule) {\r\n        var i = rules.length;\r\n        while (i--) {\r\n            if (rules[i].indexOf(rule) !== -1) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    StandardValidator.prototype.getMessage = function (rule, object, value) {\r\n        var expression = rule.message || this.messageProvider.getMessage(rule.messageKey);\r\n        // tslint:disable-next-line:prefer-const\r\n        var _a = rule.property, propertyName = _a.name, displayName = _a.displayName;\r\n        if (propertyName !== null) {\r\n            displayName = this.messageProvider.getDisplayName(propertyName, displayName);\r\n        }\r\n        var overrideContext = {\r\n            $displayName: displayName,\r\n            $propertyName: propertyName,\r\n            $value: value,\r\n            $object: object,\r\n            $config: rule.config,\r\n            // returns the name of a given property, given just the property name (irrespective of the property's displayName)\r\n            // split on capital letters, first letter ensured to be capitalized\r\n            $getDisplayName: this.getDisplayName\r\n        };\r\n        return expression.evaluate({ bindingContext: object, overrideContext: overrideContext }, this.lookupFunctions);\r\n    };\r\n    StandardValidator.prototype.validateRuleSequence = function (object, propertyName, ruleSequence, sequence, results) {\r\n        var _this = this;\r\n        // are we validating all properties or a single property?\r\n        var validateAllProperties = propertyName === null || propertyName === undefined;\r\n        var rules = ruleSequence[sequence];\r\n        var allValid = true;\r\n        // validate each rule.\r\n        var promises = [];\r\n        var _loop_1 = function (i) {\r\n            var rule = rules[i];\r\n            // is the rule related to the property we're validating.\r\n            // tslint:disable-next-line:triple-equals | Use loose equality for property keys\r\n            if (!validateAllProperties && rule.property.name != propertyName) {\r\n                return \"continue\";\r\n            }\r\n            // is this a conditional rule? is the condition met?\r\n            if (rule.when && !rule.when(object)) {\r\n                return \"continue\";\r\n            }\r\n            // validate.\r\n            var value = rule.property.name === null ? object : object[rule.property.name];\r\n            var promiseOrBoolean = rule.condition(value, object);\r\n            if (!(promiseOrBoolean instanceof Promise)) {\r\n                promiseOrBoolean = Promise.resolve(promiseOrBoolean);\r\n            }\r\n            promises.push(promiseOrBoolean.then(function (valid) {\r\n                var message = valid ? null : _this.getMessage(rule, object, value);\r\n                results.push(new ValidateResult(rule, object, rule.property.name, valid, message));\r\n                allValid = allValid && valid;\r\n                return valid;\r\n            }));\r\n        };\r\n        for (var i = 0; i < rules.length; i++) {\r\n            _loop_1(i);\r\n        }\r\n        return Promise.all(promises)\r\n            .then(function () {\r\n            sequence++;\r\n            if (allValid && sequence < ruleSequence.length) {\r\n                return _this.validateRuleSequence(object, propertyName, ruleSequence, sequence, results);\r\n            }\r\n            return results;\r\n        });\r\n    };\r\n    StandardValidator.prototype.validate = function (object, propertyName, rules) {\r\n        // rules specified?\r\n        if (!rules) {\r\n            // no. attempt to locate the rules.\r\n            rules = Rules.get(object);\r\n        }\r\n        // any rules?\r\n        if (!rules || rules.length === 0) {\r\n            return Promise.resolve([]);\r\n        }\r\n        return this.validateRuleSequence(object, propertyName, rules, 0, []);\r\n    };\r\n    StandardValidator.inject = [ValidationMessageProvider, aurelia_templating__WEBPACK_IMPORTED_MODULE_4__[\"ViewResources\"]];\r\n    return StandardValidator;\r\n}(Validator));\n\n/**\r\n * Part of the fluent rule API. Enables customizing property rules.\r\n */\r\nvar FluentRuleCustomizer = /** @class */ (function () {\r\n    function FluentRuleCustomizer(property, condition, config, fluentEnsure, fluentRules, parsers) {\r\n        if (config === void 0) { config = {}; }\r\n        this.fluentEnsure = fluentEnsure;\r\n        this.fluentRules = fluentRules;\r\n        this.parsers = parsers;\r\n        this.rule = {\r\n            property: property,\r\n            condition: condition,\r\n            config: config,\r\n            when: null,\r\n            messageKey: 'default',\r\n            message: null,\r\n            sequence: fluentRules.sequence\r\n        };\r\n        this.fluentEnsure._addRule(this.rule);\r\n    }\r\n    /**\r\n     * Validate subsequent rules after previously declared rules have\r\n     * been validated successfully. Use to postpone validation of costly\r\n     * rules until less expensive rules pass validation.\r\n     */\r\n    FluentRuleCustomizer.prototype.then = function () {\r\n        this.fluentRules.sequence++;\r\n        return this;\r\n    };\r\n    /**\r\n     * Specifies the key to use when looking up the rule's validation message.\r\n     */\r\n    FluentRuleCustomizer.prototype.withMessageKey = function (key) {\r\n        this.rule.messageKey = key;\r\n        this.rule.message = null;\r\n        return this;\r\n    };\r\n    /**\r\n     * Specifies rule's validation message.\r\n     */\r\n    FluentRuleCustomizer.prototype.withMessage = function (message) {\r\n        this.rule.messageKey = 'custom';\r\n        this.rule.message = this.parsers.message.parse(message);\r\n        return this;\r\n    };\r\n    /**\r\n     * Specifies a condition that must be met before attempting to validate the rule.\r\n     * @param condition A function that accepts the object as a parameter and returns true\r\n     * or false whether the rule should be evaluated.\r\n     */\r\n    FluentRuleCustomizer.prototype.when = function (condition) {\r\n        this.rule.when = condition;\r\n        return this;\r\n    };\r\n    /**\r\n     * Tags the rule instance, enabling the rule to be found easily\r\n     * using ValidationRules.taggedRules(rules, tag)\r\n     */\r\n    FluentRuleCustomizer.prototype.tag = function (tag) {\r\n        this.rule.tag = tag;\r\n        return this;\r\n    };\r\n    ///// FluentEnsure APIs /////\r\n    /**\r\n     * Target a property with validation rules.\r\n     * @param property The property to target. Can be the property name or a property accessor function.\r\n     */\r\n    FluentRuleCustomizer.prototype.ensure = function (subject) {\r\n        return this.fluentEnsure.ensure(subject);\r\n    };\r\n    /**\r\n     * Targets an object with validation rules.\r\n     */\r\n    FluentRuleCustomizer.prototype.ensureObject = function () {\r\n        return this.fluentEnsure.ensureObject();\r\n    };\r\n    Object.defineProperty(FluentRuleCustomizer.prototype, \"rules\", {\r\n        /**\r\n         * Rules that have been defined using the fluent API.\r\n         */\r\n        get: function () {\r\n            return this.fluentEnsure.rules;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Applies the rules to a class or object, making them discoverable by the StandardValidator.\r\n     * @param target A class or object.\r\n     */\r\n    FluentRuleCustomizer.prototype.on = function (target) {\r\n        return this.fluentEnsure.on(target);\r\n    };\r\n    ///////// FluentRules APIs /////////\r\n    /**\r\n     * Applies an ad-hoc rule function to the ensured property or object.\r\n     * @param condition The function to validate the rule.\r\n     * Will be called with two arguments, the property value and the object.\r\n     * Should return a boolean or a Promise that resolves to a boolean.\r\n     */\r\n    FluentRuleCustomizer.prototype.satisfies = function (condition, config) {\r\n        return this.fluentRules.satisfies(condition, config);\r\n    };\r\n    /**\r\n     * Applies a rule by name.\r\n     * @param name The name of the custom or standard rule.\r\n     * @param args The rule's arguments.\r\n     */\r\n    FluentRuleCustomizer.prototype.satisfiesRule = function (name) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var _a;\r\n        return (_a = this.fluentRules).satisfiesRule.apply(_a, [name].concat(args));\r\n    };\r\n    /**\r\n     * Applies the \"required\" rule to the property.\r\n     * The value cannot be null, undefined or whitespace.\r\n     */\r\n    FluentRuleCustomizer.prototype.required = function () {\r\n        return this.fluentRules.required();\r\n    };\r\n    /**\r\n     * Applies the \"matches\" rule to the property.\r\n     * Value must match the specified regular expression.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.matches = function (regex) {\r\n        return this.fluentRules.matches(regex);\r\n    };\r\n    /**\r\n     * Applies the \"email\" rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.email = function () {\r\n        return this.fluentRules.email();\r\n    };\r\n    /**\r\n     * Applies the \"minLength\" STRING validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.minLength = function (length) {\r\n        return this.fluentRules.minLength(length);\r\n    };\r\n    /**\r\n     * Applies the \"maxLength\" STRING validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.maxLength = function (length) {\r\n        return this.fluentRules.maxLength(length);\r\n    };\r\n    /**\r\n     * Applies the \"minItems\" ARRAY validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.minItems = function (count) {\r\n        return this.fluentRules.minItems(count);\r\n    };\r\n    /**\r\n     * Applies the \"maxItems\" ARRAY validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.maxItems = function (count) {\r\n        return this.fluentRules.maxItems(count);\r\n    };\r\n    /**\r\n     * Applies the \"equals\" validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.equals = function (expectedValue) {\r\n        return this.fluentRules.equals(expectedValue);\r\n    };\r\n    return FluentRuleCustomizer;\r\n}());\r\n/**\r\n * Part of the fluent rule API. Enables applying rules to properties and objects.\r\n */\r\nvar FluentRules = /** @class */ (function () {\r\n    function FluentRules(fluentEnsure, parsers, property) {\r\n        this.fluentEnsure = fluentEnsure;\r\n        this.parsers = parsers;\r\n        this.property = property;\r\n        /**\r\n         * Current rule sequence number. Used to postpone evaluation of rules until rules\r\n         * with lower sequence number have successfully validated. The \"then\" fluent API method\r\n         * manages this property, there's usually no need to set it directly.\r\n         */\r\n        this.sequence = 0;\r\n    }\r\n    /**\r\n     * Sets the display name of the ensured property.\r\n     */\r\n    FluentRules.prototype.displayName = function (name) {\r\n        this.property.displayName = name;\r\n        return this;\r\n    };\r\n    /**\r\n     * Applies an ad-hoc rule function to the ensured property or object.\r\n     * @param condition The function to validate the rule.\r\n     * Will be called with two arguments, the property value and the object.\r\n     * Should return a boolean or a Promise that resolves to a boolean.\r\n     */\r\n    FluentRules.prototype.satisfies = function (condition, config) {\r\n        return new FluentRuleCustomizer(this.property, condition, config, this.fluentEnsure, this, this.parsers);\r\n    };\r\n    /**\r\n     * Applies a rule by name.\r\n     * @param name The name of the custom or standard rule.\r\n     * @param args The rule's arguments.\r\n     */\r\n    FluentRules.prototype.satisfiesRule = function (name) {\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var rule = FluentRules.customRules[name];\r\n        if (!rule) {\r\n            // standard rule?\r\n            rule = this[name];\r\n            if (rule instanceof Function) {\r\n                return rule.call.apply(rule, [this].concat(args));\r\n            }\r\n            throw new Error(\"Rule with name \\\"\" + name + \"\\\" does not exist.\");\r\n        }\r\n        var config = rule.argsToConfig ? rule.argsToConfig.apply(rule, args) : undefined;\r\n        return this.satisfies(function (value, obj) {\r\n            var _a;\r\n            return (_a = rule.condition).call.apply(_a, [_this, value, obj].concat(args));\r\n        }, config)\r\n            .withMessageKey(name);\r\n    };\r\n    /**\r\n     * Applies the \"required\" rule to the property.\r\n     * The value cannot be null, undefined or whitespace.\r\n     */\r\n    FluentRules.prototype.required = function () {\r\n        return this.satisfies(function (value) {\r\n            return value !== null\r\n                && value !== undefined\r\n                && !(isString(value) && !/\\S/.test(value));\r\n        }).withMessageKey('required');\r\n    };\r\n    /**\r\n     * Applies the \"matches\" rule to the property.\r\n     * Value must match the specified regular expression.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRules.prototype.matches = function (regex) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value.length === 0 || regex.test(value); })\r\n            .withMessageKey('matches');\r\n    };\r\n    /**\r\n     * Applies the \"email\" rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRules.prototype.email = function () {\r\n        // regex from https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address\r\n        /* tslint:disable:max-line-length */\r\n        return this.matches(/^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/)\r\n            /* tslint:enable:max-line-length */\r\n            .withMessageKey('email');\r\n    };\r\n    /**\r\n     * Applies the \"minLength\" STRING validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRules.prototype.minLength = function (length) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value.length === 0 || value.length >= length; }, { length: length })\r\n            .withMessageKey('minLength');\r\n    };\r\n    /**\r\n     * Applies the \"maxLength\" STRING validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRules.prototype.maxLength = function (length) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value.length === 0 || value.length <= length; }, { length: length })\r\n            .withMessageKey('maxLength');\r\n    };\r\n    /**\r\n     * Applies the \"minItems\" ARRAY validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRules.prototype.minItems = function (count) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value.length >= count; }, { count: count })\r\n            .withMessageKey('minItems');\r\n    };\r\n    /**\r\n     * Applies the \"maxItems\" ARRAY validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRules.prototype.maxItems = function (count) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value.length <= count; }, { count: count })\r\n            .withMessageKey('maxItems');\r\n    };\r\n    /**\r\n     * Applies the \"equals\" validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRules.prototype.equals = function (expectedValue) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value === '' || value === expectedValue; }, { expectedValue: expectedValue })\r\n            .withMessageKey('equals');\r\n    };\r\n    FluentRules.customRules = {};\r\n    return FluentRules;\r\n}());\r\n/**\r\n * Part of the fluent rule API. Enables targeting properties and objects with rules.\r\n */\r\nvar FluentEnsure = /** @class */ (function () {\r\n    function FluentEnsure(parsers) {\r\n        this.parsers = parsers;\r\n        /**\r\n         * Rules that have been defined using the fluent API.\r\n         */\r\n        this.rules = [];\r\n    }\r\n    /**\r\n     * Target a property with validation rules.\r\n     * @param property The property to target. Can be the property name or a property accessor\r\n     * function.\r\n     */\r\n    FluentEnsure.prototype.ensure = function (property) {\r\n        this.assertInitialized();\r\n        var name = this.parsers.property.parse(property);\r\n        var fluentRules = new FluentRules(this, this.parsers, { name: name, displayName: null });\r\n        return this.mergeRules(fluentRules, name);\r\n    };\r\n    /**\r\n     * Targets an object with validation rules.\r\n     */\r\n    FluentEnsure.prototype.ensureObject = function () {\r\n        this.assertInitialized();\r\n        var fluentRules = new FluentRules(this, this.parsers, { name: null, displayName: null });\r\n        return this.mergeRules(fluentRules, null);\r\n    };\r\n    /**\r\n     * Applies the rules to a class or object, making them discoverable by the StandardValidator.\r\n     * @param target A class or object.\r\n     */\r\n    FluentEnsure.prototype.on = function (target) {\r\n        Rules.set(target, this.rules);\r\n        return this;\r\n    };\r\n    /**\r\n     * Adds a rule definition to the sequenced ruleset.\r\n     * @internal\r\n     */\r\n    FluentEnsure.prototype._addRule = function (rule) {\r\n        while (this.rules.length < rule.sequence + 1) {\r\n            this.rules.push([]);\r\n        }\r\n        this.rules[rule.sequence].push(rule);\r\n    };\r\n    FluentEnsure.prototype.assertInitialized = function () {\r\n        if (this.parsers) {\r\n            return;\r\n        }\r\n        throw new Error(\"Did you forget to add \\\".plugin('aurelia-validation')\\\" to your main.js?\");\r\n    };\r\n    FluentEnsure.prototype.mergeRules = function (fluentRules, propertyName) {\r\n        // tslint:disable-next-line:triple-equals | Use loose equality for property keys\r\n        var existingRules = this.rules.find(function (r) { return r.length > 0 && r[0].property.name == propertyName; });\r\n        if (existingRules) {\r\n            var rule = existingRules[existingRules.length - 1];\r\n            fluentRules.sequence = rule.sequence;\r\n            if (rule.property.displayName !== null) {\r\n                fluentRules = fluentRules.displayName(rule.property.displayName);\r\n            }\r\n        }\r\n        return fluentRules;\r\n    };\r\n    return FluentEnsure;\r\n}());\r\n/**\r\n * Fluent rule definition API.\r\n */\r\nvar ValidationRules = /** @class */ (function () {\r\n    function ValidationRules() {\r\n    }\r\n    ValidationRules.initialize = function (messageParser, propertyParser) {\r\n        this.parsers = {\r\n            message: messageParser,\r\n            property: propertyParser\r\n        };\r\n    };\r\n    /**\r\n     * Target a property with validation rules.\r\n     * @param property The property to target. Can be the property name or a property accessor function.\r\n     */\r\n    ValidationRules.ensure = function (property) {\r\n        return new FluentEnsure(ValidationRules.parsers).ensure(property);\r\n    };\r\n    /**\r\n     * Targets an object with validation rules.\r\n     */\r\n    ValidationRules.ensureObject = function () {\r\n        return new FluentEnsure(ValidationRules.parsers).ensureObject();\r\n    };\r\n    /**\r\n     * Defines a custom rule.\r\n     * @param name The name of the custom rule. Also serves as the message key.\r\n     * @param condition The rule function.\r\n     * @param message The message expression\r\n     * @param argsToConfig A function that maps the rule's arguments to a \"config\"\r\n     * object that can be used when evaluating the message expression.\r\n     */\r\n    ValidationRules.customRule = function (name, condition, message, argsToConfig) {\r\n        validationMessages[name] = message;\r\n        FluentRules.customRules[name] = { condition: condition, argsToConfig: argsToConfig };\r\n    };\r\n    /**\r\n     * Returns rules with the matching tag.\r\n     * @param rules The rules to search.\r\n     * @param tag The tag to search for.\r\n     */\r\n    ValidationRules.taggedRules = function (rules, tag) {\r\n        return rules.map(function (x) { return x.filter(function (r) { return r.tag === tag; }); });\r\n    };\r\n    /**\r\n     * Returns rules that have no tag.\r\n     * @param rules The rules to search.\r\n     */\r\n    ValidationRules.untaggedRules = function (rules) {\r\n        return rules.map(function (x) { return x.filter(function (r) { return r.tag === undefined; }); });\r\n    };\r\n    /**\r\n     * Removes the rules from a class or object.\r\n     * @param target A class or object.\r\n     */\r\n    ValidationRules.off = function (target) {\r\n        Rules.unset(target);\r\n    };\r\n    return ValidationRules;\r\n}());\n\n// Exports\r\n/**\r\n * Aurelia Validation Configuration API\r\n */\r\nvar AureliaValidationConfiguration = /** @class */ (function () {\r\n    function AureliaValidationConfiguration() {\r\n        this.validatorType = StandardValidator;\r\n    }\r\n    /**\r\n     * Use a custom Validator implementation.\r\n     */\r\n    AureliaValidationConfiguration.prototype.customValidator = function (type) {\r\n        this.validatorType = type;\r\n    };\r\n    /**\r\n     * Applies the configuration.\r\n     */\r\n    AureliaValidationConfiguration.prototype.apply = function (container) {\r\n        var validator = container.get(this.validatorType);\r\n        container.registerInstance(Validator, validator);\r\n    };\r\n    return AureliaValidationConfiguration;\r\n}());\r\n/**\r\n * Configures the plugin.\r\n */\r\nfunction configure(\r\n// tslint:disable-next-line:ban-types\r\nframeworkConfig, callback) {\r\n    // the fluent rule definition API needs the parser to translate messages\r\n    // to interpolation expressions.\r\n    var messageParser = frameworkConfig.container.get(ValidationMessageParser);\r\n    var propertyParser = frameworkConfig.container.get(PropertyAccessorParser);\r\n    ValidationRules.initialize(messageParser, propertyParser);\r\n    // configure...\r\n    var config = new AureliaValidationConfiguration();\r\n    if (callback instanceof Function) {\r\n        callback(config);\r\n    }\r\n    config.apply(frameworkConfig.container);\r\n    // globalize the behaviors.\r\n    if (frameworkConfig.globalResources) {\r\n        frameworkConfig.globalResources(ValidateBindingBehavior, ValidateManuallyBindingBehavior, ValidateOnBlurBindingBehavior, ValidateOnChangeBindingBehavior, ValidateOnChangeOrBlurBindingBehavior, ValidationErrorsCustomAttribute, ValidationRendererCustomAttribute);\r\n    }\r\n}\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! bluebird */ \"25Wt\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOE5lRy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLXZhbGlkYXRpb24vZGlzdC9uYXRpdmUtbW9kdWxlcy9hdXJlbGlhLXZhbGlkYXRpb24uanM/ZjBkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBET00gfSBmcm9tICdhdXJlbGlhLXBhbCc7XG5pbXBvcnQgeyBBY2Nlc3NNZW1iZXIsIEFjY2Vzc1Njb3BlLCBBY2Nlc3NLZXllZCwgQmluZGluZ0JlaGF2aW9yLCBWYWx1ZUNvbnZlcnRlciwgZ2V0Q29udGV4dEZvciwgUGFyc2VyLCBiaW5kaW5nQmVoYXZpb3IsIGJpbmRpbmdNb2RlLCBMaXRlcmFsU3RyaW5nLCBCaW5hcnksIENvbmRpdGlvbmFsLCBMaXRlcmFsUHJpbWl0aXZlLCBDYWxsTWVtYmVyIH0gZnJvbSAnYXVyZWxpYS1iaW5kaW5nJztcbmltcG9ydCB7IE9wdGlvbmFsLCBMYXp5IH0gZnJvbSAnYXVyZWxpYS1kZXBlbmRlbmN5LWluamVjdGlvbic7XG5pbXBvcnQgeyBUYXNrUXVldWUgfSBmcm9tICdhdXJlbGlhLXRhc2stcXVldWUnO1xuaW1wb3J0IHsgY3VzdG9tQXR0cmlidXRlLCBiaW5kYWJsZSwgQmluZGluZ0xhbmd1YWdlLCBWaWV3UmVzb3VyY2VzIH0gZnJvbSAnYXVyZWxpYS10ZW1wbGF0aW5nJztcbmltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gJ2F1cmVsaWEtbG9nZ2luZyc7XG5cbi8qKlxyXG4gKiBHZXRzIHRoZSBET00gZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIGRhdGEtYmluZGluZy4gTW9zdCBvZiB0aGUgdGltZSBpdCdzXHJcbiAqIHRoZSBiaW5kaW5nLnRhcmdldCBidXQgc29tZXRpbWVzIGJpbmRpbmcudGFyZ2V0IGlzIGFuIGF1cmVsaWEgY3VzdG9tIGVsZW1lbnQsXHJcbiAqIG9yIGN1c3RvbSBhdHRyaWJ1dGUgd2hpY2ggaXMgYSBqYXZhc2NyaXB0IFwiY2xhc3NcIiBpbnN0YW5jZSwgc28gd2UgbmVlZCB0byB1c2VcclxuICogdGhlIGNvbnRyb2xsZXIncyBjb250YWluZXIgdG8gcmV0cmlldmUgdGhlIGFjdHVhbCBET00gZWxlbWVudC5cclxuICovXHJcbmZ1bmN0aW9uIGdldFRhcmdldERPTUVsZW1lbnQoYmluZGluZywgdmlldykge1xyXG4gICAgdmFyIHRhcmdldCA9IGJpbmRpbmcudGFyZ2V0O1xyXG4gICAgLy8gRE9NIGVsZW1lbnRcclxuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIC8vIGN1c3RvbSBlbGVtZW50IG9yIGN1c3RvbSBhdHRyaWJ1dGVcclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpwcmVmZXItY29uc3RcclxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHZpZXcuY29udHJvbGxlcnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xyXG4gICAgICAgIHZhciBjb250cm9sbGVyID0gdmlldy5jb250cm9sbGVyc1tpXTtcclxuICAgICAgICBpZiAoY29udHJvbGxlci52aWV3TW9kZWwgPT09IHRhcmdldCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGNvbnRyb2xsZXIuY29udGFpbmVyLmdldChET00uRWxlbWVudCk7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gbG9jYXRlIHRhcmdldCBlbGVtZW50IGZvciBcXFwiXCIgKyBiaW5kaW5nLnNvdXJjZUV4cHJlc3Npb24gKyBcIlxcXCIuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBsb2NhdGUgdGFyZ2V0IGVsZW1lbnQgZm9yIFxcXCJcIiArIGJpbmRpbmcuc291cmNlRXhwcmVzc2lvbiArIFwiXFxcIi5cIik7XHJcbn1cblxuZnVuY3Rpb24gZ2V0T2JqZWN0KGV4cHJlc3Npb24sIG9iamVjdEV4cHJlc3Npb24sIHNvdXJjZSkge1xyXG4gICAgdmFyIHZhbHVlID0gb2JqZWN0RXhwcmVzc2lvbi5ldmFsdWF0ZShzb3VyY2UsIG51bGwpO1xyXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgJ1wiICsgb2JqZWN0RXhwcmVzc2lvbiArIFwiJyBwYXJ0IG9mICdcIiArIGV4cHJlc3Npb24gKyBcIicgZXZhbHVhdGVzIHRvIFwiICsgdmFsdWUgKyBcIiBpbnN0ZWFkIG9mIGFuIG9iamVjdCwgbnVsbCBvciB1bmRlZmluZWQuXCIpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgdGhlIG9iamVjdCBhbmQgcHJvcGVydHkgbmFtZSBmb3IgdGhlIHNwZWNpZmllZCBleHByZXNzaW9uLlxyXG4gKiBAcGFyYW0gZXhwcmVzc2lvbiBUaGUgZXhwcmVzc2lvblxyXG4gKiBAcGFyYW0gc291cmNlIFRoZSBzY29wZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UHJvcGVydHlJbmZvKGV4cHJlc3Npb24sIHNvdXJjZSkge1xyXG4gICAgdmFyIG9yaWdpbmFsRXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcbiAgICB3aGlsZSAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEJpbmRpbmdCZWhhdmlvciB8fCBleHByZXNzaW9uIGluc3RhbmNlb2YgVmFsdWVDb252ZXJ0ZXIpIHtcclxuICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5leHByZXNzaW9uO1xyXG4gICAgfVxyXG4gICAgdmFyIG9iamVjdDtcclxuICAgIHZhciBwcm9wZXJ0eU5hbWU7XHJcbiAgICBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFjY2Vzc1Njb3BlKSB7XHJcbiAgICAgICAgb2JqZWN0ID0gZ2V0Q29udGV4dEZvcihleHByZXNzaW9uLm5hbWUsIHNvdXJjZSwgZXhwcmVzc2lvbi5hbmNlc3Rvcik7XHJcbiAgICAgICAgcHJvcGVydHlOYW1lID0gZXhwcmVzc2lvbi5uYW1lO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFjY2Vzc01lbWJlcikge1xyXG4gICAgICAgIG9iamVjdCA9IGdldE9iamVjdChvcmlnaW5hbEV4cHJlc3Npb24sIGV4cHJlc3Npb24ub2JqZWN0LCBzb3VyY2UpO1xyXG4gICAgICAgIHByb3BlcnR5TmFtZSA9IGV4cHJlc3Npb24ubmFtZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBBY2Nlc3NLZXllZCkge1xyXG4gICAgICAgIG9iamVjdCA9IGdldE9iamVjdChvcmlnaW5hbEV4cHJlc3Npb24sIGV4cHJlc3Npb24ub2JqZWN0LCBzb3VyY2UpO1xyXG4gICAgICAgIHByb3BlcnR5TmFtZSA9IGV4cHJlc3Npb24ua2V5LmV2YWx1YXRlKHNvdXJjZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHByZXNzaW9uICdcIiArIG9yaWdpbmFsRXhwcmVzc2lvbiArIFwiJyBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSB2YWxpZGF0ZSBiaW5kaW5nLWJlaGF2aW9yLlwiKTtcclxuICAgIH1cclxuICAgIGlmIChvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiB7IG9iamVjdDogb2JqZWN0LCBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSB9O1xyXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XHJcbn1cclxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJztcclxufVxuXG52YXIgUHJvcGVydHlBY2Nlc3NvclBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFByb3BlcnR5QWNjZXNzb3JQYXJzZXIocGFyc2VyKSB7XHJcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB9XHJcbiAgICBQcm9wZXJ0eUFjY2Vzc29yUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhwcm9wZXJ0eSkgfHwgaXNOdW1iZXIocHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFjY2Vzc29yVGV4dCA9IGdldEFjY2Vzc29yRXhwcmVzc2lvbihwcm9wZXJ0eS50b1N0cmluZygpKTtcclxuICAgICAgICB2YXIgYWNjZXNzb3IgPSB0aGlzLnBhcnNlci5wYXJzZShhY2Nlc3NvclRleHQpO1xyXG4gICAgICAgIGlmIChhY2Nlc3NvciBpbnN0YW5jZW9mIEFjY2Vzc1Njb3BlXHJcbiAgICAgICAgICAgIHx8IGFjY2Vzc29yIGluc3RhbmNlb2YgQWNjZXNzTWVtYmVyICYmIGFjY2Vzc29yLm9iamVjdCBpbnN0YW5jZW9mIEFjY2Vzc1Njb3BlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3Nvci5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3BlcnR5IGV4cHJlc3Npb246IFxcXCJcIiArIGFjY2Vzc29yICsgXCJcXFwiXCIpO1xyXG4gICAgfTtcclxuICAgIFByb3BlcnR5QWNjZXNzb3JQYXJzZXIuaW5qZWN0ID0gW1BhcnNlcl07XHJcbiAgICByZXR1cm4gUHJvcGVydHlBY2Nlc3NvclBhcnNlcjtcclxufSgpKTtcclxuZnVuY3Rpb24gZ2V0QWNjZXNzb3JFeHByZXNzaW9uKGZuKSB7XHJcbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cclxuICAgIHZhciBjbGFzc2ljID0gL15mdW5jdGlvblxccypcXChbJF9cXHdcXGRdK1xcKVxccypcXHsoPzpcXHMqXCJ1c2Ugc3RyaWN0XCI7KT9cXHMqKD86WyRfXFx3XFxkLlsnXCJcXF0rO10rKT9cXHMqcmV0dXJuXFxzK1skX1xcd1xcZF0rXFwuKFskX1xcd1xcZF0rKVxccyo7P1xccypcXH0kLztcclxuICAgIC8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXHJcbiAgICB2YXIgYXJyb3cgPSAvXlxcKD9bJF9cXHdcXGRdK1xcKT9cXHMqPT5cXHMqWyRfXFx3XFxkXStcXC4oWyRfXFx3XFxkXSspJC87XHJcbiAgICB2YXIgbWF0Y2ggPSBjbGFzc2ljLmV4ZWMoZm4pIHx8IGFycm93LmV4ZWMoZm4pO1xyXG4gICAgaWYgKG1hdGNoID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHBhcnNlIGFjY2Vzc29yIGZ1bmN0aW9uOlxcblwiICsgZm4pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hdGNoWzFdO1xyXG59XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cblxuLyoqXHJcbiAqIFZhbGlkYXRpb24gdHJpZ2dlcnMuXHJcbiAqL1xyXG52YXIgdmFsaWRhdGVUcmlnZ2VyO1xyXG4oZnVuY3Rpb24gKHZhbGlkYXRlVHJpZ2dlcikge1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYW51YWwgdmFsaWRhdGlvbi4gIFVzZSB0aGUgY29udHJvbGxlcidzIGB2YWxpZGF0ZSgpYCBhbmQgIGByZXNldCgpYCBtZXRob2RzXHJcbiAgICAgKiB0byB2YWxpZGF0ZSBhbGwgYmluZGluZ3MuXHJcbiAgICAgKi9cclxuICAgIHZhbGlkYXRlVHJpZ2dlclt2YWxpZGF0ZVRyaWdnZXJbXCJtYW51YWxcIl0gPSAwXSA9IFwibWFudWFsXCI7XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIHRoZSBiaW5kaW5nIHdoZW4gdGhlIGJpbmRpbmcncyB0YXJnZXQgZWxlbWVudCBmaXJlcyBhIERPTSBcImJsdXJcIiBldmVudC5cclxuICAgICAqL1xyXG4gICAgdmFsaWRhdGVUcmlnZ2VyW3ZhbGlkYXRlVHJpZ2dlcltcImJsdXJcIl0gPSAxXSA9IFwiYmx1clwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZSB0aGUgYmluZGluZyB3aGVuIGl0IHVwZGF0ZXMgdGhlIG1vZGVsIGR1ZSB0byBhIGNoYW5nZSBpbiB0aGUgdmlldy5cclxuICAgICAqL1xyXG4gICAgdmFsaWRhdGVUcmlnZ2VyW3ZhbGlkYXRlVHJpZ2dlcltcImNoYW5nZVwiXSA9IDJdID0gXCJjaGFuZ2VcIjtcclxuICAgIC8qKlxyXG4gICAgICogVmFsaWRhdGUgdGhlIGJpbmRpbmcgd2hlbiB0aGUgYmluZGluZydzIHRhcmdldCBlbGVtZW50IGZpcmVzIGEgRE9NIFwiYmx1clwiIGV2ZW50IGFuZFxyXG4gICAgICogd2hlbiBpdCB1cGRhdGVzIHRoZSBtb2RlbCBkdWUgdG8gYSBjaGFuZ2UgaW4gdGhlIHZpZXcuXHJcbiAgICAgKi9cclxuICAgIHZhbGlkYXRlVHJpZ2dlclt2YWxpZGF0ZVRyaWdnZXJbXCJjaGFuZ2VPckJsdXJcIl0gPSAzXSA9IFwiY2hhbmdlT3JCbHVyXCI7XHJcbn0pKHZhbGlkYXRlVHJpZ2dlciB8fCAodmFsaWRhdGVUcmlnZ2VyID0ge30pKTtcblxuLyoqXHJcbiAqIFZhbGlkYXRlcyBvYmplY3RzIGFuZCBwcm9wZXJ0aWVzLlxyXG4gKi9cclxudmFyIFZhbGlkYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZhbGlkYXRvcigpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBWYWxpZGF0b3I7XHJcbn0oKSk7XG5cbi8qKlxyXG4gKiBUaGUgcmVzdWx0IG9mIHZhbGlkYXRpbmcgYW4gaW5kaXZpZHVhbCB2YWxpZGF0aW9uIHJ1bGUuXHJcbiAqL1xyXG52YXIgVmFsaWRhdGVSZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBydWxlIFRoZSBydWxlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVzdWx0LiBWYWxpZGF0b3IgaW1wbGVtZW50YXRpb24gc3BlY2lmaWMuXHJcbiAgICAgKiBAcGFyYW0gb2JqZWN0IFRoZSBvYmplY3QgdGhhdCB3YXMgdmFsaWRhdGVkLlxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5TmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCB3YXMgdmFsaWRhdGVkLlxyXG4gICAgICogQHBhcmFtIGVycm9yIFRoZSBlcnJvciwgaWYgdGhlIHJlc3VsdCBpcyBhIHZhbGlkYXRpb24gZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFZhbGlkYXRlUmVzdWx0KHJ1bGUsIG9iamVjdCwgcHJvcGVydHlOYW1lLCB2YWxpZCwgbWVzc2FnZSkge1xyXG4gICAgICAgIGlmIChtZXNzYWdlID09PSB2b2lkIDApIHsgbWVzc2FnZSA9IG51bGw7IH1cclxuICAgICAgICB0aGlzLnJ1bGUgPSBydWxlO1xyXG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG4gICAgICAgIHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xyXG4gICAgICAgIHRoaXMudmFsaWQgPSB2YWxpZDtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIHRoaXMuaWQgPSBWYWxpZGF0ZVJlc3VsdC5uZXh0SWQrKztcclxuICAgIH1cclxuICAgIFZhbGlkYXRlUmVzdWx0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZCA/ICdWYWxpZC4nIDogdGhpcy5tZXNzYWdlO1xyXG4gICAgfTtcclxuICAgIFZhbGlkYXRlUmVzdWx0Lm5leHRJZCA9IDA7XHJcbiAgICByZXR1cm4gVmFsaWRhdGVSZXN1bHQ7XHJcbn0oKSk7XG5cbnZhciBWYWxpZGF0ZUV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmFsaWRhdGVFdmVudChcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHR5cGUgb2YgdmFsaWRhdGUgZXZlbnQuIEVpdGhlciBcInZhbGlkYXRlXCIgb3IgXCJyZXNldFwiLlxyXG4gICAgICovXHJcbiAgICB0eXBlLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbnRyb2xsZXIncyBjdXJyZW50IGFycmF5IG9mIGVycm9ycy4gRm9yIGFuIGFycmF5IGNvbnRhaW5pbmcgYm90aFxyXG4gICAgICogZmFpbGVkIHJ1bGVzIGFuZCBwYXNzZWQgcnVsZXMsIHVzZSB0aGUgXCJyZXN1bHRzXCIgcHJvcGVydHkuXHJcbiAgICAgKi9cclxuICAgIGVycm9ycywgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjb250cm9sbGVyJ3MgY3VycmVudCBhcnJheSBvZiB2YWxpZGF0ZSByZXN1bHRzLiBUaGlzXHJcbiAgICAgKiBpbmNsdWRlcyBib3RoIHBhc3NlZCBydWxlcyBhbmQgZmFpbGVkIHJ1bGVzLiBGb3IgYW4gYXJyYXkgb2Ygb25seSBmYWlsZWQgcnVsZXMsXHJcbiAgICAgKiB1c2UgdGhlIFwiZXJyb3JzXCIgcHJvcGVydHkuXHJcbiAgICAgKi9cclxuICAgIHJlc3VsdHMsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5zdHJ1Y3Rpb24gcGFzc2VkIHRvIHRoZSBcInZhbGlkYXRlXCIgb3IgXCJyZXNldFwiIGV2ZW50LiBXaWxsIGJlIG51bGwgd2hlblxyXG4gICAgICogdGhlIGNvbnRyb2xsZXIncyB2YWxpZGF0ZS9yZXNldCBtZXRob2Qgd2FzIGNhbGxlZCB3aXRoIG5vIGluc3RydWN0aW9uIGFyZ3VtZW50LlxyXG4gICAgICovXHJcbiAgICBpbnN0cnVjdGlvbiwgXHJcbiAgICAvKipcclxuICAgICAqIEluIGV2ZW50cyB3aXRoIHR5cGUgPT09IFwidmFsaWRhdGVcIiwgdGhpcyBwcm9wZXJ0eSB3aWxsIGNvbnRhaW4gdGhlIHJlc3VsdFxyXG4gICAgICogb2YgdmFsaWRhdGluZyB0aGUgaW5zdHJ1Y3Rpb24gKHNlZSBcImluc3RydWN0aW9uXCIgcHJvcGVydHkpLiBVc2UgdGhlIGNvbnRyb2xsZXJWYWxpZGF0ZVJlc3VsdFxyXG4gICAgICogdG8gYWNjZXNzIHRoZSB2YWxpZGF0ZSByZXN1bHRzIHNwZWNpZmljIHRvIHRoZSBjYWxsIHRvIFwidmFsaWRhdGVcIlxyXG4gICAgICogKGFzIG9wcG9zZWQgdG8gdXNpbmcgdGhlIFwicmVzdWx0c1wiIGFuZCBcImVycm9yc1wiIHByb3BlcnRpZXMgdG8gYWNjZXNzIHRoZSBjb250cm9sbGVyJ3MgZW50aXJlXHJcbiAgICAgKiBzZXQgb2YgcmVzdWx0cy9lcnJvcnMpLlxyXG4gICAgICovXHJcbiAgICBjb250cm9sbGVyVmFsaWRhdGVSZXN1bHQpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xyXG4gICAgICAgIHRoaXMucmVzdWx0cyA9IHJlc3VsdHM7XHJcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlclZhbGlkYXRlUmVzdWx0ID0gY29udHJvbGxlclZhbGlkYXRlUmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFZhbGlkYXRlRXZlbnQ7XHJcbn0oKSk7XG5cbi8qKlxyXG4gKiBPcmNoZXN0cmF0ZXMgdmFsaWRhdGlvbi5cclxuICogTWFuYWdlcyBhIHNldCBvZiBiaW5kaW5ncywgcmVuZGVyZXJzIGFuZCBvYmplY3RzLlxyXG4gKiBFeHBvc2VzIHRoZSBjdXJyZW50IGxpc3Qgb2YgdmFsaWRhdGlvbiByZXN1bHRzIGZvciBiaW5kaW5nIHB1cnBvc2VzLlxyXG4gKi9cclxudmFyIFZhbGlkYXRpb25Db250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmFsaWRhdGlvbkNvbnRyb2xsZXIodmFsaWRhdG9yLCBwcm9wZXJ0eVBhcnNlcikge1xyXG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gdmFsaWRhdG9yO1xyXG4gICAgICAgIHRoaXMucHJvcGVydHlQYXJzZXIgPSBwcm9wZXJ0eVBhcnNlcjtcclxuICAgICAgICAvLyBSZWdpc3RlcmVkIGJpbmRpbmdzICh2aWEgdGhlIHZhbGlkYXRlIGJpbmRpbmcgYmVoYXZpb3IpXHJcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvLyBSZW5kZXJlcnMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGNvbnRyb2xsZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlcnMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBWYWxpZGF0aW9uIHJlc3VsdHMgdGhhdCBoYXZlIGJlZW4gcmVuZGVyZWQgYnkgdGhlIGNvbnRyb2xsZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZXN1bHRzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVmFsaWRhdGlvbiBlcnJvcnMgdGhhdCBoYXZlIGJlZW4gcmVuZGVyZWQgYnkgdGhlIGNvbnRyb2xsZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAgV2hldGhlciB0aGUgY29udHJvbGxlciBpcyBjdXJyZW50bHkgdmFsaWRhdGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZhbGlkYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAvLyBFbGVtZW50cyByZWxhdGVkIHRvIHZhbGlkYXRpb24gcmVzdWx0cyB0aGF0IGhhdmUgYmVlbiByZW5kZXJlZC5cclxuICAgICAgICB0aGlzLmVsZW1lbnRzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8vIE9iamVjdHMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGNvbnRyb2xsZXIgaW5zdGFuY2UgKGVudGl0eS1zdHlsZSB2YWxpZGF0aW9uKS5cclxuICAgICAgICB0aGlzLm9iamVjdHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRyaWdnZXIgdGhhdCB3aWxsIGludm9rZSBhdXRvbWF0aWMgdmFsaWRhdGlvbiBvZiBhIHByb3BlcnR5IHVzZWQgaW4gYSBiaW5kaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGVUcmlnZ2VyID0gdmFsaWRhdGVUcmlnZ2VyLmJsdXI7XHJcbiAgICAgICAgLy8gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdmFsaWRhdGlvbiBoYXMgY29tcGxldGVkLlxyXG4gICAgICAgIHRoaXMuZmluaXNoVmFsaWRhdGluZyA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRDYWxsYmFja3MgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlIHRvIGNvbnRyb2xsZXIgdmFsaWRhdGUgYW5kIHJlc2V0IGV2ZW50cy4gVGhlc2UgZXZlbnRzIG9jY3VyIHdoZW4gdGhlXHJcbiAgICAgKiBjb250cm9sbGVyJ3MgXCJ2YWxpZGF0ZVwiXCIgYW5kIFwicmVzZXRcIiBtZXRob2RzIGFyZSBjYWxsZWQuXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgY29udHJvbGxlciB2YWxpZGF0ZXMgb3IgcmVzZXRzLlxyXG4gICAgICovXHJcbiAgICBWYWxpZGF0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmV2ZW50Q2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLmV2ZW50Q2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50Q2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBvYmplY3QgdG8gdGhlIHNldCBvZiBvYmplY3RzIHRoYXQgc2hvdWxkIGJlIHZhbGlkYXRlZCB3aGVuIHZhbGlkYXRlIGlzIGNhbGxlZC5cclxuICAgICAqIEBwYXJhbSBvYmplY3QgVGhlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBydWxlcyBPcHRpb25hbC4gVGhlIHJ1bGVzLiBJZiBydWxlcyBhcmVuJ3Qgc3VwcGxpZWQgdGhlIFZhbGlkYXRvciBpbXBsZW1lbnRhdGlvbiB3aWxsIGxvb2t1cCB0aGUgcnVsZXMuXHJcbiAgICAgKi9cclxuICAgIFZhbGlkYXRpb25Db250cm9sbGVyLnByb3RvdHlwZS5hZGRPYmplY3QgPSBmdW5jdGlvbiAob2JqZWN0LCBydWxlcykge1xyXG4gICAgICAgIHRoaXMub2JqZWN0cy5zZXQob2JqZWN0LCBydWxlcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFuIG9iamVjdCBmcm9tIHRoZSBzZXQgb2Ygb2JqZWN0cyB0aGF0IHNob3VsZCBiZSB2YWxpZGF0ZWQgd2hlbiB2YWxpZGF0ZSBpcyBjYWxsZWQuXHJcbiAgICAgKiBAcGFyYW0gb2JqZWN0IFRoZSBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIFZhbGlkYXRpb25Db250cm9sbGVyLnByb3RvdHlwZS5yZW1vdmVPYmplY3QgPSBmdW5jdGlvbiAob2JqZWN0KSB7XHJcbiAgICAgICAgdGhpcy5vYmplY3RzLmRlbGV0ZShvYmplY3QpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1Jlc3VsdERlbHRhKCdyZXNldCcsIHRoaXMucmVzdWx0cy5maWx0ZXIoZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0Lm9iamVjdCA9PT0gb2JqZWN0OyB9KSwgW10pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbmQgcmVuZGVycyBhbiBlcnJvci5cclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLmFkZEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG9iamVjdCwgcHJvcGVydHlOYW1lKSB7XHJcbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZSA9PT0gdm9pZCAwKSB7IHByb3BlcnR5TmFtZSA9IG51bGw7IH1cclxuICAgICAgICB2YXIgcmVzb2x2ZWRQcm9wZXJ0eU5hbWU7XHJcbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXNvbHZlZFByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc29sdmVkUHJvcGVydHlOYW1lID0gdGhpcy5wcm9wZXJ0eVBhcnNlci5wYXJzZShwcm9wZXJ0eU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRlUmVzdWx0KHsgX19tYW51YWxseUFkZGVkX186IHRydWUgfSwgb2JqZWN0LCByZXNvbHZlZFByb3BlcnR5TmFtZSwgZmFsc2UsIG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1Jlc3VsdERlbHRhKCd2YWxpZGF0ZScsIFtdLCBbcmVzdWx0XSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW5kIHVucmVuZGVycyBhbiBlcnJvci5cclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZUVycm9yID0gZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlc3VsdHMuaW5kZXhPZihyZXN1bHQpICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NSZXN1bHREZWx0YSgncmVzZXQnLCBbcmVzdWx0XSwgW10pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSByZW5kZXJlci5cclxuICAgICAqIEBwYXJhbSByZW5kZXJlciBUaGUgcmVuZGVyZXIuXHJcbiAgICAgKi9cclxuICAgIFZhbGlkYXRpb25Db250cm9sbGVyLnByb3RvdHlwZS5hZGRSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlcnMucHVzaChyZW5kZXJlcik7XHJcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKHtcclxuICAgICAgICAgICAga2luZDogJ3ZhbGlkYXRlJyxcclxuICAgICAgICAgICAgcmVuZGVyOiB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuICh7IHJlc3VsdDogcmVzdWx0LCBlbGVtZW50czogX3RoaXMuZWxlbWVudHMuZ2V0KHJlc3VsdCkgfSk7IH0pLFxyXG4gICAgICAgICAgICB1bnJlbmRlcjogW11cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSByZW5kZXJlci5cclxuICAgICAqIEBwYXJhbSByZW5kZXJlciBUaGUgcmVuZGVyZXIuXHJcbiAgICAgKi9cclxuICAgIFZhbGlkYXRpb25Db250cm9sbGVyLnByb3RvdHlwZS5yZW1vdmVSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlcnMuc3BsaWNlKHRoaXMucmVuZGVyZXJzLmluZGV4T2YocmVuZGVyZXIpLCAxKTtcclxuICAgICAgICByZW5kZXJlci5yZW5kZXIoe1xyXG4gICAgICAgICAgICBraW5kOiAncmVzZXQnLFxyXG4gICAgICAgICAgICByZW5kZXI6IFtdLFxyXG4gICAgICAgICAgICB1bnJlbmRlcjogdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiAoeyByZXN1bHQ6IHJlc3VsdCwgZWxlbWVudHM6IF90aGlzLmVsZW1lbnRzLmdldChyZXN1bHQpIH0pOyB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGEgYmluZGluZyB3aXRoIHRoZSBjb250cm9sbGVyLlxyXG4gICAgICogQHBhcmFtIGJpbmRpbmcgVGhlIGJpbmRpbmcgaW5zdGFuY2UuXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSBET00gZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSBydWxlcyAob3B0aW9uYWwpIHJ1bGVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgYmluZGluZy4gVmFsaWRhdG9yIGltcGxlbWVudGF0aW9uIHNwZWNpZmljLlxyXG4gICAgICovXHJcbiAgICBWYWxpZGF0aW9uQ29udHJvbGxlci5wcm90b3R5cGUucmVnaXN0ZXJCaW5kaW5nID0gZnVuY3Rpb24gKGJpbmRpbmcsIHRhcmdldCwgcnVsZXMpIHtcclxuICAgICAgICB0aGlzLmJpbmRpbmdzLnNldChiaW5kaW5nLCB7IHRhcmdldDogdGFyZ2V0LCBydWxlczogcnVsZXMsIHByb3BlcnR5SW5mbzogbnVsbCB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVucmVnaXN0ZXJzIGEgYmluZGluZyB3aXRoIHRoZSBjb250cm9sbGVyLlxyXG4gICAgICogQHBhcmFtIGJpbmRpbmcgVGhlIGJpbmRpbmcgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIFZhbGlkYXRpb25Db250cm9sbGVyLnByb3RvdHlwZS51bnJlZ2lzdGVyQmluZGluZyA9IGZ1bmN0aW9uIChiaW5kaW5nKSB7XHJcbiAgICAgICAgdGhpcy5yZXNldEJpbmRpbmcoYmluZGluZyk7XHJcbiAgICAgICAgdGhpcy5iaW5kaW5ncy5kZWxldGUoYmluZGluZyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcnByZXRzIHRoZSBpbnN0cnVjdGlvbiBhbmQgcmV0dXJucyBhIHByZWRpY2F0ZSB0aGF0IHdpbGwgaWRlbnRpZnlcclxuICAgICAqIHJlbGV2YW50IHJlc3VsdHMgaW4gdGhlIGxpc3Qgb2YgcmVuZGVyZWQgdmFsaWRhdGlvbiByZXN1bHRzLlxyXG4gICAgICovXHJcbiAgICBWYWxpZGF0aW9uQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0SW5zdHJ1Y3Rpb25QcmVkaWNhdGUgPSBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChpbnN0cnVjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0XzEgPSBpbnN0cnVjdGlvbi5vYmplY3QsIHByb3BlcnR5TmFtZV8xID0gaW5zdHJ1Y3Rpb24ucHJvcGVydHlOYW1lLCBydWxlc18xID0gaW5zdHJ1Y3Rpb24ucnVsZXM7XHJcbiAgICAgICAgICAgIHZhciBwcmVkaWNhdGVfMTtcclxuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLnByb3BlcnR5TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcHJlZGljYXRlXzEgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5vYmplY3QgPT09IG9iamVjdF8xICYmIHgucHJvcGVydHlOYW1lID09PSBwcm9wZXJ0eU5hbWVfMTsgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHByZWRpY2F0ZV8xID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgub2JqZWN0ID09PSBvYmplY3RfMTsgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocnVsZXNfMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7IHJldHVybiBwcmVkaWNhdGVfMSh4KSAmJiBfdGhpcy52YWxpZGF0b3IucnVsZUV4aXN0cyhydWxlc18xLCB4LnJ1bGUpOyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGVfMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlcyBhbmQgcmVuZGVycyByZXN1bHRzLlxyXG4gICAgICogQHBhcmFtIGluc3RydWN0aW9uIE9wdGlvbmFsLiBJbnN0cnVjdGlvbnMgb24gd2hhdCB0byB2YWxpZGF0ZS4gSWYgdW5kZWZpbmVkLCBhbGxcclxuICAgICAqIG9iamVjdHMgYW5kIGJpbmRpbmdzIHdpbGwgYmUgdmFsaWRhdGVkLlxyXG4gICAgICovXHJcbiAgICBWYWxpZGF0aW9uQ29udHJvbGxlci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIEdldCBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBwcm9jZXNzIHRoZSB2YWxpZGF0aW9uIGluc3RydWN0aW9uLlxyXG4gICAgICAgIHZhciBleGVjdXRlO1xyXG4gICAgICAgIGlmIChpbnN0cnVjdGlvbikge1xyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6cHJlZmVyLWNvbnN0XHJcbiAgICAgICAgICAgIHZhciBvYmplY3RfMiA9IGluc3RydWN0aW9uLm9iamVjdCwgcHJvcGVydHlOYW1lXzIgPSBpbnN0cnVjdGlvbi5wcm9wZXJ0eU5hbWUsIHJ1bGVzXzIgPSBpbnN0cnVjdGlvbi5ydWxlcztcclxuICAgICAgICAgICAgLy8gaWYgcnVsZXMgd2VyZSBub3Qgc3BlY2lmaWVkLCBjaGVjayB0aGUgb2JqZWN0IG1hcC5cclxuICAgICAgICAgICAgcnVsZXNfMiA9IHJ1bGVzXzIgfHwgdGhpcy5vYmplY3RzLmdldChvYmplY3RfMik7XHJcbiAgICAgICAgICAgIC8vIHByb3BlcnR5IHNwZWNpZmllZD9cclxuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLnByb3BlcnR5TmFtZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB2YWxpZGF0ZSB0aGUgc3BlY2lmaWVkIG9iamVjdC5cclxuICAgICAgICAgICAgICAgIGV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy52YWxpZGF0b3IudmFsaWRhdGVPYmplY3Qob2JqZWN0XzIsIHJ1bGVzXzIpOyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdmFsaWRhdGUgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICAgIGV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy52YWxpZGF0b3IudmFsaWRhdGVQcm9wZXJ0eShvYmplY3RfMiwgcHJvcGVydHlOYW1lXzIsIHJ1bGVzXzIpOyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB2YWxpZGF0ZSBhbGwgb2JqZWN0cyBhbmQgYmluZGluZ3MuXHJcbiAgICAgICAgICAgIGV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBBcnJheS5mcm9tKF90aGlzLm9iamVjdHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IF9hW19pXSwgb2JqZWN0ID0gX2JbMF0sIHJ1bGVzID0gX2JbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChfdGhpcy52YWxpZGF0b3IudmFsaWRhdGVPYmplY3Qob2JqZWN0LCBydWxlcykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2MgPSAwLCBfZCA9IEFycmF5LmZyb20oX3RoaXMuYmluZGluZ3MpOyBfYyA8IF9kLmxlbmd0aDsgX2MrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfZSA9IF9kW19jXSwgYmluZGluZyA9IF9lWzBdLCBydWxlcyA9IF9lWzFdLnJ1bGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8oYmluZGluZy5zb3VyY2VFeHByZXNzaW9uLCBiaW5kaW5nLnNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eUluZm8gfHwgX3RoaXMub2JqZWN0cy5oYXMocHJvcGVydHlJbmZvLm9iamVjdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goX3RoaXMudmFsaWRhdG9yLnZhbGlkYXRlUHJvcGVydHkocHJvcGVydHlJbmZvLm9iamVjdCwgcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZSwgcnVsZXMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAocmVzdWx0U2V0cykgeyByZXR1cm4gcmVzdWx0U2V0cy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuY29uY2F0KGIpOyB9LCBbXSk7IH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXYWl0IGZvciBhbnkgZXhpc3RpbmcgdmFsaWRhdGlvbiB0byBmaW5pc2gsIGV4ZWN1dGUgdGhlIGluc3RydWN0aW9uLCByZW5kZXIgdGhlIHJlc3VsdHMuXHJcbiAgICAgICAgdGhpcy52YWxpZGF0aW5nID0gdHJ1ZTtcclxuICAgICAgICB2YXIgcmV0dXJuUHJvbWlzZSA9IHRoaXMuZmluaXNoVmFsaWRhdGluZ1xyXG4gICAgICAgICAgICAudGhlbihleGVjdXRlKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobmV3UmVzdWx0cykge1xyXG4gICAgICAgICAgICB2YXIgcHJlZGljYXRlID0gX3RoaXMuZ2V0SW5zdHJ1Y3Rpb25QcmVkaWNhdGUoaW5zdHJ1Y3Rpb24pO1xyXG4gICAgICAgICAgICB2YXIgb2xkUmVzdWx0cyA9IF90aGlzLnJlc3VsdHMuZmlsdGVyKHByZWRpY2F0ZSk7XHJcbiAgICAgICAgICAgIF90aGlzLnByb2Nlc3NSZXN1bHREZWx0YSgndmFsaWRhdGUnLCBvbGRSZXN1bHRzLCBuZXdSZXN1bHRzKTtcclxuICAgICAgICAgICAgaWYgKHJldHVyblByb21pc2UgPT09IF90aGlzLmZpbmlzaFZhbGlkYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnZhbGlkYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb246IGluc3RydWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgdmFsaWQ6IG5ld1Jlc3VsdHMuZmluZChmdW5jdGlvbiAoeCkgeyByZXR1cm4gIXgudmFsaWQ7IH0pID09PSB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICByZXN1bHRzOiBuZXdSZXN1bHRzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIF90aGlzLmludm9rZUNhbGxiYWNrcyhpbnN0cnVjdGlvbiwgcmVzdWx0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xyXG4gICAgICAgICAgICAvLyByZWNvdmVyLCB0byBlbmFibGUgc3Vic2VxdWVudCBjYWxscyB0byB2YWxpZGF0ZSgpXHJcbiAgICAgICAgICAgIF90aGlzLnZhbGlkYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMuZmluaXNoVmFsaWRhdGluZyA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXhjZXB0aW9uKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmZpbmlzaFZhbGlkYXRpbmcgPSByZXR1cm5Qcm9taXNlO1xyXG4gICAgICAgIHJldHVybiByZXR1cm5Qcm9taXNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIGFueSByZW5kZXJlZCB2YWxpZGF0aW9uIHJlc3VsdHMgKHVucmVuZGVycykuXHJcbiAgICAgKiBAcGFyYW0gaW5zdHJ1Y3Rpb24gT3B0aW9uYWwuIEluc3RydWN0aW9ucyBvbiB3aGF0IHRvIHJlc2V0LiBJZiB1bnNwZWNpZmllZCBhbGwgcmVuZGVyZWQgcmVzdWx0c1xyXG4gICAgICogd2lsbCBiZSB1bnJlbmRlcmVkLlxyXG4gICAgICovXHJcbiAgICBWYWxpZGF0aW9uQ29udHJvbGxlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcclxuICAgICAgICB2YXIgcHJlZGljYXRlID0gdGhpcy5nZXRJbnN0cnVjdGlvblByZWRpY2F0ZShpbnN0cnVjdGlvbik7XHJcbiAgICAgICAgdmFyIG9sZFJlc3VsdHMgPSB0aGlzLnJlc3VsdHMuZmlsdGVyKHByZWRpY2F0ZSk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUmVzdWx0RGVsdGEoJ3Jlc2V0Jywgb2xkUmVzdWx0cywgW10pO1xyXG4gICAgICAgIHRoaXMuaW52b2tlQ2FsbGJhY2tzKGluc3RydWN0aW9uLCBudWxsKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGVsZW1lbnRzIGFzc29jaWF0ZWQgd2l0aCBhbiBvYmplY3QgYW5kIHByb3BlcnR5TmFtZSAoaWYgYW55KS5cclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldEFzc29jaWF0ZWRFbGVtZW50cyA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBvYmplY3QgPSBfYS5vYmplY3QsIHByb3BlcnR5TmFtZSA9IF9hLnByb3BlcnR5TmFtZTtcclxuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9iID0gQXJyYXkuZnJvbSh0aGlzLmJpbmRpbmdzKTsgX2kgPCBfYi5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIF9jID0gX2JbX2ldLCBiaW5kaW5nID0gX2NbMF0sIHRhcmdldCA9IF9jWzFdLnRhcmdldDtcclxuICAgICAgICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhiaW5kaW5nLnNvdXJjZUV4cHJlc3Npb24sIGJpbmRpbmcuc291cmNlKTtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnR5SW5mbyAmJiBwcm9wZXJ0eUluZm8ub2JqZWN0ID09PSBvYmplY3QgJiYgcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZSA9PT0gcHJvcGVydHlOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xyXG4gICAgfTtcclxuICAgIFZhbGlkYXRpb25Db250cm9sbGVyLnByb3RvdHlwZS5wcm9jZXNzUmVzdWx0RGVsdGEgPSBmdW5jdGlvbiAoa2luZCwgb2xkUmVzdWx0cywgbmV3UmVzdWx0cykge1xyXG4gICAgICAgIC8vIHByZXBhcmUgdGhlIGluc3RydWN0aW9uLlxyXG4gICAgICAgIHZhciBpbnN0cnVjdGlvbiA9IHtcclxuICAgICAgICAgICAga2luZDoga2luZCxcclxuICAgICAgICAgICAgcmVuZGVyOiBbXSxcclxuICAgICAgICAgICAgdW5yZW5kZXI6IFtdXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBjcmVhdGUgYSBzaGFsbG93IGNvcHkgb2YgbmV3UmVzdWx0cyBzbyB3ZSBjYW4gbXV0YXRlIGl0IHdpdGhvdXQgY2F1c2luZyBzaWRlLWVmZmVjdHMuXHJcbiAgICAgICAgbmV3UmVzdWx0cyA9IG5ld1Jlc3VsdHMuc2xpY2UoMCk7XHJcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAob2xkUmVzdWx0KSB7XHJcbiAgICAgICAgICAgIC8vIGdldCB0aGUgZWxlbWVudHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBvbGQgcmVzdWx0LlxyXG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzXzEuZWxlbWVudHMuZ2V0KG9sZFJlc3VsdCk7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgb2xkIHJlc3VsdCBmcm9tIHRoZSBlbGVtZW50IG1hcC5cclxuICAgICAgICAgICAgdGhpc18xLmVsZW1lbnRzLmRlbGV0ZShvbGRSZXN1bHQpO1xyXG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIHVucmVuZGVyIGluc3RydWN0aW9uLlxyXG4gICAgICAgICAgICBpbnN0cnVjdGlvbi51bnJlbmRlci5wdXNoKHsgcmVzdWx0OiBvbGRSZXN1bHQsIGVsZW1lbnRzOiBlbGVtZW50cyB9KTtcclxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHRoZXJlJ3MgYSBjb3JyZXNwb25kaW5nIG5ldyByZXN1bHQgZm9yIHRoZSBvbGQgcmVzdWx0IHdlIGFyZSB1bnJlbmRlcmluZy5cclxuICAgICAgICAgICAgdmFyIG5ld1Jlc3VsdEluZGV4ID0gbmV3UmVzdWx0cy5maW5kSW5kZXgoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgucnVsZSA9PT0gb2xkUmVzdWx0LnJ1bGUgJiYgeC5vYmplY3QgPT09IG9sZFJlc3VsdC5vYmplY3QgJiYgeC5wcm9wZXJ0eU5hbWUgPT09IG9sZFJlc3VsdC5wcm9wZXJ0eU5hbWU7IH0pO1xyXG4gICAgICAgICAgICBpZiAobmV3UmVzdWx0SW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBubyBjb3JyZXNwb25kaW5nIG5ldyByZXN1bHQuLi4gc2ltcGxlIHJlbW92ZS5cclxuICAgICAgICAgICAgICAgIHRoaXNfMS5yZXN1bHRzLnNwbGljZSh0aGlzXzEucmVzdWx0cy5pbmRleE9mKG9sZFJlc3VsdCksIDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvbGRSZXN1bHQudmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzXzEuZXJyb3JzLnNwbGljZSh0aGlzXzEuZXJyb3JzLmluZGV4T2Yob2xkUmVzdWx0KSwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBhIGNvcnJlc3BvbmRpbmcgbmV3IHJlc3VsdC4uLlxyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1Jlc3VsdCA9IG5ld1Jlc3VsdHMuc3BsaWNlKG5ld1Jlc3VsdEluZGV4LCAxKVswXTtcclxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgZWxlbWVudHMgdGhhdCBhcmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBuZXcgcmVzdWx0LlxyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzXzEgPSB0aGlzXzEuZ2V0QXNzb2NpYXRlZEVsZW1lbnRzKG5ld1Jlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzXzEuZWxlbWVudHMuc2V0KG5ld1Jlc3VsdCwgZWxlbWVudHNfMSk7XHJcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSByZW5kZXIgaW5zdHJ1Y3Rpb24gZm9yIHRoZSBuZXcgcmVzdWx0LlxyXG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24ucmVuZGVyLnB1c2goeyByZXN1bHQ6IG5ld1Jlc3VsdCwgZWxlbWVudHM6IGVsZW1lbnRzXzEgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBkbyBhbiBpbi1wbGFjZSByZXBsYWNlbWVudCBvZiB0aGUgb2xkIHJlc3VsdCB3aXRoIHRoZSBuZXcgcmVzdWx0LlxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBlbnN1cmVzIGFueSByZXBlYXRzIGJvdW5kIHRvIHRoaXMucmVzdWx0cyB3aWxsIG5vdCB0aHJhc2guXHJcbiAgICAgICAgICAgICAgICB0aGlzXzEucmVzdWx0cy5zcGxpY2UodGhpc18xLnJlc3VsdHMuaW5kZXhPZihvbGRSZXN1bHQpLCAxLCBuZXdSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvbGRSZXN1bHQudmFsaWQgJiYgbmV3UmVzdWx0LnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLmVycm9ycy5zcGxpY2UodGhpc18xLmVycm9ycy5pbmRleE9mKG9sZFJlc3VsdCksIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIW9sZFJlc3VsdC52YWxpZCAmJiAhbmV3UmVzdWx0LnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLmVycm9ycy5zcGxpY2UodGhpc18xLmVycm9ycy5pbmRleE9mKG9sZFJlc3VsdCksIDEsIG5ld1Jlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghbmV3UmVzdWx0LnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLmVycm9ycy5wdXNoKG5ld1Jlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xyXG4gICAgICAgIC8vIGNyZWF0ZSB1bnJlbmRlciBpbnN0cnVjdGlvbnMgZnJvbSB0aGUgb2xkIHJlc3VsdHMuXHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBvbGRSZXN1bHRzXzEgPSBvbGRSZXN1bHRzOyBfaSA8IG9sZFJlc3VsdHNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIG9sZFJlc3VsdCA9IG9sZFJlc3VsdHNfMVtfaV07XHJcbiAgICAgICAgICAgIF9sb29wXzEob2xkUmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY3JlYXRlIHJlbmRlciBpbnN0cnVjdGlvbnMgZnJvbSB0aGUgcmVtYWluaW5nIG5ldyByZXN1bHRzLlxyXG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgbmV3UmVzdWx0c18xID0gbmV3UmVzdWx0czsgX2EgPCBuZXdSZXN1bHRzXzEubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXdSZXN1bHRzXzFbX2FdO1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmdldEFzc29jaWF0ZWRFbGVtZW50cyhyZXN1bHQpO1xyXG4gICAgICAgICAgICBpbnN0cnVjdGlvbi5yZW5kZXIucHVzaCh7IHJlc3VsdDogcmVzdWx0LCBlbGVtZW50czogZWxlbWVudHMgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMuc2V0KHJlc3VsdCwgZWxlbWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdHMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgICAgICBpZiAoIXJlc3VsdC52YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlbmRlci5cclxuICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gdGhpcy5yZW5kZXJlcnM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgIHZhciByZW5kZXJlciA9IF9jW19iXTtcclxuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKGluc3RydWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIHByb3BlcnR5IGFzc29jaWF0ZWQgd2l0aCBhIGJpbmRpbmcuXHJcbiAgICAgKi9cclxuICAgIFZhbGlkYXRpb25Db250cm9sbGVyLnByb3RvdHlwZS52YWxpZGF0ZUJpbmRpbmcgPSBmdW5jdGlvbiAoYmluZGluZykge1xyXG4gICAgICAgIGlmICghYmluZGluZy5pc0JvdW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhiaW5kaW5nLnNvdXJjZUV4cHJlc3Npb24sIGJpbmRpbmcuc291cmNlKTtcclxuICAgICAgICB2YXIgcnVsZXM7XHJcbiAgICAgICAgdmFyIHJlZ2lzdGVyZWRCaW5kaW5nID0gdGhpcy5iaW5kaW5ncy5nZXQoYmluZGluZyk7XHJcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRCaW5kaW5nKSB7XHJcbiAgICAgICAgICAgIHJ1bGVzID0gcmVnaXN0ZXJlZEJpbmRpbmcucnVsZXM7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyZWRCaW5kaW5nLnByb3BlcnR5SW5mbyA9IHByb3BlcnR5SW5mbztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFwcm9wZXJ0eUluZm8pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2JqZWN0ID0gcHJvcGVydHlJbmZvLm9iamVjdCwgcHJvcGVydHlOYW1lID0gcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtcclxuICAgICAgICB0aGlzLnZhbGlkYXRlKHsgb2JqZWN0OiBvYmplY3QsIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lLCBydWxlczogcnVsZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIHJlc3VsdHMgZm9yIGEgcHJvcGVydHkgYXNzb2NpYXRlZCB3aXRoIGEgYmluZGluZy5cclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLnJlc2V0QmluZGluZyA9IGZ1bmN0aW9uIChiaW5kaW5nKSB7XHJcbiAgICAgICAgdmFyIHJlZ2lzdGVyZWRCaW5kaW5nID0gdGhpcy5iaW5kaW5ncy5nZXQoYmluZGluZyk7XHJcbiAgICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhiaW5kaW5nLnNvdXJjZUV4cHJlc3Npb24sIGJpbmRpbmcuc291cmNlKTtcclxuICAgICAgICBpZiAoIXByb3BlcnR5SW5mbyAmJiByZWdpc3RlcmVkQmluZGluZykge1xyXG4gICAgICAgICAgICBwcm9wZXJ0eUluZm8gPSByZWdpc3RlcmVkQmluZGluZy5wcm9wZXJ0eUluZm87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWdpc3RlcmVkQmluZGluZykge1xyXG4gICAgICAgICAgICByZWdpc3RlcmVkQmluZGluZy5wcm9wZXJ0eUluZm8gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXByb3BlcnR5SW5mbykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYmplY3QgPSBwcm9wZXJ0eUluZm8ub2JqZWN0LCBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xyXG4gICAgICAgIHRoaXMucmVzZXQoeyBvYmplY3Q6IG9iamVjdCwgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eU5hbWUgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBjb250cm9sbGVyJ3MgdmFsaWRhdGVUcmlnZ2VyLlxyXG4gICAgICogQHBhcmFtIG5ld1RyaWdnZXIgVGhlIG5ldyB2YWxpZGF0ZVRyaWdnZXJcclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLmNoYW5nZVRyaWdnZXIgPSBmdW5jdGlvbiAobmV3VHJpZ2dlcikge1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGVUcmlnZ2VyID0gbmV3VHJpZ2dlcjtcclxuICAgICAgICB2YXIgYmluZGluZ3MgPSBBcnJheS5mcm9tKHRoaXMuYmluZGluZ3Mua2V5cygpKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGJpbmRpbmdzXzEgPSBiaW5kaW5nczsgX2kgPCBiaW5kaW5nc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgYmluZGluZyA9IGJpbmRpbmdzXzFbX2ldO1xyXG4gICAgICAgICAgICB2YXIgc291cmNlID0gYmluZGluZy5zb3VyY2U7XHJcbiAgICAgICAgICAgIGJpbmRpbmcudW5iaW5kKCk7XHJcbiAgICAgICAgICAgIGJpbmRpbmcuYmluZChzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldmFsaWRhdGVzIHRoZSBjb250cm9sbGVyJ3MgY3VycmVudCBzZXQgb2YgZXJyb3JzLlxyXG4gICAgICovXHJcbiAgICBWYWxpZGF0aW9uQ29udHJvbGxlci5wcm90b3R5cGUucmV2YWxpZGF0ZUVycm9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5lcnJvcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBfYiA9IF9hW19pXSwgb2JqZWN0ID0gX2Iub2JqZWN0LCBwcm9wZXJ0eU5hbWUgPSBfYi5wcm9wZXJ0eU5hbWUsIHJ1bGUgPSBfYi5ydWxlO1xyXG4gICAgICAgICAgICBpZiAocnVsZS5fX21hbnVhbGx5QWRkZWRfXykge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJ1bGVzID0gW1tydWxlXV07XHJcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoeyBvYmplY3Q6IG9iamVjdCwgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eU5hbWUsIHJ1bGVzOiBydWxlcyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmFsaWRhdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLmludm9rZUNhbGxiYWNrcyA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbiwgcmVzdWx0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRDYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IFZhbGlkYXRlRXZlbnQocmVzdWx0ID8gJ3ZhbGlkYXRlJyA6ICdyZXNldCcsIHRoaXMuZXJyb3JzLCB0aGlzLnJlc3VsdHMsIGluc3RydWN0aW9uIHx8IG51bGwsIHJlc3VsdCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50Q2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRDYWxsYmFja3NbaV0oZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWYWxpZGF0aW9uQ29udHJvbGxlci5pbmplY3QgPSBbVmFsaWRhdG9yLCBQcm9wZXJ0eUFjY2Vzc29yUGFyc2VyXTtcclxuICAgIHJldHVybiBWYWxpZGF0aW9uQ29udHJvbGxlcjtcclxufSgpKTtcblxuLyoqXHJcbiAqIEJpbmRpbmcgYmVoYXZpb3IuIEluZGljYXRlcyB0aGUgYm91bmQgcHJvcGVydHkgc2hvdWxkIGJlIHZhbGlkYXRlZC5cclxuICovXHJcbnZhciBWYWxpZGF0ZUJpbmRpbmdCZWhhdmlvckJhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWYWxpZGF0ZUJpbmRpbmdCZWhhdmlvckJhc2UodGFza1F1ZXVlKSB7XHJcbiAgICAgICAgdGhpcy50YXNrUXVldWUgPSB0YXNrUXVldWU7XHJcbiAgICB9XHJcbiAgICBWYWxpZGF0ZUJpbmRpbmdCZWhhdmlvckJhc2UucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoYmluZGluZywgc291cmNlLCBydWxlc09yQ29udHJvbGxlciwgcnVsZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIGlkZW50aWZ5IHRoZSB0YXJnZXQgZWxlbWVudC5cclxuICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0RE9NRWxlbWVudChiaW5kaW5nLCBzb3VyY2UpO1xyXG4gICAgICAgIC8vIGxvY2F0ZSB0aGUgY29udHJvbGxlci5cclxuICAgICAgICB2YXIgY29udHJvbGxlcjtcclxuICAgICAgICBpZiAocnVsZXNPckNvbnRyb2xsZXIgaW5zdGFuY2VvZiBWYWxpZGF0aW9uQ29udHJvbGxlcikge1xyXG4gICAgICAgICAgICBjb250cm9sbGVyID0gcnVsZXNPckNvbnRyb2xsZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb250cm9sbGVyID0gc291cmNlLmNvbnRhaW5lci5nZXQoT3B0aW9uYWwub2YoVmFsaWRhdGlvbkNvbnRyb2xsZXIpKTtcclxuICAgICAgICAgICAgcnVsZXMgPSBydWxlc09yQ29udHJvbGxlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBWYWxpZGF0aW9uQ29udHJvbGxlciBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRyb2xsZXIucmVnaXN0ZXJCaW5kaW5nKGJpbmRpbmcsIHRhcmdldCwgcnVsZXMpO1xyXG4gICAgICAgIGJpbmRpbmcudmFsaWRhdGlvbkNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xyXG4gICAgICAgIHZhciB0cmlnZ2VyID0gdGhpcy5nZXRWYWxpZGF0ZVRyaWdnZXIoY29udHJvbGxlcik7XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJpdHdpc2VcclxuICAgICAgICBpZiAodHJpZ2dlciAmIHZhbGlkYXRlVHJpZ2dlci5jaGFuZ2UpIHtcclxuICAgICAgICAgICAgYmluZGluZy52YmJVcGRhdGVTb3VyY2UgPSBiaW5kaW5nLnVwZGF0ZVNvdXJjZTtcclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm9ubHktYXJyb3ctZnVuY3Rpb25zXHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpzcGFjZS1iZWZvcmUtZnVuY3Rpb24tcGFyZW5cclxuICAgICAgICAgICAgYmluZGluZy51cGRhdGVTb3VyY2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmJiVXBkYXRlU291cmNlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGlvbkNvbnRyb2xsZXIudmFsaWRhdGVCaW5kaW5nKHRoaXMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYml0d2lzZVxyXG4gICAgICAgIGlmICh0cmlnZ2VyICYgdmFsaWRhdGVUcmlnZ2VyLmJsdXIpIHtcclxuICAgICAgICAgICAgYmluZGluZy52YWxpZGF0ZUJsdXJIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudGFza1F1ZXVlLnF1ZXVlTWljcm9UYXNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyb2xsZXIudmFsaWRhdGVCaW5kaW5nKGJpbmRpbmcpOyB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYmluZGluZy52YWxpZGF0ZVRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBiaW5kaW5nLnZhbGlkYXRlQmx1ckhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJpZ2dlciAhPT0gdmFsaWRhdGVUcmlnZ2VyLm1hbnVhbCkge1xyXG4gICAgICAgICAgICBiaW5kaW5nLnN0YW5kYXJkVXBkYXRlVGFyZ2V0ID0gYmluZGluZy51cGRhdGVUYXJnZXQ7XHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpvbmx5LWFycm93LWZ1bmN0aW9uc1xyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6c3BhY2UtYmVmb3JlLWZ1bmN0aW9uLXBhcmVuXHJcbiAgICAgICAgICAgIGJpbmRpbmcudXBkYXRlVGFyZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YW5kYXJkVXBkYXRlVGFyZ2V0KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGlvbkNvbnRyb2xsZXIucmVzZXRCaW5kaW5nKHRoaXMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWYWxpZGF0ZUJpbmRpbmdCZWhhdmlvckJhc2UucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uIChiaW5kaW5nKSB7XHJcbiAgICAgICAgLy8gcmVzZXQgdGhlIGJpbmRpbmcgdG8gaXQncyBvcmlnaW5hbCBzdGF0ZS5cclxuICAgICAgICBpZiAoYmluZGluZy52YmJVcGRhdGVTb3VyY2UpIHtcclxuICAgICAgICAgICAgYmluZGluZy51cGRhdGVTb3VyY2UgPSBiaW5kaW5nLnZiYlVwZGF0ZVNvdXJjZTtcclxuICAgICAgICAgICAgYmluZGluZy52YmJVcGRhdGVTb3VyY2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmluZGluZy5zdGFuZGFyZFVwZGF0ZVRhcmdldCkge1xyXG4gICAgICAgICAgICBiaW5kaW5nLnVwZGF0ZVRhcmdldCA9IGJpbmRpbmcuc3RhbmRhcmRVcGRhdGVUYXJnZXQ7XHJcbiAgICAgICAgICAgIGJpbmRpbmcuc3RhbmRhcmRVcGRhdGVUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmluZGluZy52YWxpZGF0ZUJsdXJIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcudmFsaWRhdGVUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGJpbmRpbmcudmFsaWRhdGVCbHVySGFuZGxlcik7XHJcbiAgICAgICAgICAgIGJpbmRpbmcudmFsaWRhdGVCbHVySGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgICAgIGJpbmRpbmcudmFsaWRhdGVUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBiaW5kaW5nLnZhbGlkYXRpb25Db250cm9sbGVyLnVucmVnaXN0ZXJCaW5kaW5nKGJpbmRpbmcpO1xyXG4gICAgICAgIGJpbmRpbmcudmFsaWRhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBWYWxpZGF0ZUJpbmRpbmdCZWhhdmlvckJhc2U7XHJcbn0oKSk7XG5cbi8qKlxyXG4gKiBCaW5kaW5nIGJlaGF2aW9yLiBJbmRpY2F0ZXMgdGhlIGJvdW5kIHByb3BlcnR5IHNob3VsZCBiZSB2YWxpZGF0ZWRcclxuICogd2hlbiB0aGUgdmFsaWRhdGUgdHJpZ2dlciBzcGVjaWZpZWQgYnkgdGhlIGFzc29jaWF0ZWQgY29udHJvbGxlcidzXHJcbiAqIHZhbGlkYXRlVHJpZ2dlciBwcm9wZXJ0eSBvY2N1cnMuXHJcbiAqL1xyXG52YXIgVmFsaWRhdGVCaW5kaW5nQmVoYXZpb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVmFsaWRhdGVCaW5kaW5nQmVoYXZpb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBWYWxpZGF0ZUJpbmRpbmdCZWhhdmlvcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBWYWxpZGF0ZUJpbmRpbmdCZWhhdmlvci5wcm90b3R5cGUuZ2V0VmFsaWRhdGVUcmlnZ2VyID0gZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcclxuICAgICAgICByZXR1cm4gY29udHJvbGxlci52YWxpZGF0ZVRyaWdnZXI7XHJcbiAgICB9O1xyXG4gICAgVmFsaWRhdGVCaW5kaW5nQmVoYXZpb3IuaW5qZWN0ID0gW1Rhc2tRdWV1ZV07XHJcbiAgICBWYWxpZGF0ZUJpbmRpbmdCZWhhdmlvciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGJpbmRpbmdCZWhhdmlvcigndmFsaWRhdGUnKVxyXG4gICAgXSwgVmFsaWRhdGVCaW5kaW5nQmVoYXZpb3IpO1xyXG4gICAgcmV0dXJuIFZhbGlkYXRlQmluZGluZ0JlaGF2aW9yO1xyXG59KFZhbGlkYXRlQmluZGluZ0JlaGF2aW9yQmFzZSkpO1xyXG4vKipcclxuICogQmluZGluZyBiZWhhdmlvci4gSW5kaWNhdGVzIHRoZSBib3VuZCBwcm9wZXJ0eSB3aWxsIGJlIHZhbGlkYXRlZFxyXG4gKiBtYW51YWxseSwgYnkgY2FsbGluZyBjb250cm9sbGVyLnZhbGlkYXRlKCkuIE5vIGF1dG9tYXRpYyB2YWxpZGF0aW9uXHJcbiAqIHRyaWdnZXJlZCBieSBkYXRhLWVudHJ5IG9yIGJsdXIgd2lsbCBvY2N1ci5cclxuICovXHJcbnZhciBWYWxpZGF0ZU1hbnVhbGx5QmluZGluZ0JlaGF2aW9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFZhbGlkYXRlTWFudWFsbHlCaW5kaW5nQmVoYXZpb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBWYWxpZGF0ZU1hbnVhbGx5QmluZGluZ0JlaGF2aW9yKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFZhbGlkYXRlTWFudWFsbHlCaW5kaW5nQmVoYXZpb3IucHJvdG90eXBlLmdldFZhbGlkYXRlVHJpZ2dlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdmFsaWRhdGVUcmlnZ2VyLm1hbnVhbDtcclxuICAgIH07XHJcbiAgICBWYWxpZGF0ZU1hbnVhbGx5QmluZGluZ0JlaGF2aW9yLmluamVjdCA9IFtUYXNrUXVldWVdO1xyXG4gICAgVmFsaWRhdGVNYW51YWxseUJpbmRpbmdCZWhhdmlvciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGJpbmRpbmdCZWhhdmlvcigndmFsaWRhdGVNYW51YWxseScpXHJcbiAgICBdLCBWYWxpZGF0ZU1hbnVhbGx5QmluZGluZ0JlaGF2aW9yKTtcclxuICAgIHJldHVybiBWYWxpZGF0ZU1hbnVhbGx5QmluZGluZ0JlaGF2aW9yO1xyXG59KFZhbGlkYXRlQmluZGluZ0JlaGF2aW9yQmFzZSkpO1xyXG4vKipcclxuICogQmluZGluZyBiZWhhdmlvci4gSW5kaWNhdGVzIHRoZSBib3VuZCBwcm9wZXJ0eSBzaG91bGQgYmUgdmFsaWRhdGVkXHJcbiAqIHdoZW4gdGhlIGFzc29jaWF0ZWQgZWxlbWVudCBibHVycy5cclxuICovXHJcbnZhciBWYWxpZGF0ZU9uQmx1ckJpbmRpbmdCZWhhdmlvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhWYWxpZGF0ZU9uQmx1ckJpbmRpbmdCZWhhdmlvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFZhbGlkYXRlT25CbHVyQmluZGluZ0JlaGF2aW9yKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFZhbGlkYXRlT25CbHVyQmluZGluZ0JlaGF2aW9yLnByb3RvdHlwZS5nZXRWYWxpZGF0ZVRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlVHJpZ2dlci5ibHVyO1xyXG4gICAgfTtcclxuICAgIFZhbGlkYXRlT25CbHVyQmluZGluZ0JlaGF2aW9yLmluamVjdCA9IFtUYXNrUXVldWVdO1xyXG4gICAgVmFsaWRhdGVPbkJsdXJCaW5kaW5nQmVoYXZpb3IgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBiaW5kaW5nQmVoYXZpb3IoJ3ZhbGlkYXRlT25CbHVyJylcclxuICAgIF0sIFZhbGlkYXRlT25CbHVyQmluZGluZ0JlaGF2aW9yKTtcclxuICAgIHJldHVybiBWYWxpZGF0ZU9uQmx1ckJpbmRpbmdCZWhhdmlvcjtcclxufShWYWxpZGF0ZUJpbmRpbmdCZWhhdmlvckJhc2UpKTtcclxuLyoqXHJcbiAqIEJpbmRpbmcgYmVoYXZpb3IuIEluZGljYXRlcyB0aGUgYm91bmQgcHJvcGVydHkgc2hvdWxkIGJlIHZhbGlkYXRlZFxyXG4gKiB3aGVuIHRoZSBhc3NvY2lhdGVkIGVsZW1lbnQgaXMgY2hhbmdlZCBieSB0aGUgdXNlciwgY2F1c2luZyBhIGNoYW5nZVxyXG4gKiB0byB0aGUgbW9kZWwuXHJcbiAqL1xyXG52YXIgVmFsaWRhdGVPbkNoYW5nZUJpbmRpbmdCZWhhdmlvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhWYWxpZGF0ZU9uQ2hhbmdlQmluZGluZ0JlaGF2aW9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVmFsaWRhdGVPbkNoYW5nZUJpbmRpbmdCZWhhdmlvcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBWYWxpZGF0ZU9uQ2hhbmdlQmluZGluZ0JlaGF2aW9yLnByb3RvdHlwZS5nZXRWYWxpZGF0ZVRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlVHJpZ2dlci5jaGFuZ2U7XHJcbiAgICB9O1xyXG4gICAgVmFsaWRhdGVPbkNoYW5nZUJpbmRpbmdCZWhhdmlvci5pbmplY3QgPSBbVGFza1F1ZXVlXTtcclxuICAgIFZhbGlkYXRlT25DaGFuZ2VCaW5kaW5nQmVoYXZpb3IgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBiaW5kaW5nQmVoYXZpb3IoJ3ZhbGlkYXRlT25DaGFuZ2UnKVxyXG4gICAgXSwgVmFsaWRhdGVPbkNoYW5nZUJpbmRpbmdCZWhhdmlvcik7XHJcbiAgICByZXR1cm4gVmFsaWRhdGVPbkNoYW5nZUJpbmRpbmdCZWhhdmlvcjtcclxufShWYWxpZGF0ZUJpbmRpbmdCZWhhdmlvckJhc2UpKTtcclxuLyoqXHJcbiAqIEJpbmRpbmcgYmVoYXZpb3IuIEluZGljYXRlcyB0aGUgYm91bmQgcHJvcGVydHkgc2hvdWxkIGJlIHZhbGlkYXRlZFxyXG4gKiB3aGVuIHRoZSBhc3NvY2lhdGVkIGVsZW1lbnQgYmx1cnMgb3IgaXMgY2hhbmdlZCBieSB0aGUgdXNlciwgY2F1c2luZ1xyXG4gKiBhIGNoYW5nZSB0byB0aGUgbW9kZWwuXHJcbiAqL1xyXG52YXIgVmFsaWRhdGVPbkNoYW5nZU9yQmx1ckJpbmRpbmdCZWhhdmlvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhWYWxpZGF0ZU9uQ2hhbmdlT3JCbHVyQmluZGluZ0JlaGF2aW9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVmFsaWRhdGVPbkNoYW5nZU9yQmx1ckJpbmRpbmdCZWhhdmlvcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBWYWxpZGF0ZU9uQ2hhbmdlT3JCbHVyQmluZGluZ0JlaGF2aW9yLnByb3RvdHlwZS5nZXRWYWxpZGF0ZVRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlVHJpZ2dlci5jaGFuZ2VPckJsdXI7XHJcbiAgICB9O1xyXG4gICAgVmFsaWRhdGVPbkNoYW5nZU9yQmx1ckJpbmRpbmdCZWhhdmlvci5pbmplY3QgPSBbVGFza1F1ZXVlXTtcclxuICAgIFZhbGlkYXRlT25DaGFuZ2VPckJsdXJCaW5kaW5nQmVoYXZpb3IgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBiaW5kaW5nQmVoYXZpb3IoJ3ZhbGlkYXRlT25DaGFuZ2VPckJsdXInKVxyXG4gICAgXSwgVmFsaWRhdGVPbkNoYW5nZU9yQmx1ckJpbmRpbmdCZWhhdmlvcik7XHJcbiAgICByZXR1cm4gVmFsaWRhdGVPbkNoYW5nZU9yQmx1ckJpbmRpbmdCZWhhdmlvcjtcclxufShWYWxpZGF0ZUJpbmRpbmdCZWhhdmlvckJhc2UpKTtcblxuLyoqXHJcbiAqIENyZWF0ZXMgVmFsaWRhdGlvbkNvbnRyb2xsZXIgaW5zdGFuY2VzLlxyXG4gKi9cclxudmFyIFZhbGlkYXRpb25Db250cm9sbGVyRmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZhbGlkYXRpb25Db250cm9sbGVyRmFjdG9yeShjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgIH1cclxuICAgIFZhbGlkYXRpb25Db250cm9sbGVyRmFjdG9yeS5nZXQgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uQ29udHJvbGxlckZhY3RvcnkoY29udGFpbmVyKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29udHJvbGxlciBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvbkNvbnRyb2xsZXJGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAodmFsaWRhdG9yKSB7XHJcbiAgICAgICAgaWYgKCF2YWxpZGF0b3IpIHtcclxuICAgICAgICAgICAgdmFsaWRhdG9yID0gdGhpcy5jb250YWluZXIuZ2V0KFZhbGlkYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcm9wZXJ0eVBhcnNlciA9IHRoaXMuY29udGFpbmVyLmdldChQcm9wZXJ0eUFjY2Vzc29yUGFyc2VyKTtcclxuICAgICAgICByZXR1cm4gbmV3IFZhbGlkYXRpb25Db250cm9sbGVyKHZhbGlkYXRvciwgcHJvcGVydHlQYXJzZXIpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb250cm9sbGVyIGFuZCByZWdpc3RlcnMgaXQgaW4gdGhlIGN1cnJlbnQgZWxlbWVudCdzIGNvbnRhaW5lciBzbyB0aGF0IGl0J3NcclxuICAgICAqIGF2YWlsYWJsZSB0byB0aGUgdmFsaWRhdGUgYmluZGluZyBiZWhhdmlvciBhbmQgcmVuZGVyZXJzLlxyXG4gICAgICovXHJcbiAgICBWYWxpZGF0aW9uQ29udHJvbGxlckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUZvckN1cnJlbnRTY29wZSA9IGZ1bmN0aW9uICh2YWxpZGF0b3IpIHtcclxuICAgICAgICB2YXIgY29udHJvbGxlciA9IHRoaXMuY3JlYXRlKHZhbGlkYXRvcik7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVnaXN0ZXJJbnN0YW5jZShWYWxpZGF0aW9uQ29udHJvbGxlciwgY29udHJvbGxlcik7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFZhbGlkYXRpb25Db250cm9sbGVyRmFjdG9yeTtcclxufSgpKTtcclxuVmFsaWRhdGlvbkNvbnRyb2xsZXJGYWN0b3J5Wydwcm90b2NvbDphdXJlbGlhOnJlc29sdmVyJ10gPSB0cnVlO1xuXG52YXIgVmFsaWRhdGlvbkVycm9yc0N1c3RvbUF0dHJpYnV0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvcnNDdXN0b21BdHRyaWJ1dGUoYm91bmRhcnlFbGVtZW50LCBjb250cm9sbGVyQWNjZXNzb3IpIHtcclxuICAgICAgICB0aGlzLmJvdW5kYXJ5RWxlbWVudCA9IGJvdW5kYXJ5RWxlbWVudDtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJBY2Nlc3NvciA9IGNvbnRyb2xsZXJBY2Nlc3NvcjtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XHJcbiAgICAgICAgdGhpcy5lcnJvcnNJbnRlcm5hbCA9IFtdO1xyXG4gICAgfVxyXG4gICAgVmFsaWRhdGlvbkVycm9yc0N1c3RvbUF0dHJpYnV0ZS5pbmplY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtET00uRWxlbWVudCwgTGF6eS5vZihWYWxpZGF0aW9uQ29udHJvbGxlcildO1xyXG4gICAgfTtcclxuICAgIFZhbGlkYXRpb25FcnJvcnNDdXN0b21BdHRyaWJ1dGUucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5lcnJvcnNJbnRlcm5hbC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIGlmIChhLnRhcmdldHNbMF0gPT09IGIudGFyZ2V0c1swXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJpdHdpc2VcclxuICAgICAgICAgICAgcmV0dXJuIGEudGFyZ2V0c1swXS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiLnRhcmdldHNbMF0pICYgMiA/IDEgOiAtMTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBWYWxpZGF0aW9uRXJyb3JzQ3VzdG9tQXR0cmlidXRlLnByb3RvdHlwZS5pbnRlcmVzdGluZ0VsZW1lbnRzID0gZnVuY3Rpb24gKGVsZW1lbnRzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gZWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5ib3VuZGFyeUVsZW1lbnQuY29udGFpbnMoZSk7IH0pO1xyXG4gICAgfTtcclxuICAgIFZhbGlkYXRpb25FcnJvcnNDdXN0b21BdHRyaWJ1dGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbikge1xyXG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzXzEuZXJyb3JzSW50ZXJuYWwuZmluZEluZGV4KGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmVycm9yID09PSByZXN1bHQ7IH0pO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzXzEuZXJyb3JzSW50ZXJuYWwuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGluc3RydWN0aW9uLnVucmVuZGVyOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX2FbX2ldLnJlc3VsdDtcclxuICAgICAgICAgICAgX2xvb3BfMShyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gaW5zdHJ1Y3Rpb24ucmVuZGVyOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICB2YXIgX2QgPSBfY1tfYl0sIHJlc3VsdCA9IF9kLnJlc3VsdCwgZWxlbWVudHMgPSBfZC5lbGVtZW50cztcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC52YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRhcmdldHMgPSB0aGlzLmludGVyZXN0aW5nRWxlbWVudHMoZWxlbWVudHMpO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzSW50ZXJuYWwucHVzaCh7IGVycm9yOiByZXN1bHQsIHRhcmdldHM6IHRhcmdldHMgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zb3J0KCk7XHJcbiAgICAgICAgdGhpcy5lcnJvcnMgPSB0aGlzLmVycm9yc0ludGVybmFsO1xyXG4gICAgfTtcclxuICAgIFZhbGlkYXRpb25FcnJvcnNDdXN0b21BdHRyaWJ1dGUucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2xsZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyID0gdGhpcy5jb250cm9sbGVyQWNjZXNzb3IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGhpcyB3aWxsIGNhbGwgcmVuZGVyKCkgd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgdXBkYXRpbmcgdGhpcy5lcnJvcnNcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYWRkUmVuZGVyZXIodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgVmFsaWRhdGlvbkVycm9yc0N1c3RvbUF0dHJpYnV0ZS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2xsZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLnJlbW92ZVJlbmRlcmVyKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBiaW5kYWJsZSh7IGRlZmF1bHRCaW5kaW5nTW9kZTogYmluZGluZ01vZGUub25lV2F5IH0pXHJcbiAgICBdLCBWYWxpZGF0aW9uRXJyb3JzQ3VzdG9tQXR0cmlidXRlLnByb3RvdHlwZSwgXCJjb250cm9sbGVyXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBiaW5kYWJsZSh7IHByaW1hcnlQcm9wZXJ0eTogdHJ1ZSwgZGVmYXVsdEJpbmRpbmdNb2RlOiBiaW5kaW5nTW9kZS50d29XYXkgfSlcclxuICAgIF0sIFZhbGlkYXRpb25FcnJvcnNDdXN0b21BdHRyaWJ1dGUucHJvdG90eXBlLCBcImVycm9yc1wiLCB2b2lkIDApO1xyXG4gICAgVmFsaWRhdGlvbkVycm9yc0N1c3RvbUF0dHJpYnV0ZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIGN1c3RvbUF0dHJpYnV0ZSgndmFsaWRhdGlvbi1lcnJvcnMnKVxyXG4gICAgXSwgVmFsaWRhdGlvbkVycm9yc0N1c3RvbUF0dHJpYnV0ZSk7XHJcbiAgICByZXR1cm4gVmFsaWRhdGlvbkVycm9yc0N1c3RvbUF0dHJpYnV0ZTtcclxufSgpKTtcblxudmFyIFZhbGlkYXRpb25SZW5kZXJlckN1c3RvbUF0dHJpYnV0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZhbGlkYXRpb25SZW5kZXJlckN1c3RvbUF0dHJpYnV0ZSgpIHtcclxuICAgIH1cclxuICAgIFZhbGlkYXRpb25SZW5kZXJlckN1c3RvbUF0dHJpYnV0ZS5wcm90b3R5cGUuY3JlYXRlZCA9IGZ1bmN0aW9uICh2aWV3KSB7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSB2aWV3LmNvbnRhaW5lcjtcclxuICAgIH07XHJcbiAgICBWYWxpZGF0aW9uUmVuZGVyZXJDdXN0b21BdHRyaWJ1dGUucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gdGhpcy5jb250YWluZXIuZ2V0KFZhbGlkYXRpb25Db250cm9sbGVyKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5jb250YWluZXIuZ2V0KHRoaXMudmFsdWUpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlci5hZGRSZW5kZXJlcih0aGlzLnJlbmRlcmVyKTtcclxuICAgIH07XHJcbiAgICBWYWxpZGF0aW9uUmVuZGVyZXJDdXN0b21BdHRyaWJ1dGUucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXIucmVtb3ZlUmVuZGVyZXIodGhpcy5yZW5kZXJlcik7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcclxuICAgIH07XHJcbiAgICBWYWxpZGF0aW9uUmVuZGVyZXJDdXN0b21BdHRyaWJ1dGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBjdXN0b21BdHRyaWJ1dGUoJ3ZhbGlkYXRpb24tcmVuZGVyZXInKVxyXG4gICAgXSwgVmFsaWRhdGlvblJlbmRlcmVyQ3VzdG9tQXR0cmlidXRlKTtcclxuICAgIHJldHVybiBWYWxpZGF0aW9uUmVuZGVyZXJDdXN0b21BdHRyaWJ1dGU7XHJcbn0oKSk7XG5cbi8qKlxyXG4gKiBTZXRzLCB1bnNldHMgYW5kIHJldHJpZXZlcyBydWxlcyBvbiBhbiBvYmplY3Qgb3IgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcbiAqL1xyXG52YXIgUnVsZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSdWxlcygpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgcnVsZXMgdG8gYSB0YXJnZXQuXHJcbiAgICAgKi9cclxuICAgIFJ1bGVzLnNldCA9IGZ1bmN0aW9uICh0YXJnZXQsIHJ1bGVzKSB7XHJcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wcm90b3R5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIFJ1bGVzLmtleSwgeyBlbnVtZXJhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBydWxlcyB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgcnVsZXMgZnJvbSBhIHRhcmdldC5cclxuICAgICAqL1xyXG4gICAgUnVsZXMudW5zZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wcm90b3R5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRhcmdldFtSdWxlcy5rZXldID0gbnVsbDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgdGFyZ2V0J3MgcnVsZXMuXHJcbiAgICAgKi9cclxuICAgIFJ1bGVzLmdldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0W1J1bGVzLmtleV0gfHwgbnVsbDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHN0b3JlcyB0aGUgcnVsZXMuXHJcbiAgICAgKi9cclxuICAgIFJ1bGVzLmtleSA9ICdfX3J1bGVzX18nO1xyXG4gICAgcmV0dXJuIFJ1bGVzO1xyXG59KCkpO1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1lbXB0eVxyXG52YXIgRXhwcmVzc2lvblZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFeHByZXNzaW9uVmlzaXRvcigpIHtcclxuICAgIH1cclxuICAgIEV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGNoYWluKSB7XHJcbiAgICAgICAgdGhpcy52aXNpdEFyZ3MoY2hhaW4uZXhwcmVzc2lvbnMpO1xyXG4gICAgfTtcclxuICAgIEV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmRpbmdCZWhhdmlvciA9IGZ1bmN0aW9uIChiZWhhdmlvcikge1xyXG4gICAgICAgIGJlaGF2aW9yLmV4cHJlc3Npb24uYWNjZXB0KHRoaXMpO1xyXG4gICAgICAgIHRoaXMudmlzaXRBcmdzKGJlaGF2aW9yLmFyZ3MpO1xyXG4gICAgfTtcclxuICAgIEV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdFZhbHVlQ29udmVydGVyID0gZnVuY3Rpb24gKGNvbnZlcnRlcikge1xyXG4gICAgICAgIGNvbnZlcnRlci5leHByZXNzaW9uLmFjY2VwdCh0aGlzKTtcclxuICAgICAgICB0aGlzLnZpc2l0QXJncyhjb252ZXJ0ZXIuYXJncyk7XHJcbiAgICB9O1xyXG4gICAgRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXNzaWduID0gZnVuY3Rpb24gKGFzc2lnbikge1xyXG4gICAgICAgIGFzc2lnbi50YXJnZXQuYWNjZXB0KHRoaXMpO1xyXG4gICAgICAgIGFzc2lnbi52YWx1ZS5hY2NlcHQodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoY29uZGl0aW9uYWwpIHtcclxuICAgICAgICBjb25kaXRpb25hbC5jb25kaXRpb24uYWNjZXB0KHRoaXMpO1xyXG4gICAgICAgIGNvbmRpdGlvbmFsLnllcy5hY2NlcHQodGhpcyk7XHJcbiAgICAgICAgY29uZGl0aW9uYWwubm8uYWNjZXB0KHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdEFjY2Vzc1RoaXMgPSBmdW5jdGlvbiAoYWNjZXNzKSB7XHJcbiAgICAgICAgYWNjZXNzLmFuY2VzdG9yID0gYWNjZXNzLmFuY2VzdG9yO1xyXG4gICAgfTtcclxuICAgIEV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdEFjY2Vzc1Njb3BlID0gZnVuY3Rpb24gKGFjY2Vzcykge1xyXG4gICAgICAgIGFjY2Vzcy5uYW1lID0gYWNjZXNzLm5hbWU7XHJcbiAgICB9O1xyXG4gICAgRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWNjZXNzTWVtYmVyID0gZnVuY3Rpb24gKGFjY2Vzcykge1xyXG4gICAgICAgIGFjY2Vzcy5vYmplY3QuYWNjZXB0KHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdEFjY2Vzc0tleWVkID0gZnVuY3Rpb24gKGFjY2Vzcykge1xyXG4gICAgICAgIGFjY2Vzcy5vYmplY3QuYWNjZXB0KHRoaXMpO1xyXG4gICAgICAgIGFjY2Vzcy5rZXkuYWNjZXB0KHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdENhbGxTY29wZSA9IGZ1bmN0aW9uIChjYWxsKSB7XHJcbiAgICAgICAgdGhpcy52aXNpdEFyZ3MoY2FsbC5hcmdzKTtcclxuICAgIH07XHJcbiAgICBFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRDYWxsRnVuY3Rpb24gPSBmdW5jdGlvbiAoY2FsbCkge1xyXG4gICAgICAgIGNhbGwuZnVuYy5hY2NlcHQodGhpcyk7XHJcbiAgICAgICAgdGhpcy52aXNpdEFyZ3MoY2FsbC5hcmdzKTtcclxuICAgIH07XHJcbiAgICBFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRDYWxsTWVtYmVyID0gZnVuY3Rpb24gKGNhbGwpIHtcclxuICAgICAgICBjYWxsLm9iamVjdC5hY2NlcHQodGhpcyk7XHJcbiAgICAgICAgdGhpcy52aXNpdEFyZ3MoY2FsbC5hcmdzKTtcclxuICAgIH07XHJcbiAgICBFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRQcmVmaXggPSBmdW5jdGlvbiAocHJlZml4KSB7XHJcbiAgICAgICAgcHJlZml4LmV4cHJlc3Npb24uYWNjZXB0KHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChiaW5hcnkpIHtcclxuICAgICAgICBiaW5hcnkubGVmdC5hY2NlcHQodGhpcyk7XHJcbiAgICAgICAgYmluYXJ5LnJpZ2h0LmFjY2VwdCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGxpdGVyYWwpIHtcclxuICAgICAgICBsaXRlcmFsLnZhbHVlID0gbGl0ZXJhbC52YWx1ZTtcclxuICAgIH07XHJcbiAgICBFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXkgPSBmdW5jdGlvbiAobGl0ZXJhbCkge1xyXG4gICAgICAgIHRoaXMudmlzaXRBcmdzKGxpdGVyYWwuZWxlbWVudHMpO1xyXG4gICAgfTtcclxuICAgIEV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxPYmplY3QgPSBmdW5jdGlvbiAobGl0ZXJhbCkge1xyXG4gICAgICAgIHRoaXMudmlzaXRBcmdzKGxpdGVyYWwudmFsdWVzKTtcclxuICAgIH07XHJcbiAgICBFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsU3RyaW5nID0gZnVuY3Rpb24gKGxpdGVyYWwpIHtcclxuICAgICAgICBsaXRlcmFsLnZhbHVlID0gbGl0ZXJhbC52YWx1ZTtcclxuICAgIH07XHJcbiAgICBFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRBcmdzID0gZnVuY3Rpb24gKGFyZ3MpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYXJnc1tpXS5hY2NlcHQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBFeHByZXNzaW9uVmlzaXRvcjtcclxufSgpKTtcblxudmFyIFZhbGlkYXRpb25NZXNzYWdlUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmFsaWRhdGlvbk1lc3NhZ2VQYXJzZXIoYmluZGlucUxhbmd1YWdlKSB7XHJcbiAgICAgICAgdGhpcy5iaW5kaW5xTGFuZ3VhZ2UgPSBiaW5kaW5xTGFuZ3VhZ2U7XHJcbiAgICAgICAgdGhpcy5lbXB0eVN0cmluZ0V4cHJlc3Npb24gPSBuZXcgTGl0ZXJhbFN0cmluZygnJyk7XHJcbiAgICAgICAgdGhpcy5udWxsRXhwcmVzc2lvbiA9IG5ldyBMaXRlcmFsUHJpbWl0aXZlKG51bGwpO1xyXG4gICAgICAgIHRoaXMudW5kZWZpbmVkRXhwcmVzc2lvbiA9IG5ldyBMaXRlcmFsUHJpbWl0aXZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgdGhpcy5jYWNoZSA9IHt9O1xyXG4gICAgfVxyXG4gICAgVmFsaWRhdGlvbk1lc3NhZ2VQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAodGhpcy5jYWNoZVttZXNzYWdlXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlW21lc3NhZ2VdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFydHMgPSB0aGlzLmJpbmRpbnFMYW5ndWFnZS5wYXJzZUludGVycG9sYXRpb24obnVsbCwgbWVzc2FnZSk7XHJcbiAgICAgICAgaWYgKHBhcnRzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFN0cmluZyhtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBuZXcgTGl0ZXJhbFN0cmluZyhwYXJ0c1swXSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICBleHByZXNzaW9uID0gbmV3IEJpbmFyeSgnKycsIGV4cHJlc3Npb24sIG5ldyBCaW5hcnkoJysnLCB0aGlzLmNvYWxlc2NlKHBhcnRzW2ldKSwgbmV3IExpdGVyYWxTdHJpbmcocGFydHNbaSArIDFdKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBNZXNzYWdlRXhwcmVzc2lvblZhbGlkYXRvci52YWxpZGF0ZShleHByZXNzaW9uLCBtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLmNhY2hlW21lc3NhZ2VdID0gZXhwcmVzc2lvbjtcclxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcclxuICAgIH07XHJcbiAgICBWYWxpZGF0aW9uTWVzc2FnZVBhcnNlci5wcm90b3R5cGUuY29hbGVzY2UgPSBmdW5jdGlvbiAocGFydCkge1xyXG4gICAgICAgIC8vIHBhcnQgPT09IG51bGwgfHwgcGFydCA9PT0gdW5kZWZpbmVkID8gJycgOiBwYXJ0XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbChuZXcgQmluYXJ5KCd8fCcsIG5ldyBCaW5hcnkoJz09PScsIHBhcnQsIHRoaXMubnVsbEV4cHJlc3Npb24pLCBuZXcgQmluYXJ5KCc9PT0nLCBwYXJ0LCB0aGlzLnVuZGVmaW5lZEV4cHJlc3Npb24pKSwgdGhpcy5lbXB0eVN0cmluZ0V4cHJlc3Npb24sIG5ldyBDYWxsTWVtYmVyKHBhcnQsICd0b1N0cmluZycsIFtdKSk7XHJcbiAgICB9O1xyXG4gICAgVmFsaWRhdGlvbk1lc3NhZ2VQYXJzZXIuaW5qZWN0ID0gW0JpbmRpbmdMYW5ndWFnZV07XHJcbiAgICByZXR1cm4gVmFsaWRhdGlvbk1lc3NhZ2VQYXJzZXI7XHJcbn0oKSk7XHJcbnZhciBNZXNzYWdlRXhwcmVzc2lvblZhbGlkYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNZXNzYWdlRXhwcmVzc2lvblZhbGlkYXRvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1lc3NhZ2VFeHByZXNzaW9uVmFsaWRhdG9yKG9yaWdpbmFsTWVzc2FnZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMub3JpZ2luYWxNZXNzYWdlID0gb3JpZ2luYWxNZXNzYWdlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE1lc3NhZ2VFeHByZXNzaW9uVmFsaWRhdG9yLnZhbGlkYXRlID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIG9yaWdpbmFsTWVzc2FnZSkge1xyXG4gICAgICAgIHZhciB2aXNpdG9yID0gbmV3IE1lc3NhZ2VFeHByZXNzaW9uVmFsaWRhdG9yKG9yaWdpbmFsTWVzc2FnZSk7XHJcbiAgICAgICAgZXhwcmVzc2lvbi5hY2NlcHQodmlzaXRvcik7XHJcbiAgICB9O1xyXG4gICAgTWVzc2FnZUV4cHJlc3Npb25WYWxpZGF0b3IucHJvdG90eXBlLnZpc2l0QWNjZXNzU2NvcGUgPSBmdW5jdGlvbiAoYWNjZXNzKSB7XHJcbiAgICAgICAgaWYgKGFjY2Vzcy5hbmNlc3RvciAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyRwYXJlbnQgaXMgbm90IHBlcm1pdHRlZCBpbiB2YWxpZGF0aW9uIG1lc3NhZ2UgZXhwcmVzc2lvbnMuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChbJ2Rpc3BsYXlOYW1lJywgJ3Byb3BlcnR5TmFtZScsICd2YWx1ZScsICdvYmplY3QnLCAnY29uZmlnJywgJ2dldERpc3BsYXlOYW1lJ10uaW5kZXhPZihhY2Nlc3MubmFtZSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGdldExvZ2dlcignYXVyZWxpYS12YWxpZGF0aW9uJylcclxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcclxuICAgICAgICAgICAgICAgIC53YXJuKFwiRGlkIHlvdSBtZWFuIHRvIHVzZSBcXFwiJFwiICsgYWNjZXNzLm5hbWUgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBhY2Nlc3MubmFtZSArIFwiXFxcIiBpbiB0aGlzIHZhbGlkYXRpb24gbWVzc2FnZSB0ZW1wbGF0ZTogXFxcIlwiICsgdGhpcy5vcmlnaW5hbE1lc3NhZ2UgKyBcIlxcXCI/XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gTWVzc2FnZUV4cHJlc3Npb25WYWxpZGF0b3I7XHJcbn0oRXhwcmVzc2lvblZpc2l0b3IpKTtcblxuLyoqXHJcbiAqIERpY3Rpb25hcnkgb2YgdmFsaWRhdGlvbiBtZXNzYWdlcy4gW21lc3NhZ2VLZXldOiBtZXNzYWdlRXhwcmVzc2lvblxyXG4gKi9cclxudmFyIHZhbGlkYXRpb25NZXNzYWdlcyA9IHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRlZmF1bHQgdmFsaWRhdGlvbiBtZXNzYWdlLiBVc2VkIHdpdGggcnVsZXMgdGhhdCBoYXZlIG5vIHN0YW5kYXJkIG1lc3NhZ2UuXHJcbiAgICAgKi9cclxuICAgIGRlZmF1bHQ6IFwiJHskZGlzcGxheU5hbWV9IGlzIGludmFsaWQuXCIsXHJcbiAgICByZXF1aXJlZDogXCIkeyRkaXNwbGF5TmFtZX0gaXMgcmVxdWlyZWQuXCIsXHJcbiAgICBtYXRjaGVzOiBcIiR7JGRpc3BsYXlOYW1lfSBpcyBub3QgY29ycmVjdGx5IGZvcm1hdHRlZC5cIixcclxuICAgIGVtYWlsOiBcIiR7JGRpc3BsYXlOYW1lfSBpcyBub3QgYSB2YWxpZCBlbWFpbC5cIixcclxuICAgIG1pbkxlbmd0aDogXCIkeyRkaXNwbGF5TmFtZX0gbXVzdCBiZSBhdCBsZWFzdCAkeyRjb25maWcubGVuZ3RofSBjaGFyYWN0ZXIkeyRjb25maWcubGVuZ3RoID09PSAxID8gJycgOiAncyd9LlwiLFxyXG4gICAgbWF4TGVuZ3RoOiBcIiR7JGRpc3BsYXlOYW1lfSBjYW5ub3QgYmUgbG9uZ2VyIHRoYW4gJHskY29uZmlnLmxlbmd0aH0gY2hhcmFjdGVyJHskY29uZmlnLmxlbmd0aCA9PT0gMSA/ICcnIDogJ3MnfS5cIixcclxuICAgIG1pbkl0ZW1zOiBcIiR7JGRpc3BsYXlOYW1lfSBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgJHskY29uZmlnLmNvdW50fSBpdGVtJHskY29uZmlnLmNvdW50ID09PSAxID8gJycgOiAncyd9LlwiLFxyXG4gICAgbWF4SXRlbXM6IFwiJHskZGlzcGxheU5hbWV9IGNhbm5vdCBjb250YWluIG1vcmUgdGhhbiAkeyRjb25maWcuY291bnR9IGl0ZW0keyRjb25maWcuY291bnQgPT09IDEgPyAnJyA6ICdzJ30uXCIsXHJcbiAgICBlcXVhbHM6IFwiJHskZGlzcGxheU5hbWV9IG11c3QgYmUgJHskY29uZmlnLmV4cGVjdGVkVmFsdWV9LlwiLFxyXG59O1xyXG4vKipcclxuICogUmV0cmlldmVzIHZhbGlkYXRpb24gbWVzc2FnZXMgYW5kIHByb3BlcnR5IGRpc3BsYXkgbmFtZXMuXHJcbiAqL1xyXG52YXIgVmFsaWRhdGlvbk1lc3NhZ2VQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZhbGlkYXRpb25NZXNzYWdlUHJvdmlkZXIocGFyc2VyKSB7XHJcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBtZXNzYWdlIGJpbmRpbmcgZXhwcmVzc2lvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBrZXkuXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBtZXNzYWdlIGtleS5cclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvbk1lc3NhZ2VQcm92aWRlci5wcm90b3R5cGUuZ2V0TWVzc2FnZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB2YXIgbWVzc2FnZTtcclxuICAgICAgICBpZiAoa2V5IGluIHZhbGlkYXRpb25NZXNzYWdlcykge1xyXG4gICAgICAgICAgICBtZXNzYWdlID0gdmFsaWRhdGlvbk1lc3NhZ2VzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtZXNzYWdlID0gdmFsaWRhdGlvbk1lc3NhZ2VzWydkZWZhdWx0J107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlci5wYXJzZShtZXNzYWdlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEZvcm11bGF0ZXMgYSBwcm9wZXJ0eSBkaXNwbGF5IG5hbWUgdXNpbmcgdGhlIHByb3BlcnR5IG5hbWUgYW5kIHRoZSBjb25maWd1cmVkXHJcbiAgICAgKiBkaXNwbGF5TmFtZSAoaWYgcHJvdmlkZWQpLlxyXG4gICAgICogT3ZlcnJpZGUgdGhpcyB3aXRoIHlvdXIgb3duIGN1c3RvbSBsb2dpYy5cclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eU5hbWUgVGhlIHByb3BlcnR5IG5hbWUuXHJcbiAgICAgKi9cclxuICAgIFZhbGlkYXRpb25NZXNzYWdlUHJvdmlkZXIucHJvdG90eXBlLmdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSwgZGlzcGxheU5hbWUpIHtcclxuICAgICAgICBpZiAoZGlzcGxheU5hbWUgIT09IG51bGwgJiYgZGlzcGxheU5hbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKGRpc3BsYXlOYW1lIGluc3RhbmNlb2YgRnVuY3Rpb24pID8gZGlzcGxheU5hbWUoKSA6IGRpc3BsYXlOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzcGxpdCBvbiB1cHBlci1jYXNlIGxldHRlcnMuXHJcbiAgICAgICAgdmFyIHdvcmRzID0gcHJvcGVydHlOYW1lLnRvU3RyaW5nKCkuc3BsaXQoLyg/PVtBLVpdKS8pLmpvaW4oJyAnKTtcclxuICAgICAgICAvLyBjYXBpdGFsaXplIGZpcnN0IGxldHRlci5cclxuICAgICAgICByZXR1cm4gd29yZHMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB3b3Jkcy5zbGljZSgxKTtcclxuICAgIH07XHJcbiAgICBWYWxpZGF0aW9uTWVzc2FnZVByb3ZpZGVyLmluamVjdCA9IFtWYWxpZGF0aW9uTWVzc2FnZVBhcnNlcl07XHJcbiAgICByZXR1cm4gVmFsaWRhdGlvbk1lc3NhZ2VQcm92aWRlcjtcclxufSgpKTtcblxuLyoqXHJcbiAqIFZhbGlkYXRlcy5cclxuICogUmVzcG9uc2libGUgZm9yIHZhbGlkYXRpbmcgb2JqZWN0cyBhbmQgcHJvcGVydGllcy5cclxuICovXHJcbnZhciBTdGFuZGFyZFZhbGlkYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTdGFuZGFyZFZhbGlkYXRvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFN0YW5kYXJkVmFsaWRhdG9yKG1lc3NhZ2VQcm92aWRlciwgcmVzb3VyY2VzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5tZXNzYWdlUHJvdmlkZXIgPSBtZXNzYWdlUHJvdmlkZXI7XHJcbiAgICAgICAgX3RoaXMubG9va3VwRnVuY3Rpb25zID0gcmVzb3VyY2VzLmxvb2t1cEZ1bmN0aW9ucztcclxuICAgICAgICBfdGhpcy5nZXREaXNwbGF5TmFtZSA9IG1lc3NhZ2VQcm92aWRlci5nZXREaXNwbGF5TmFtZS5iaW5kKG1lc3NhZ2VQcm92aWRlcik7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS5cclxuICAgICAqIEBwYXJhbSBvYmplY3QgVGhlIG9iamVjdCB0byB2YWxpZGF0ZS5cclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eU5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHZhbGlkYXRlLlxyXG4gICAgICogQHBhcmFtIHJ1bGVzIE9wdGlvbmFsLiBJZiB1bnNwZWNpZmllZCwgdGhlIHJ1bGVzIHdpbGwgYmUgbG9va2VkIHVwIHVzaW5nIHRoZSBtZXRhZGF0YVxyXG4gICAgICogZm9yIHRoZSBvYmplY3QgY3JlYXRlZCBieSBWYWxpZGF0aW9uUnVsZXMuLi4ub24oY2xhc3Mvb2JqZWN0KVxyXG4gICAgICovXHJcbiAgICBTdGFuZGFyZFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIHByb3BlcnR5TmFtZSwgcnVsZXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZShvYmplY3QsIHByb3BlcnR5TmFtZSwgcnVsZXMgfHwgbnVsbCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZXMgYWxsIHJ1bGVzIGZvciBzcGVjaWZpZWQgb2JqZWN0IGFuZCBpdCdzIHByb3BlcnRpZXMuXHJcbiAgICAgKiBAcGFyYW0gb2JqZWN0IFRoZSBvYmplY3QgdG8gdmFsaWRhdGUuXHJcbiAgICAgKiBAcGFyYW0gcnVsZXMgT3B0aW9uYWwuIElmIHVuc3BlY2lmaWVkLCB0aGUgcnVsZXMgd2lsbCBiZSBsb29rZWQgdXAgdXNpbmcgdGhlIG1ldGFkYXRhXHJcbiAgICAgKiBmb3IgdGhlIG9iamVjdCBjcmVhdGVkIGJ5IFZhbGlkYXRpb25SdWxlcy4uLi5vbihjbGFzcy9vYmplY3QpXHJcbiAgICAgKi9cclxuICAgIFN0YW5kYXJkVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZU9iamVjdCA9IGZ1bmN0aW9uIChvYmplY3QsIHJ1bGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGUob2JqZWN0LCBudWxsLCBydWxlcyB8fCBudWxsKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgd2hldGhlciBhIHJ1bGUgZXhpc3RzIGluIGEgc2V0IG9mIHJ1bGVzLlxyXG4gICAgICogQHBhcmFtIHJ1bGVzIFRoZSBydWxlcyB0byBzZWFyY2guXHJcbiAgICAgKiBAcGFyZW0gcnVsZSBUaGUgcnVsZSB0byBmaW5kLlxyXG4gICAgICovXHJcbiAgICBTdGFuZGFyZFZhbGlkYXRvci5wcm90b3R5cGUucnVsZUV4aXN0cyA9IGZ1bmN0aW9uIChydWxlcywgcnVsZSkge1xyXG4gICAgICAgIHZhciBpID0gcnVsZXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgaWYgKHJ1bGVzW2ldLmluZGV4T2YocnVsZSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgU3RhbmRhcmRWYWxpZGF0b3IucHJvdG90eXBlLmdldE1lc3NhZ2UgPSBmdW5jdGlvbiAocnVsZSwgb2JqZWN0LCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBleHByZXNzaW9uID0gcnVsZS5tZXNzYWdlIHx8IHRoaXMubWVzc2FnZVByb3ZpZGVyLmdldE1lc3NhZ2UocnVsZS5tZXNzYWdlS2V5KTtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6cHJlZmVyLWNvbnN0XHJcbiAgICAgICAgdmFyIF9hID0gcnVsZS5wcm9wZXJ0eSwgcHJvcGVydHlOYW1lID0gX2EubmFtZSwgZGlzcGxheU5hbWUgPSBfYS5kaXNwbGF5TmFtZTtcclxuICAgICAgICBpZiAocHJvcGVydHlOYW1lICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lID0gdGhpcy5tZXNzYWdlUHJvdmlkZXIuZ2V0RGlzcGxheU5hbWUocHJvcGVydHlOYW1lLCBkaXNwbGF5TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvdmVycmlkZUNvbnRleHQgPSB7XHJcbiAgICAgICAgICAgICRkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXHJcbiAgICAgICAgICAgICRwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcclxuICAgICAgICAgICAgJHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgJG9iamVjdDogb2JqZWN0LFxyXG4gICAgICAgICAgICAkY29uZmlnOiBydWxlLmNvbmZpZyxcclxuICAgICAgICAgICAgLy8gcmV0dXJucyB0aGUgbmFtZSBvZiBhIGdpdmVuIHByb3BlcnR5LCBnaXZlbiBqdXN0IHRoZSBwcm9wZXJ0eSBuYW1lIChpcnJlc3BlY3RpdmUgb2YgdGhlIHByb3BlcnR5J3MgZGlzcGxheU5hbWUpXHJcbiAgICAgICAgICAgIC8vIHNwbGl0IG9uIGNhcGl0YWwgbGV0dGVycywgZmlyc3QgbGV0dGVyIGVuc3VyZWQgdG8gYmUgY2FwaXRhbGl6ZWRcclxuICAgICAgICAgICAgJGdldERpc3BsYXlOYW1lOiB0aGlzLmdldERpc3BsYXlOYW1lXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi5ldmFsdWF0ZSh7IGJpbmRpbmdDb250ZXh0OiBvYmplY3QsIG92ZXJyaWRlQ29udGV4dDogb3ZlcnJpZGVDb250ZXh0IH0sIHRoaXMubG9va3VwRnVuY3Rpb25zKTtcclxuICAgIH07XHJcbiAgICBTdGFuZGFyZFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVSdWxlU2VxdWVuY2UgPSBmdW5jdGlvbiAob2JqZWN0LCBwcm9wZXJ0eU5hbWUsIHJ1bGVTZXF1ZW5jZSwgc2VxdWVuY2UsIHJlc3VsdHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIGFyZSB3ZSB2YWxpZGF0aW5nIGFsbCBwcm9wZXJ0aWVzIG9yIGEgc2luZ2xlIHByb3BlcnR5P1xyXG4gICAgICAgIHZhciB2YWxpZGF0ZUFsbFByb3BlcnRpZXMgPSBwcm9wZXJ0eU5hbWUgPT09IG51bGwgfHwgcHJvcGVydHlOYW1lID09PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIHJ1bGVzID0gcnVsZVNlcXVlbmNlW3NlcXVlbmNlXTtcclxuICAgICAgICB2YXIgYWxsVmFsaWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIHZhbGlkYXRlIGVhY2ggcnVsZS5cclxuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgIHZhciBydWxlID0gcnVsZXNbaV07XHJcbiAgICAgICAgICAgIC8vIGlzIHRoZSBydWxlIHJlbGF0ZWQgdG8gdGhlIHByb3BlcnR5IHdlJ3JlIHZhbGlkYXRpbmcuXHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp0cmlwbGUtZXF1YWxzIHwgVXNlIGxvb3NlIGVxdWFsaXR5IGZvciBwcm9wZXJ0eSBrZXlzXHJcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxQcm9wZXJ0aWVzICYmIHJ1bGUucHJvcGVydHkubmFtZSAhPSBwcm9wZXJ0eU5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaXMgdGhpcyBhIGNvbmRpdGlvbmFsIHJ1bGU/IGlzIHRoZSBjb25kaXRpb24gbWV0P1xyXG4gICAgICAgICAgICBpZiAocnVsZS53aGVuICYmICFydWxlLndoZW4ob2JqZWN0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB2YWxpZGF0ZS5cclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gcnVsZS5wcm9wZXJ0eS5uYW1lID09PSBudWxsID8gb2JqZWN0IDogb2JqZWN0W3J1bGUucHJvcGVydHkubmFtZV07XHJcbiAgICAgICAgICAgIHZhciBwcm9taXNlT3JCb29sZWFuID0gcnVsZS5jb25kaXRpb24odmFsdWUsIG9iamVjdCk7XHJcbiAgICAgICAgICAgIGlmICghKHByb21pc2VPckJvb2xlYW4gaW5zdGFuY2VvZiBQcm9taXNlKSkge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZU9yQm9vbGVhbiA9IFByb21pc2UucmVzb2x2ZShwcm9taXNlT3JCb29sZWFuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2VPckJvb2xlYW4udGhlbihmdW5jdGlvbiAodmFsaWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdmFsaWQgPyBudWxsIDogX3RoaXMuZ2V0TWVzc2FnZShydWxlLCBvYmplY3QsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgVmFsaWRhdGVSZXN1bHQocnVsZSwgb2JqZWN0LCBydWxlLnByb3BlcnR5Lm5hbWUsIHZhbGlkLCBtZXNzYWdlKSk7XHJcbiAgICAgICAgICAgICAgICBhbGxWYWxpZCA9IGFsbFZhbGlkICYmIHZhbGlkO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIF9sb29wXzEoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcylcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzZXF1ZW5jZSsrO1xyXG4gICAgICAgICAgICBpZiAoYWxsVmFsaWQgJiYgc2VxdWVuY2UgPCBydWxlU2VxdWVuY2UubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudmFsaWRhdGVSdWxlU2VxdWVuY2Uob2JqZWN0LCBwcm9wZXJ0eU5hbWUsIHJ1bGVTZXF1ZW5jZSwgc2VxdWVuY2UsIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFN0YW5kYXJkVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChvYmplY3QsIHByb3BlcnR5TmFtZSwgcnVsZXMpIHtcclxuICAgICAgICAvLyBydWxlcyBzcGVjaWZpZWQ/XHJcbiAgICAgICAgaWYgKCFydWxlcykge1xyXG4gICAgICAgICAgICAvLyBuby4gYXR0ZW1wdCB0byBsb2NhdGUgdGhlIHJ1bGVzLlxyXG4gICAgICAgICAgICBydWxlcyA9IFJ1bGVzLmdldChvYmplY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhbnkgcnVsZXM/XHJcbiAgICAgICAgaWYgKCFydWxlcyB8fCBydWxlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlUnVsZVNlcXVlbmNlKG9iamVjdCwgcHJvcGVydHlOYW1lLCBydWxlcywgMCwgW10pO1xyXG4gICAgfTtcclxuICAgIFN0YW5kYXJkVmFsaWRhdG9yLmluamVjdCA9IFtWYWxpZGF0aW9uTWVzc2FnZVByb3ZpZGVyLCBWaWV3UmVzb3VyY2VzXTtcclxuICAgIHJldHVybiBTdGFuZGFyZFZhbGlkYXRvcjtcclxufShWYWxpZGF0b3IpKTtcblxuLyoqXHJcbiAqIFBhcnQgb2YgdGhlIGZsdWVudCBydWxlIEFQSS4gRW5hYmxlcyBjdXN0b21pemluZyBwcm9wZXJ0eSBydWxlcy5cclxuICovXHJcbnZhciBGbHVlbnRSdWxlQ3VzdG9taXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEZsdWVudFJ1bGVDdXN0b21pemVyKHByb3BlcnR5LCBjb25kaXRpb24sIGNvbmZpZywgZmx1ZW50RW5zdXJlLCBmbHVlbnRSdWxlcywgcGFyc2Vycykge1xyXG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxyXG4gICAgICAgIHRoaXMuZmx1ZW50RW5zdXJlID0gZmx1ZW50RW5zdXJlO1xyXG4gICAgICAgIHRoaXMuZmx1ZW50UnVsZXMgPSBmbHVlbnRSdWxlcztcclxuICAgICAgICB0aGlzLnBhcnNlcnMgPSBwYXJzZXJzO1xyXG4gICAgICAgIHRoaXMucnVsZSA9IHtcclxuICAgICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5LFxyXG4gICAgICAgICAgICBjb25kaXRpb246IGNvbmRpdGlvbixcclxuICAgICAgICAgICAgY29uZmlnOiBjb25maWcsXHJcbiAgICAgICAgICAgIHdoZW46IG51bGwsXHJcbiAgICAgICAgICAgIG1lc3NhZ2VLZXk6ICdkZWZhdWx0JyxcclxuICAgICAgICAgICAgbWVzc2FnZTogbnVsbCxcclxuICAgICAgICAgICAgc2VxdWVuY2U6IGZsdWVudFJ1bGVzLnNlcXVlbmNlXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmZsdWVudEVuc3VyZS5fYWRkUnVsZSh0aGlzLnJ1bGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZSBzdWJzZXF1ZW50IHJ1bGVzIGFmdGVyIHByZXZpb3VzbHkgZGVjbGFyZWQgcnVsZXMgaGF2ZVxyXG4gICAgICogYmVlbiB2YWxpZGF0ZWQgc3VjY2Vzc2Z1bGx5LiBVc2UgdG8gcG9zdHBvbmUgdmFsaWRhdGlvbiBvZiBjb3N0bHlcclxuICAgICAqIHJ1bGVzIHVudGlsIGxlc3MgZXhwZW5zaXZlIHJ1bGVzIHBhc3MgdmFsaWRhdGlvbi5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZUN1c3RvbWl6ZXIucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5mbHVlbnRSdWxlcy5zZXF1ZW5jZSsrO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIHRoZSBrZXkgdG8gdXNlIHdoZW4gbG9va2luZyB1cCB0aGUgcnVsZSdzIHZhbGlkYXRpb24gbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZUN1c3RvbWl6ZXIucHJvdG90eXBlLndpdGhNZXNzYWdlS2V5ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHRoaXMucnVsZS5tZXNzYWdlS2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMucnVsZS5tZXNzYWdlID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZmllcyBydWxlJ3MgdmFsaWRhdGlvbiBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlQ3VzdG9taXplci5wcm90b3R5cGUud2l0aE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgIHRoaXMucnVsZS5tZXNzYWdlS2V5ID0gJ2N1c3RvbSc7XHJcbiAgICAgICAgdGhpcy5ydWxlLm1lc3NhZ2UgPSB0aGlzLnBhcnNlcnMubWVzc2FnZS5wYXJzZShtZXNzYWdlKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZmllcyBhIGNvbmRpdGlvbiB0aGF0IG11c3QgYmUgbWV0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHZhbGlkYXRlIHRoZSBydWxlLlxyXG4gICAgICogQHBhcmFtIGNvbmRpdGlvbiBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgb2JqZWN0IGFzIGEgcGFyYW1ldGVyIGFuZCByZXR1cm5zIHRydWVcclxuICAgICAqIG9yIGZhbHNlIHdoZXRoZXIgdGhlIHJ1bGUgc2hvdWxkIGJlIGV2YWx1YXRlZC5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZUN1c3RvbWl6ZXIucHJvdG90eXBlLndoZW4gPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5ydWxlLndoZW4gPSBjb25kaXRpb247XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUYWdzIHRoZSBydWxlIGluc3RhbmNlLCBlbmFibGluZyB0aGUgcnVsZSB0byBiZSBmb3VuZCBlYXNpbHlcclxuICAgICAqIHVzaW5nIFZhbGlkYXRpb25SdWxlcy50YWdnZWRSdWxlcyhydWxlcywgdGFnKVxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlQ3VzdG9taXplci5wcm90b3R5cGUudGFnID0gZnVuY3Rpb24gKHRhZykge1xyXG4gICAgICAgIHRoaXMucnVsZS50YWcgPSB0YWc7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLy8vLy8gRmx1ZW50RW5zdXJlIEFQSXMgLy8vLy9cclxuICAgIC8qKlxyXG4gICAgICogVGFyZ2V0IGEgcHJvcGVydHkgd2l0aCB2YWxpZGF0aW9uIHJ1bGVzLlxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byB0YXJnZXQuIENhbiBiZSB0aGUgcHJvcGVydHkgbmFtZSBvciBhIHByb3BlcnR5IGFjY2Vzc29yIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlQ3VzdG9taXplci5wcm90b3R5cGUuZW5zdXJlID0gZnVuY3Rpb24gKHN1YmplY3QpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mbHVlbnRFbnN1cmUuZW5zdXJlKHN1YmplY3QpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGFyZ2V0cyBhbiBvYmplY3Qgd2l0aCB2YWxpZGF0aW9uIHJ1bGVzLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlQ3VzdG9taXplci5wcm90b3R5cGUuZW5zdXJlT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZsdWVudEVuc3VyZS5lbnN1cmVPYmplY3QoKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmx1ZW50UnVsZUN1c3RvbWl6ZXIucHJvdG90eXBlLCBcInJ1bGVzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSdWxlcyB0aGF0IGhhdmUgYmVlbiBkZWZpbmVkIHVzaW5nIHRoZSBmbHVlbnQgQVBJLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbHVlbnRFbnN1cmUucnVsZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIHJ1bGVzIHRvIGEgY2xhc3Mgb3Igb2JqZWN0LCBtYWtpbmcgdGhlbSBkaXNjb3ZlcmFibGUgYnkgdGhlIFN0YW5kYXJkVmFsaWRhdG9yLlxyXG4gICAgICogQHBhcmFtIHRhcmdldCBBIGNsYXNzIG9yIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZUN1c3RvbWl6ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZsdWVudEVuc3VyZS5vbih0YXJnZXQpO1xyXG4gICAgfTtcclxuICAgIC8vLy8vLy8vLyBGbHVlbnRSdWxlcyBBUElzIC8vLy8vLy8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIGFuIGFkLWhvYyBydWxlIGZ1bmN0aW9uIHRvIHRoZSBlbnN1cmVkIHByb3BlcnR5IG9yIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBjb25kaXRpb24gVGhlIGZ1bmN0aW9uIHRvIHZhbGlkYXRlIHRoZSBydWxlLlxyXG4gICAgICogV2lsbCBiZSBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzLCB0aGUgcHJvcGVydHkgdmFsdWUgYW5kIHRoZSBvYmplY3QuXHJcbiAgICAgKiBTaG91bGQgcmV0dXJuIGEgYm9vbGVhbiBvciBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGJvb2xlYW4uXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVDdXN0b21pemVyLnByb3RvdHlwZS5zYXRpc2ZpZXMgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBjb25maWcpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mbHVlbnRSdWxlcy5zYXRpc2ZpZXMoY29uZGl0aW9uLCBjb25maWcpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyBhIHJ1bGUgYnkgbmFtZS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gb3Igc3RhbmRhcmQgcnVsZS5cclxuICAgICAqIEBwYXJhbSBhcmdzIFRoZSBydWxlJ3MgYXJndW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlQ3VzdG9taXplci5wcm90b3R5cGUuc2F0aXNmaWVzUnVsZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuZmx1ZW50UnVsZXMpLnNhdGlzZmllc1J1bGUuYXBwbHkoX2EsIFtuYW1lXS5jb25jYXQoYXJncykpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJyZXF1aXJlZFwiIHJ1bGUgdG8gdGhlIHByb3BlcnR5LlxyXG4gICAgICogVGhlIHZhbHVlIGNhbm5vdCBiZSBudWxsLCB1bmRlZmluZWQgb3Igd2hpdGVzcGFjZS5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZUN1c3RvbWl6ZXIucHJvdG90eXBlLnJlcXVpcmVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZsdWVudFJ1bGVzLnJlcXVpcmVkKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIm1hdGNoZXNcIiBydWxlIHRvIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqIFZhbHVlIG11c3QgbWF0Y2ggdGhlIHNwZWNpZmllZCByZWd1bGFyIGV4cHJlc3Npb24uXHJcbiAgICAgKiBudWxsLCB1bmRlZmluZWQgYW5kIGVtcHR5LXN0cmluZyB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVDdXN0b21pemVyLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKHJlZ2V4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmx1ZW50UnVsZXMubWF0Y2hlcyhyZWdleCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcImVtYWlsXCIgcnVsZSB0byB0aGUgcHJvcGVydHkuXHJcbiAgICAgKiBudWxsLCB1bmRlZmluZWQgYW5kIGVtcHR5LXN0cmluZyB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVDdXN0b21pemVyLnByb3RvdHlwZS5lbWFpbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mbHVlbnRSdWxlcy5lbWFpbCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJtaW5MZW5ndGhcIiBTVFJJTkcgdmFsaWRhdGlvbiBydWxlIHRvIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqIG51bGwsIHVuZGVmaW5lZCBhbmQgZW1wdHktc3RyaW5nIHZhbHVlcyBhcmUgY29uc2lkZXJlZCB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZUN1c3RvbWl6ZXIucHJvdG90eXBlLm1pbkxlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mbHVlbnRSdWxlcy5taW5MZW5ndGgobGVuZ3RoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwibWF4TGVuZ3RoXCIgU1RSSU5HIHZhbGlkYXRpb24gcnVsZSB0byB0aGUgcHJvcGVydHkuXHJcbiAgICAgKiBudWxsLCB1bmRlZmluZWQgYW5kIGVtcHR5LXN0cmluZyB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVDdXN0b21pemVyLnByb3RvdHlwZS5tYXhMZW5ndGggPSBmdW5jdGlvbiAobGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmx1ZW50UnVsZXMubWF4TGVuZ3RoKGxlbmd0aCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIm1pbkl0ZW1zXCIgQVJSQVkgdmFsaWRhdGlvbiBydWxlIHRvIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqIG51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVDdXN0b21pemVyLnByb3RvdHlwZS5taW5JdGVtcyA9IGZ1bmN0aW9uIChjb3VudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZsdWVudFJ1bGVzLm1pbkl0ZW1zKGNvdW50KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwibWF4SXRlbXNcIiBBUlJBWSB2YWxpZGF0aW9uIHJ1bGUgdG8gdGhlIHByb3BlcnR5LlxyXG4gICAgICogbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcyBhcmUgY29uc2lkZXJlZCB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZUN1c3RvbWl6ZXIucHJvdG90eXBlLm1heEl0ZW1zID0gZnVuY3Rpb24gKGNvdW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmx1ZW50UnVsZXMubWF4SXRlbXMoY291bnQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJlcXVhbHNcIiB2YWxpZGF0aW9uIHJ1bGUgdG8gdGhlIHByb3BlcnR5LlxyXG4gICAgICogbnVsbCwgdW5kZWZpbmVkIGFuZCBlbXB0eS1zdHJpbmcgdmFsdWVzIGFyZSBjb25zaWRlcmVkIHZhbGlkLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlQ3VzdG9taXplci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGV4cGVjdGVkVmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mbHVlbnRSdWxlcy5lcXVhbHMoZXhwZWN0ZWRWYWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZsdWVudFJ1bGVDdXN0b21pemVyO1xyXG59KCkpO1xyXG4vKipcclxuICogUGFydCBvZiB0aGUgZmx1ZW50IHJ1bGUgQVBJLiBFbmFibGVzIGFwcGx5aW5nIHJ1bGVzIHRvIHByb3BlcnRpZXMgYW5kIG9iamVjdHMuXHJcbiAqL1xyXG52YXIgRmx1ZW50UnVsZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGbHVlbnRSdWxlcyhmbHVlbnRFbnN1cmUsIHBhcnNlcnMsIHByb3BlcnR5KSB7XHJcbiAgICAgICAgdGhpcy5mbHVlbnRFbnN1cmUgPSBmbHVlbnRFbnN1cmU7XHJcbiAgICAgICAgdGhpcy5wYXJzZXJzID0gcGFyc2VycztcclxuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3VycmVudCBydWxlIHNlcXVlbmNlIG51bWJlci4gVXNlZCB0byBwb3N0cG9uZSBldmFsdWF0aW9uIG9mIHJ1bGVzIHVudGlsIHJ1bGVzXHJcbiAgICAgICAgICogd2l0aCBsb3dlciBzZXF1ZW5jZSBudW1iZXIgaGF2ZSBzdWNjZXNzZnVsbHkgdmFsaWRhdGVkLiBUaGUgXCJ0aGVuXCIgZmx1ZW50IEFQSSBtZXRob2RcclxuICAgICAgICAgKiBtYW5hZ2VzIHRoaXMgcHJvcGVydHksIHRoZXJlJ3MgdXN1YWxseSBubyBuZWVkIHRvIHNldCBpdCBkaXJlY3RseS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNlcXVlbmNlID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZGlzcGxheSBuYW1lIG9mIHRoZSBlbnN1cmVkIHByb3BlcnR5LlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlcy5wcm90b3R5cGUuZGlzcGxheU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHRoaXMucHJvcGVydHkuZGlzcGxheU5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyBhbiBhZC1ob2MgcnVsZSBmdW5jdGlvbiB0byB0aGUgZW5zdXJlZCBwcm9wZXJ0eSBvciBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gY29uZGl0aW9uIFRoZSBmdW5jdGlvbiB0byB2YWxpZGF0ZSB0aGUgcnVsZS5cclxuICAgICAqIFdpbGwgYmUgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50cywgdGhlIHByb3BlcnR5IHZhbHVlIGFuZCB0aGUgb2JqZWN0LlxyXG4gICAgICogU2hvdWxkIHJldHVybiBhIGJvb2xlYW4gb3IgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBib29sZWFuLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlcy5wcm90b3R5cGUuc2F0aXNmaWVzID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgY29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGbHVlbnRSdWxlQ3VzdG9taXplcih0aGlzLnByb3BlcnR5LCBjb25kaXRpb24sIGNvbmZpZywgdGhpcy5mbHVlbnRFbnN1cmUsIHRoaXMsIHRoaXMucGFyc2Vycyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIGEgcnVsZSBieSBuYW1lLlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGN1c3RvbSBvciBzdGFuZGFyZCBydWxlLlxyXG4gICAgICogQHBhcmFtIGFyZ3MgVGhlIHJ1bGUncyBhcmd1bWVudHMuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVzLnByb3RvdHlwZS5zYXRpc2ZpZXNSdWxlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJ1bGUgPSBGbHVlbnRSdWxlcy5jdXN0b21SdWxlc1tuYW1lXTtcclxuICAgICAgICBpZiAoIXJ1bGUpIHtcclxuICAgICAgICAgICAgLy8gc3RhbmRhcmQgcnVsZT9cclxuICAgICAgICAgICAgcnVsZSA9IHRoaXNbbmFtZV07XHJcbiAgICAgICAgICAgIGlmIChydWxlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBydWxlLmNhbGwuYXBwbHkocnVsZSwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUnVsZSB3aXRoIG5hbWUgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBkb2VzIG5vdCBleGlzdC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb25maWcgPSBydWxlLmFyZ3NUb0NvbmZpZyA/IHJ1bGUuYXJnc1RvQ29uZmlnLmFwcGx5KHJ1bGUsIGFyZ3MpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNhdGlzZmllcyhmdW5jdGlvbiAodmFsdWUsIG9iaikge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBydWxlLmNvbmRpdGlvbikuY2FsbC5hcHBseShfYSwgW190aGlzLCB2YWx1ZSwgb2JqXS5jb25jYXQoYXJncykpO1xyXG4gICAgICAgIH0sIGNvbmZpZylcclxuICAgICAgICAgICAgLndpdGhNZXNzYWdlS2V5KG5hbWUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJyZXF1aXJlZFwiIHJ1bGUgdG8gdGhlIHByb3BlcnR5LlxyXG4gICAgICogVGhlIHZhbHVlIGNhbm5vdCBiZSBudWxsLCB1bmRlZmluZWQgb3Igd2hpdGVzcGFjZS5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZXMucHJvdG90eXBlLnJlcXVpcmVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNhdGlzZmllcyhmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsXHJcbiAgICAgICAgICAgICAgICAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAmJiAhKGlzU3RyaW5nKHZhbHVlKSAmJiAhL1xcUy8udGVzdCh2YWx1ZSkpO1xyXG4gICAgICAgIH0pLndpdGhNZXNzYWdlS2V5KCdyZXF1aXJlZCcpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJtYXRjaGVzXCIgcnVsZSB0byB0aGUgcHJvcGVydHkuXHJcbiAgICAgKiBWYWx1ZSBtdXN0IG1hdGNoIHRoZSBzcGVjaWZpZWQgcmVndWxhciBleHByZXNzaW9uLlxyXG4gICAgICogbnVsbCwgdW5kZWZpbmVkIGFuZCBlbXB0eS1zdHJpbmcgdmFsdWVzIGFyZSBjb25zaWRlcmVkIHZhbGlkLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlcy5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChyZWdleCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNhdGlzZmllcyhmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUubGVuZ3RoID09PSAwIHx8IHJlZ2V4LnRlc3QodmFsdWUpOyB9KVxyXG4gICAgICAgICAgICAud2l0aE1lc3NhZ2VLZXkoJ21hdGNoZXMnKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwiZW1haWxcIiBydWxlIHRvIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqIG51bGwsIHVuZGVmaW5lZCBhbmQgZW1wdHktc3RyaW5nIHZhbHVlcyBhcmUgY29uc2lkZXJlZCB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZXMucHJvdG90eXBlLmVtYWlsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHJlZ2V4IGZyb20gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzc1xyXG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoZXMoL15bYS16QS1aMC05LiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC8pXHJcbiAgICAgICAgICAgIC8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXHJcbiAgICAgICAgICAgIC53aXRoTWVzc2FnZUtleSgnZW1haWwnKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFwibWluTGVuZ3RoXCIgU1RSSU5HIHZhbGlkYXRpb24gcnVsZSB0byB0aGUgcHJvcGVydHkuXHJcbiAgICAgKiBudWxsLCB1bmRlZmluZWQgYW5kIGVtcHR5LXN0cmluZyB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVzLnByb3RvdHlwZS5taW5MZW5ndGggPSBmdW5jdGlvbiAobGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2F0aXNmaWVzKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZS5sZW5ndGggPT09IDAgfHwgdmFsdWUubGVuZ3RoID49IGxlbmd0aDsgfSwgeyBsZW5ndGg6IGxlbmd0aCB9KVxyXG4gICAgICAgICAgICAud2l0aE1lc3NhZ2VLZXkoJ21pbkxlbmd0aCcpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgXCJtYXhMZW5ndGhcIiBTVFJJTkcgdmFsaWRhdGlvbiBydWxlIHRvIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqIG51bGwsIHVuZGVmaW5lZCBhbmQgZW1wdHktc3RyaW5nIHZhbHVlcyBhcmUgY29uc2lkZXJlZCB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50UnVsZXMucHJvdG90eXBlLm1heExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zYXRpc2ZpZXMoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCB8fCB2YWx1ZS5sZW5ndGggPD0gbGVuZ3RoOyB9LCB7IGxlbmd0aDogbGVuZ3RoIH0pXHJcbiAgICAgICAgICAgIC53aXRoTWVzc2FnZUtleSgnbWF4TGVuZ3RoJyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIm1pbkl0ZW1zXCIgQVJSQVkgdmFsaWRhdGlvbiBydWxlIHRvIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqIG51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVzLnByb3RvdHlwZS5taW5JdGVtcyA9IGZ1bmN0aW9uIChjb3VudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNhdGlzZmllcyhmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUubGVuZ3RoID49IGNvdW50OyB9LCB7IGNvdW50OiBjb3VudCB9KVxyXG4gICAgICAgICAgICAud2l0aE1lc3NhZ2VLZXkoJ21pbkl0ZW1zJyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcIm1heEl0ZW1zXCIgQVJSQVkgdmFsaWRhdGlvbiBydWxlIHRvIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqIG51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudFJ1bGVzLnByb3RvdHlwZS5tYXhJdGVtcyA9IGZ1bmN0aW9uIChjb3VudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNhdGlzZmllcyhmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUubGVuZ3RoIDw9IGNvdW50OyB9LCB7IGNvdW50OiBjb3VudCB9KVxyXG4gICAgICAgICAgICAud2l0aE1lc3NhZ2VLZXkoJ21heEl0ZW1zJyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBcImVxdWFsc1wiIHZhbGlkYXRpb24gcnVsZSB0byB0aGUgcHJvcGVydHkuXHJcbiAgICAgKiBudWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzIGFyZSBjb25zaWRlcmVkIHZhbGlkLlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRSdWxlcy5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGV4cGVjdGVkVmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zYXRpc2ZpZXMoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gZXhwZWN0ZWRWYWx1ZTsgfSwgeyBleHBlY3RlZFZhbHVlOiBleHBlY3RlZFZhbHVlIH0pXHJcbiAgICAgICAgICAgIC53aXRoTWVzc2FnZUtleSgnZXF1YWxzJyk7XHJcbiAgICB9O1xyXG4gICAgRmx1ZW50UnVsZXMuY3VzdG9tUnVsZXMgPSB7fTtcclxuICAgIHJldHVybiBGbHVlbnRSdWxlcztcclxufSgpKTtcclxuLyoqXHJcbiAqIFBhcnQgb2YgdGhlIGZsdWVudCBydWxlIEFQSS4gRW5hYmxlcyB0YXJnZXRpbmcgcHJvcGVydGllcyBhbmQgb2JqZWN0cyB3aXRoIHJ1bGVzLlxyXG4gKi9cclxudmFyIEZsdWVudEVuc3VyZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEZsdWVudEVuc3VyZShwYXJzZXJzKSB7XHJcbiAgICAgICAgdGhpcy5wYXJzZXJzID0gcGFyc2VycztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSdWxlcyB0aGF0IGhhdmUgYmVlbiBkZWZpbmVkIHVzaW5nIHRoZSBmbHVlbnQgQVBJLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucnVsZXMgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGFyZ2V0IGEgcHJvcGVydHkgd2l0aCB2YWxpZGF0aW9uIHJ1bGVzLlxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byB0YXJnZXQuIENhbiBiZSB0aGUgcHJvcGVydHkgbmFtZSBvciBhIHByb3BlcnR5IGFjY2Vzc29yXHJcbiAgICAgKiBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgRmx1ZW50RW5zdXJlLnByb3RvdHlwZS5lbnN1cmUgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcclxuICAgICAgICB0aGlzLmFzc2VydEluaXRpYWxpemVkKCk7XHJcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlcnMucHJvcGVydHkucGFyc2UocHJvcGVydHkpO1xyXG4gICAgICAgIHZhciBmbHVlbnRSdWxlcyA9IG5ldyBGbHVlbnRSdWxlcyh0aGlzLCB0aGlzLnBhcnNlcnMsIHsgbmFtZTogbmFtZSwgZGlzcGxheU5hbWU6IG51bGwgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2VSdWxlcyhmbHVlbnRSdWxlcywgbmFtZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUYXJnZXRzIGFuIG9iamVjdCB3aXRoIHZhbGlkYXRpb24gcnVsZXMuXHJcbiAgICAgKi9cclxuICAgIEZsdWVudEVuc3VyZS5wcm90b3R5cGUuZW5zdXJlT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYXNzZXJ0SW5pdGlhbGl6ZWQoKTtcclxuICAgICAgICB2YXIgZmx1ZW50UnVsZXMgPSBuZXcgRmx1ZW50UnVsZXModGhpcywgdGhpcy5wYXJzZXJzLCB7IG5hbWU6IG51bGwsIGRpc3BsYXlOYW1lOiBudWxsIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lcmdlUnVsZXMoZmx1ZW50UnVsZXMsIG51bGwpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgcnVsZXMgdG8gYSBjbGFzcyBvciBvYmplY3QsIG1ha2luZyB0aGVtIGRpc2NvdmVyYWJsZSBieSB0aGUgU3RhbmRhcmRWYWxpZGF0b3IuXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IEEgY2xhc3Mgb3Igb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBGbHVlbnRFbnN1cmUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIFJ1bGVzLnNldCh0YXJnZXQsIHRoaXMucnVsZXMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJ1bGUgZGVmaW5pdGlvbiB0byB0aGUgc2VxdWVuY2VkIHJ1bGVzZXQuXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgRmx1ZW50RW5zdXJlLnByb3RvdHlwZS5fYWRkUnVsZSA9IGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMucnVsZXMubGVuZ3RoIDwgcnVsZS5zZXF1ZW5jZSArIDEpIHtcclxuICAgICAgICAgICAgdGhpcy5ydWxlcy5wdXNoKFtdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ydWxlc1tydWxlLnNlcXVlbmNlXS5wdXNoKHJ1bGUpO1xyXG4gICAgfTtcclxuICAgIEZsdWVudEVuc3VyZS5wcm90b3R5cGUuYXNzZXJ0SW5pdGlhbGl6ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGFyc2Vycykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpZCB5b3UgZm9yZ2V0IHRvIGFkZCBcXFwiLnBsdWdpbignYXVyZWxpYS12YWxpZGF0aW9uJylcXFwiIHRvIHlvdXIgbWFpbi5qcz9cIik7XHJcbiAgICB9O1xyXG4gICAgRmx1ZW50RW5zdXJlLnByb3RvdHlwZS5tZXJnZVJ1bGVzID0gZnVuY3Rpb24gKGZsdWVudFJ1bGVzLCBwcm9wZXJ0eU5hbWUpIHtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dHJpcGxlLWVxdWFscyB8IFVzZSBsb29zZSBlcXVhbGl0eSBmb3IgcHJvcGVydHkga2V5c1xyXG4gICAgICAgIHZhciBleGlzdGluZ1J1bGVzID0gdGhpcy5ydWxlcy5maW5kKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLmxlbmd0aCA+IDAgJiYgclswXS5wcm9wZXJ0eS5uYW1lID09IHByb3BlcnR5TmFtZTsgfSk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nUnVsZXMpIHtcclxuICAgICAgICAgICAgdmFyIHJ1bGUgPSBleGlzdGluZ1J1bGVzW2V4aXN0aW5nUnVsZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGZsdWVudFJ1bGVzLnNlcXVlbmNlID0gcnVsZS5zZXF1ZW5jZTtcclxuICAgICAgICAgICAgaWYgKHJ1bGUucHJvcGVydHkuZGlzcGxheU5hbWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZsdWVudFJ1bGVzID0gZmx1ZW50UnVsZXMuZGlzcGxheU5hbWUocnVsZS5wcm9wZXJ0eS5kaXNwbGF5TmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZsdWVudFJ1bGVzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGbHVlbnRFbnN1cmU7XHJcbn0oKSk7XHJcbi8qKlxyXG4gKiBGbHVlbnQgcnVsZSBkZWZpbml0aW9uIEFQSS5cclxuICovXHJcbnZhciBWYWxpZGF0aW9uUnVsZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWYWxpZGF0aW9uUnVsZXMoKSB7XHJcbiAgICB9XHJcbiAgICBWYWxpZGF0aW9uUnVsZXMuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChtZXNzYWdlUGFyc2VyLCBwcm9wZXJ0eVBhcnNlcikge1xyXG4gICAgICAgIHRoaXMucGFyc2VycyA9IHtcclxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVBhcnNlcixcclxuICAgICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5UGFyc2VyXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRhcmdldCBhIHByb3BlcnR5IHdpdGggdmFsaWRhdGlvbiBydWxlcy5cclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkgdG8gdGFyZ2V0LiBDYW4gYmUgdGhlIHByb3BlcnR5IG5hbWUgb3IgYSBwcm9wZXJ0eSBhY2Nlc3NvciBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvblJ1bGVzLmVuc3VyZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmx1ZW50RW5zdXJlKFZhbGlkYXRpb25SdWxlcy5wYXJzZXJzKS5lbnN1cmUocHJvcGVydHkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGFyZ2V0cyBhbiBvYmplY3Qgd2l0aCB2YWxpZGF0aW9uIHJ1bGVzLlxyXG4gICAgICovXHJcbiAgICBWYWxpZGF0aW9uUnVsZXMuZW5zdXJlT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmx1ZW50RW5zdXJlKFZhbGlkYXRpb25SdWxlcy5wYXJzZXJzKS5lbnN1cmVPYmplY3QoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgYSBjdXN0b20gcnVsZS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gcnVsZS4gQWxzbyBzZXJ2ZXMgYXMgdGhlIG1lc3NhZ2Uga2V5LlxyXG4gICAgICogQHBhcmFtIGNvbmRpdGlvbiBUaGUgcnVsZSBmdW5jdGlvbi5cclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIGV4cHJlc3Npb25cclxuICAgICAqIEBwYXJhbSBhcmdzVG9Db25maWcgQSBmdW5jdGlvbiB0aGF0IG1hcHMgdGhlIHJ1bGUncyBhcmd1bWVudHMgdG8gYSBcImNvbmZpZ1wiXHJcbiAgICAgKiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB3aGVuIGV2YWx1YXRpbmcgdGhlIG1lc3NhZ2UgZXhwcmVzc2lvbi5cclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvblJ1bGVzLmN1c3RvbVJ1bGUgPSBmdW5jdGlvbiAobmFtZSwgY29uZGl0aW9uLCBtZXNzYWdlLCBhcmdzVG9Db25maWcpIHtcclxuICAgICAgICB2YWxpZGF0aW9uTWVzc2FnZXNbbmFtZV0gPSBtZXNzYWdlO1xyXG4gICAgICAgIEZsdWVudFJ1bGVzLmN1c3RvbVJ1bGVzW25hbWVdID0geyBjb25kaXRpb246IGNvbmRpdGlvbiwgYXJnc1RvQ29uZmlnOiBhcmdzVG9Db25maWcgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgcnVsZXMgd2l0aCB0aGUgbWF0Y2hpbmcgdGFnLlxyXG4gICAgICogQHBhcmFtIHJ1bGVzIFRoZSBydWxlcyB0byBzZWFyY2guXHJcbiAgICAgKiBAcGFyYW0gdGFnIFRoZSB0YWcgdG8gc2VhcmNoIGZvci5cclxuICAgICAqL1xyXG4gICAgVmFsaWRhdGlvblJ1bGVzLnRhZ2dlZFJ1bGVzID0gZnVuY3Rpb24gKHJ1bGVzLCB0YWcpIHtcclxuICAgICAgICByZXR1cm4gcnVsZXMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gci50YWcgPT09IHRhZzsgfSk7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBydWxlcyB0aGF0IGhhdmUgbm8gdGFnLlxyXG4gICAgICogQHBhcmFtIHJ1bGVzIFRoZSBydWxlcyB0byBzZWFyY2guXHJcbiAgICAgKi9cclxuICAgIFZhbGlkYXRpb25SdWxlcy51bnRhZ2dlZFJ1bGVzID0gZnVuY3Rpb24gKHJ1bGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJ1bGVzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIudGFnID09PSB1bmRlZmluZWQ7IH0pOyB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHJ1bGVzIGZyb20gYSBjbGFzcyBvciBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IEEgY2xhc3Mgb3Igb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBWYWxpZGF0aW9uUnVsZXMub2ZmID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIFJ1bGVzLnVuc2V0KHRhcmdldCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFZhbGlkYXRpb25SdWxlcztcclxufSgpKTtcblxuLy8gRXhwb3J0c1xyXG4vKipcclxuICogQXVyZWxpYSBWYWxpZGF0aW9uIENvbmZpZ3VyYXRpb24gQVBJXHJcbiAqL1xyXG52YXIgQXVyZWxpYVZhbGlkYXRpb25Db25maWd1cmF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXVyZWxpYVZhbGlkYXRpb25Db25maWd1cmF0aW9uKCkge1xyXG4gICAgICAgIHRoaXMudmFsaWRhdG9yVHlwZSA9IFN0YW5kYXJkVmFsaWRhdG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2UgYSBjdXN0b20gVmFsaWRhdG9yIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICovXHJcbiAgICBBdXJlbGlhVmFsaWRhdGlvbkNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLmN1c3RvbVZhbGlkYXRvciA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0b3JUeXBlID0gdHlwZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgKi9cclxuICAgIEF1cmVsaWFWYWxpZGF0aW9uQ29uZmlndXJhdGlvbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdmFyIHZhbGlkYXRvciA9IGNvbnRhaW5lci5nZXQodGhpcy52YWxpZGF0b3JUeXBlKTtcclxuICAgICAgICBjb250YWluZXIucmVnaXN0ZXJJbnN0YW5jZShWYWxpZGF0b3IsIHZhbGlkYXRvcik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEF1cmVsaWFWYWxpZGF0aW9uQ29uZmlndXJhdGlvbjtcclxufSgpKTtcclxuLyoqXHJcbiAqIENvbmZpZ3VyZXMgdGhlIHBsdWdpbi5cclxuICovXHJcbmZ1bmN0aW9uIGNvbmZpZ3VyZShcclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmJhbi10eXBlc1xyXG5mcmFtZXdvcmtDb25maWcsIGNhbGxiYWNrKSB7XHJcbiAgICAvLyB0aGUgZmx1ZW50IHJ1bGUgZGVmaW5pdGlvbiBBUEkgbmVlZHMgdGhlIHBhcnNlciB0byB0cmFuc2xhdGUgbWVzc2FnZXNcclxuICAgIC8vIHRvIGludGVycG9sYXRpb24gZXhwcmVzc2lvbnMuXHJcbiAgICB2YXIgbWVzc2FnZVBhcnNlciA9IGZyYW1ld29ya0NvbmZpZy5jb250YWluZXIuZ2V0KFZhbGlkYXRpb25NZXNzYWdlUGFyc2VyKTtcclxuICAgIHZhciBwcm9wZXJ0eVBhcnNlciA9IGZyYW1ld29ya0NvbmZpZy5jb250YWluZXIuZ2V0KFByb3BlcnR5QWNjZXNzb3JQYXJzZXIpO1xyXG4gICAgVmFsaWRhdGlvblJ1bGVzLmluaXRpYWxpemUobWVzc2FnZVBhcnNlciwgcHJvcGVydHlQYXJzZXIpO1xyXG4gICAgLy8gY29uZmlndXJlLi4uXHJcbiAgICB2YXIgY29uZmlnID0gbmV3IEF1cmVsaWFWYWxpZGF0aW9uQ29uZmlndXJhdGlvbigpO1xyXG4gICAgaWYgKGNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICBjYWxsYmFjayhjb25maWcpO1xyXG4gICAgfVxyXG4gICAgY29uZmlnLmFwcGx5KGZyYW1ld29ya0NvbmZpZy5jb250YWluZXIpO1xyXG4gICAgLy8gZ2xvYmFsaXplIHRoZSBiZWhhdmlvcnMuXHJcbiAgICBpZiAoZnJhbWV3b3JrQ29uZmlnLmdsb2JhbFJlc291cmNlcykge1xyXG4gICAgICAgIGZyYW1ld29ya0NvbmZpZy5nbG9iYWxSZXNvdXJjZXMoVmFsaWRhdGVCaW5kaW5nQmVoYXZpb3IsIFZhbGlkYXRlTWFudWFsbHlCaW5kaW5nQmVoYXZpb3IsIFZhbGlkYXRlT25CbHVyQmluZGluZ0JlaGF2aW9yLCBWYWxpZGF0ZU9uQ2hhbmdlQmluZGluZ0JlaGF2aW9yLCBWYWxpZGF0ZU9uQ2hhbmdlT3JCbHVyQmluZGluZ0JlaGF2aW9yLCBWYWxpZGF0aW9uRXJyb3JzQ3VzdG9tQXR0cmlidXRlLCBWYWxpZGF0aW9uUmVuZGVyZXJDdXN0b21BdHRyaWJ1dGUpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IEF1cmVsaWFWYWxpZGF0aW9uQ29uZmlndXJhdGlvbiwgY29uZmlndXJlLCBnZXRUYXJnZXRET01FbGVtZW50LCBnZXRQcm9wZXJ0eUluZm8sIFByb3BlcnR5QWNjZXNzb3JQYXJzZXIsIGdldEFjY2Vzc29yRXhwcmVzc2lvbiwgVmFsaWRhdGVCaW5kaW5nQmVoYXZpb3IsIFZhbGlkYXRlTWFudWFsbHlCaW5kaW5nQmVoYXZpb3IsIFZhbGlkYXRlT25CbHVyQmluZGluZ0JlaGF2aW9yLCBWYWxpZGF0ZU9uQ2hhbmdlQmluZGluZ0JlaGF2aW9yLCBWYWxpZGF0ZU9uQ2hhbmdlT3JCbHVyQmluZGluZ0JlaGF2aW9yLCBWYWxpZGF0ZUV2ZW50LCBWYWxpZGF0ZVJlc3VsdCwgdmFsaWRhdGVUcmlnZ2VyLCBWYWxpZGF0aW9uQ29udHJvbGxlciwgVmFsaWRhdGlvbkNvbnRyb2xsZXJGYWN0b3J5LCBWYWxpZGF0aW9uRXJyb3JzQ3VzdG9tQXR0cmlidXRlLCBWYWxpZGF0aW9uUmVuZGVyZXJDdXN0b21BdHRyaWJ1dGUsIFZhbGlkYXRvciwgUnVsZXMsIFN0YW5kYXJkVmFsaWRhdG9yLCB2YWxpZGF0aW9uTWVzc2FnZXMsIFZhbGlkYXRpb25NZXNzYWdlUHJvdmlkZXIsIFZhbGlkYXRpb25NZXNzYWdlUGFyc2VyLCBNZXNzYWdlRXhwcmVzc2lvblZhbGlkYXRvciwgRmx1ZW50UnVsZUN1c3RvbWl6ZXIsIEZsdWVudFJ1bGVzLCBGbHVlbnRFbnN1cmUsIFZhbGlkYXRpb25SdWxlcyB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8NeG\n");

/***/ })

}]);