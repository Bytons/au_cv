(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendor.aurelia-polyfills~dc8a991d"],{

/***/ "Q/5p":
/*!*********************************************************************************!*\
  !*** ./node_modules/aurelia-polyfills/dist/native-modules/aurelia-polyfills.js ***!
  \*********************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-pal */ \"70NS\");\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n\n\nif (typeof FEATURE_NO_ES2015 === 'undefined') {\n\n  (function (Object, GOPS) {\n    'use strict';\n\n    if (GOPS in Object) return;\n\n    var setDescriptor,\n        G = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__[\"PLATFORM\"].global,\n        id = 0,\n        random = '' + Math.random(),\n        prefix = '__\\x01symbol:',\n        prefixLength = prefix.length,\n        internalSymbol = '__\\x01symbol@@' + random,\n        DP = 'defineProperty',\n        DPies = 'defineProperties',\n        GOPN = 'getOwnPropertyNames',\n        GOPD = 'getOwnPropertyDescriptor',\n        PIE = 'propertyIsEnumerable',\n        gOPN = Object[GOPN],\n        gOPD = Object[GOPD],\n        create = Object.create,\n        keys = Object.keys,\n        defineProperty = Object[DP],\n        $defineProperties = Object[DPies],\n        descriptor = gOPD(Object, GOPN),\n        ObjectProto = Object.prototype,\n        hOP = ObjectProto.hasOwnProperty,\n        pIE = ObjectProto[PIE],\n        toString = ObjectProto.toString,\n        indexOf = Array.prototype.indexOf || function (v) {\n      for (var i = this.length; i-- && this[i] !== v;) {}\n      return i;\n    },\n        addInternalIfNeeded = function addInternalIfNeeded(o, uid, enumerable) {\n      if (!hOP.call(o, internalSymbol)) {\n        defineProperty(o, internalSymbol, {\n          enumerable: false,\n          configurable: false,\n          writable: false,\n          value: {}\n        });\n      }\n      o[internalSymbol]['@@' + uid] = enumerable;\n    },\n        createWithSymbols = function createWithSymbols(proto, descriptors) {\n      var self = create(proto);\n      if (descriptors !== null && (typeof descriptors === 'undefined' ? 'undefined' : _typeof(descriptors)) === 'object') {\n        gOPN(descriptors).forEach(function (key) {\n          if (propertyIsEnumerable.call(descriptors, key)) {\n            $defineProperty(self, key, descriptors[key]);\n          }\n        });\n      }\n      return self;\n    },\n        copyAsNonEnumerable = function copyAsNonEnumerable(descriptor) {\n      var newDescriptor = create(descriptor);\n      newDescriptor.enumerable = false;\n      return newDescriptor;\n    },\n        get = function get() {},\n        onlyNonSymbols = function onlyNonSymbols(name) {\n      return name != internalSymbol && !hOP.call(source, name);\n    },\n        onlySymbols = function onlySymbols(name) {\n      return name != internalSymbol && hOP.call(source, name);\n    },\n        propertyIsEnumerable = function propertyIsEnumerable(key) {\n      var uid = '' + key;\n      return onlySymbols(uid) ? hOP.call(this, uid) && this[internalSymbol] && this[internalSymbol]['@@' + uid] : pIE.call(this, key);\n    },\n        setAndGetSymbol = function setAndGetSymbol(uid) {\n      var descriptor = {\n        enumerable: false,\n        configurable: true,\n        get: get,\n        set: function set(value) {\n          setDescriptor(this, uid, {\n            enumerable: false,\n            configurable: true,\n            writable: true,\n            value: value\n          });\n          addInternalIfNeeded(this, uid, true);\n        }\n      };\n      defineProperty(ObjectProto, uid, descriptor);\n      return source[uid] = defineProperty(Object(uid), 'constructor', sourceConstructor);\n    },\n        _Symbol = function _Symbol2(description) {\n      if (this && this !== G) {\n        throw new TypeError('Symbol is not a constructor');\n      }\n      return setAndGetSymbol(prefix.concat(description || '', random, ++id));\n    },\n        source = create(null),\n        sourceConstructor = { value: _Symbol },\n        sourceMap = function sourceMap(uid) {\n      return source[uid];\n    },\n        $defineProperty = function defineProp(o, key, descriptor) {\n      var uid = '' + key;\n      if (onlySymbols(uid)) {\n        setDescriptor(o, uid, descriptor.enumerable ? copyAsNonEnumerable(descriptor) : descriptor);\n        addInternalIfNeeded(o, uid, !!descriptor.enumerable);\n      } else {\n        defineProperty(o, key, descriptor);\n      }\n      return o;\n    },\n        $getOwnPropertySymbols = function getOwnPropertySymbols(o) {\n      var cof = toString.call(o);\n      o = cof === '[object String]' ? o.split('') : Object(o);\n      return gOPN(o).filter(onlySymbols).map(sourceMap);\n    };\n\n    descriptor.value = $defineProperty;\n    defineProperty(Object, DP, descriptor);\n\n    descriptor.value = $getOwnPropertySymbols;\n    defineProperty(Object, GOPS, descriptor);\n\n    var cachedWindowNames = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' ? Object.getOwnPropertyNames(window) : [];\n    var originalObjectGetOwnPropertyNames = Object.getOwnPropertyNames;\n    descriptor.value = function getOwnPropertyNames(o) {\n      if (toString.call(o) === '[object Window]') {\n        try {\n          return originalObjectGetOwnPropertyNames(o);\n        } catch (e) {\n          return [].concat([], cachedWindowNames);\n        }\n      }\n      return gOPN(o).filter(onlyNonSymbols);\n    };\n    defineProperty(Object, GOPN, descriptor);\n\n    descriptor.value = function defineProperties(o, descriptors) {\n      var symbols = $getOwnPropertySymbols(descriptors);\n      if (symbols.length) {\n        keys(descriptors).concat(symbols).forEach(function (uid) {\n          if (propertyIsEnumerable.call(descriptors, uid)) {\n            $defineProperty(o, uid, descriptors[uid]);\n          }\n        });\n      } else {\n        $defineProperties(o, descriptors);\n      }\n      return o;\n    };\n    defineProperty(Object, DPies, descriptor);\n\n    descriptor.value = propertyIsEnumerable;\n    defineProperty(ObjectProto, PIE, descriptor);\n\n    descriptor.value = _Symbol;\n    defineProperty(G, 'Symbol', descriptor);\n\n    descriptor.value = function (key) {\n      var uid = prefix.concat(prefix, key, random);\n      return uid in ObjectProto ? source[uid] : setAndGetSymbol(uid);\n    };\n    defineProperty(_Symbol, 'for', descriptor);\n\n    descriptor.value = function (symbol) {\n      return hOP.call(source, symbol) ? symbol.slice(prefixLength * 2, -random.length) : void 0;\n    };\n    defineProperty(_Symbol, 'keyFor', descriptor);\n\n    descriptor.value = function getOwnPropertyDescriptor(o, key) {\n      var descriptor = gOPD(o, key);\n      if (descriptor && onlySymbols(key)) {\n        descriptor.enumerable = propertyIsEnumerable.call(o, key);\n      }\n      return descriptor;\n    };\n    defineProperty(Object, GOPD, descriptor);\n\n    descriptor.value = function (proto, descriptors) {\n      return arguments.length === 1 ? create(proto) : createWithSymbols(proto, descriptors);\n    };\n    defineProperty(Object, 'create', descriptor);\n\n    descriptor.value = function () {\n      var str = toString.call(this);\n      return str === '[object String]' && onlySymbols(this) ? '[object Symbol]' : str;\n    };\n    defineProperty(ObjectProto, 'toString', descriptor);\n\n    try {\n      setDescriptor = create(defineProperty({}, prefix, {\n        get: function get() {\n          return defineProperty(this, prefix, { value: false })[prefix];\n        }\n      }))[prefix] || defineProperty;\n    } catch (o_O) {\n      setDescriptor = function setDescriptor(o, key, descriptor) {\n        var protoDescriptor = gOPD(ObjectProto, key);\n        delete ObjectProto[key];\n        defineProperty(o, key, descriptor);\n        defineProperty(ObjectProto, key, protoDescriptor);\n      };\n    }\n  })(Object, 'getOwnPropertySymbols');\n\n  (function (O, S) {\n    var dP = O.defineProperty,\n        ObjectProto = O.prototype,\n        toString = ObjectProto.toString,\n        toStringTag = 'toStringTag',\n        descriptor;\n    ['iterator', 'match', 'replace', 'search', 'split', 'hasInstance', 'isConcatSpreadable', 'unscopables', 'species', 'toPrimitive', toStringTag].forEach(function (name) {\n      if (!(name in Symbol)) {\n        dP(Symbol, name, { value: Symbol(name) });\n        switch (name) {\n          case toStringTag:\n            descriptor = O.getOwnPropertyDescriptor(ObjectProto, 'toString');\n            descriptor.value = function () {\n              var str = toString.call(this),\n                  tst = typeof this === 'undefined' || this === null ? undefined : this[Symbol.toStringTag];\n              return typeof tst === 'undefined' ? str : '[object ' + tst + ']';\n            };\n            dP(ObjectProto, 'toString', descriptor);\n            break;\n        }\n      }\n    });\n  })(Object, Symbol);\n\n  (function (Si, AP, SP) {\n\n    function returnThis() {\n      return this;\n    }\n\n    if (!AP[Si]) AP[Si] = function () {\n      var i = 0,\n          self = this,\n          iterator = {\n        next: function next() {\n          var done = self.length <= i;\n          return done ? { done: done } : { done: done, value: self[i++] };\n        }\n      };\n      iterator[Si] = returnThis;\n      return iterator;\n    };\n\n    if (!SP[Si]) SP[Si] = function () {\n      var fromCodePoint = String.fromCodePoint,\n          self = this,\n          i = 0,\n          length = self.length,\n          iterator = {\n        next: function next() {\n          var done = length <= i,\n              c = done ? '' : fromCodePoint(self.codePointAt(i));\n          i += c.length;\n          return done ? { done: done } : { done: done, value: c };\n        }\n      };\n      iterator[Si] = returnThis;\n      return iterator;\n    };\n  })(Symbol.iterator, Array.prototype, String.prototype);\n}\n\nif (typeof FEATURE_NO_ES2015 === 'undefined') {\n\n  Number.isNaN = Number.isNaN || function (value) {\n    return value !== value;\n  };\n\n  Number.isFinite = Number.isFinite || function (value) {\n    return typeof value === \"number\" && isFinite(value);\n  };\n}\n\nif (!String.prototype.endsWith || function () {\n  try {\n    return !\"ab\".endsWith(\"a\", 1);\n  } catch (e) {\n    return true;\n  }\n}()) {\n  String.prototype.endsWith = function (searchString, position) {\n    var subjectString = this.toString();\n    if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\n      position = subjectString.length;\n    }\n    position -= searchString.length;\n    var lastIndex = subjectString.indexOf(searchString, position);\n    return lastIndex !== -1 && lastIndex === position;\n  };\n}\n\nif (!String.prototype.startsWith || function () {\n  try {\n    return !\"ab\".startsWith(\"b\", 1);\n  } catch (e) {\n    return true;\n  }\n}()) {\n  String.prototype.startsWith = function (searchString, position) {\n    position = position || 0;\n    return this.substr(position, searchString.length) === searchString;\n  };\n}\n\nif (typeof FEATURE_NO_ES2015 === 'undefined') {\n\n  if (!Array.from) {\n    Array.from = function () {\n      var toInteger = function toInteger(it) {\n        return isNaN(it = +it) ? 0 : (it > 0 ? Math.floor : Math.ceil)(it);\n      };\n      var toLength = function toLength(it) {\n        return it > 0 ? Math.min(toInteger(it), 0x1fffffffffffff) : 0;\n      };\n      var iterCall = function iterCall(iter, fn, val, index) {\n        try {\n          return fn(val, index);\n        } catch (E) {\n          if (typeof iter.return == 'function') iter.return();\n          throw E;\n        }\n      };\n\n      return function from(arrayLike) {\n        var O = Object(arrayLike),\n            C = typeof this == 'function' ? this : Array,\n            aLen = arguments.length,\n            mapfn = aLen > 1 ? arguments[1] : undefined,\n            mapping = mapfn !== undefined,\n            index = 0,\n            iterFn = O[Symbol.iterator],\n            length,\n            result,\n            step,\n            iterator;\n        if (mapping) mapfn = mapfn.bind(aLen > 2 ? arguments[2] : undefined);\n        if (iterFn != undefined && !Array.isArray(arrayLike)) {\n          for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {\n            result[index] = mapping ? iterCall(iterator, mapfn, step.value, index) : step.value;\n          }\n        } else {\n          length = toLength(O.length);\n          for (result = new C(length); length > index; index++) {\n            result[index] = mapping ? mapfn(O[index], index) : O[index];\n          }\n        }\n        result.length = index;\n        return result;\n      };\n    }();\n  }\n\n  if (!Array.prototype.find) {\n    Object.defineProperty(Array.prototype, 'find', {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: function value(predicate) {\n        if (this === null) {\n          throw new TypeError('Array.prototype.find called on null or undefined');\n        }\n        if (typeof predicate !== 'function') {\n          throw new TypeError('predicate must be a function');\n        }\n        var list = Object(this);\n        var length = list.length >>> 0;\n        var thisArg = arguments[1];\n        var value;\n\n        for (var i = 0; i < length; i++) {\n          value = list[i];\n          if (predicate.call(thisArg, value, i, list)) {\n            return value;\n          }\n        }\n        return undefined;\n      }\n    });\n  }\n\n  if (!Array.prototype.findIndex) {\n    Object.defineProperty(Array.prototype, 'findIndex', {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: function value(predicate) {\n        if (this === null) {\n          throw new TypeError('Array.prototype.findIndex called on null or undefined');\n        }\n        if (typeof predicate !== 'function') {\n          throw new TypeError('predicate must be a function');\n        }\n        var list = Object(this);\n        var length = list.length >>> 0;\n        var thisArg = arguments[1];\n        var value;\n\n        for (var i = 0; i < length; i++) {\n          value = list[i];\n          if (predicate.call(thisArg, value, i, list)) {\n            return i;\n          }\n        }\n        return -1;\n      }\n    });\n  }\n}\n\nif (typeof FEATURE_NO_ES2016 === 'undefined' && !Array.prototype.includes) {\n  Object.defineProperty(Array.prototype, 'includes', {\n    configurable: true,\n    writable: true,\n    enumerable: false,\n    value: function value(searchElement) {\n      var O = Object(this);\n      var len = parseInt(O.length) || 0;\n      if (len === 0) {\n        return false;\n      }\n      var n = parseInt(arguments[1]) || 0;\n      var k;\n      if (n >= 0) {\n        k = n;\n      } else {\n        k = len + n;\n        if (k < 0) {\n          k = 0;\n        }\n      }\n      var currentElement;\n      while (k < len) {\n        currentElement = O[k];\n        if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {\n          return true;\n        }\n        k++;\n      }\n      return false;\n    }\n  });\n}\n\nif (typeof FEATURE_NO_ES2015 === 'undefined') {\n\n  (function () {\n    var needsFix = false;\n\n    try {\n      var s = Object.keys('a');\n      needsFix = s.length !== 1 || s[0] !== '0';\n    } catch (e) {\n      needsFix = true;\n    }\n\n    if (needsFix) {\n      Object.keys = function () {\n        var hasOwnProperty = Object.prototype.hasOwnProperty,\n            hasDontEnumBug = !{ toString: null }.propertyIsEnumerable('toString'),\n            dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],\n            dontEnumsLength = dontEnums.length;\n\n        return function (obj) {\n          if (obj === undefined || obj === null) {\n            throw TypeError('Cannot convert undefined or null to object');\n          }\n\n          obj = Object(obj);\n\n          var result = [],\n              prop,\n              i;\n\n          for (prop in obj) {\n            if (hasOwnProperty.call(obj, prop)) {\n              result.push(prop);\n            }\n          }\n\n          if (hasDontEnumBug) {\n            for (i = 0; i < dontEnumsLength; i++) {\n              if (hasOwnProperty.call(obj, dontEnums[i])) {\n                result.push(dontEnums[i]);\n              }\n            }\n          }\n\n          return result;\n        };\n      }();\n    }\n  })();\n\n  (function (O) {\n    if ('assign' in O) {\n      return;\n    }\n\n    O.defineProperty(O, 'assign', {\n      configurable: true,\n      writable: true,\n      value: function () {\n        var gOPS = O.getOwnPropertySymbols,\n            pIE = O.propertyIsEnumerable,\n            filterOS = gOPS ? function (self) {\n          return gOPS(self).filter(pIE, self);\n        } : function () {\n          return Array.prototype;\n        };\n\n        return function assign(where) {\n          if (gOPS && !(where instanceof O)) {\n            console.warn('problematic Symbols', where);\n          }\n\n          function set(keyOrSymbol) {\n            where[keyOrSymbol] = arg[keyOrSymbol];\n          }\n\n          for (var i = 1, ii = arguments.length; i < ii; ++i) {\n            var arg = arguments[i];\n\n            if (arg === null || arg === undefined) {\n              continue;\n            }\n\n            O.keys(arg).concat(filterOS(arg)).forEach(set);\n          }\n\n          return where;\n        };\n      }()\n    });\n  })(Object);\n\n  if (!Object.is) {\n    Object.is = function (x, y) {\n      if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n      } else {\n        return x !== x && y !== y;\n      }\n    };\n  }\n}\n\nif (typeof FEATURE_NO_ES2015 === 'undefined') {\n\n  (function (global) {\n    var i;\n\n    var defineProperty = Object.defineProperty,\n        is = function is(a, b) {\n      return a === b || a !== a && b !== b;\n    };\n\n    if (typeof WeakMap == 'undefined') {\n      global.WeakMap = createCollection({\n        'delete': sharedDelete,\n\n        clear: sharedClear,\n\n        get: sharedGet,\n\n        has: mapHas,\n\n        set: sharedSet\n      }, true);\n    }\n\n    if (typeof Map == 'undefined' || typeof new Map().values !== 'function' || !new Map().values().next) {\n      var _createCollection;\n\n      global.Map = createCollection((_createCollection = {\n        'delete': sharedDelete,\n\n        has: mapHas,\n\n        get: sharedGet,\n\n        set: sharedSet,\n\n        keys: sharedKeys,\n\n        values: sharedValues,\n\n        entries: mapEntries,\n\n        forEach: sharedForEach,\n\n        clear: sharedClear\n      }, _createCollection[Symbol.iterator] = mapEntries, _createCollection));\n    }\n\n    if (typeof Set == 'undefined' || typeof new Set().values !== 'function' || !new Set().values().next) {\n      var _createCollection2;\n\n      global.Set = createCollection((_createCollection2 = {\n        has: setHas,\n\n        add: sharedAdd,\n\n        'delete': sharedDelete,\n\n        clear: sharedClear,\n\n        keys: sharedValues,\n        values: sharedValues,\n\n        entries: setEntries,\n\n        forEach: sharedForEach\n      }, _createCollection2[Symbol.iterator] = sharedValues, _createCollection2));\n    }\n\n    if (typeof WeakSet == 'undefined') {\n      global.WeakSet = createCollection({\n        'delete': sharedDelete,\n\n        add: sharedAdd,\n\n        clear: sharedClear,\n\n        has: setHas\n      }, true);\n    }\n\n    function createCollection(proto, objectOnly) {\n      function Collection(a) {\n        if (!this || this.constructor !== Collection) return new Collection(a);\n        this._keys = [];\n        this._values = [];\n        this._itp = [];\n        this.objectOnly = objectOnly;\n\n        if (a) init.call(this, a);\n      }\n\n      if (!objectOnly) {\n        defineProperty(proto, 'size', {\n          get: sharedSize\n        });\n      }\n\n      proto.constructor = Collection;\n      Collection.prototype = proto;\n\n      return Collection;\n    }\n\n    function init(a) {\n      var i;\n\n      if (this.add) a.forEach(this.add, this);else a.forEach(function (a) {\n          this.set(a[0], a[1]);\n        }, this);\n    }\n\n    function sharedDelete(key) {\n      if (this.has(key)) {\n        this._keys.splice(i, 1);\n        this._values.splice(i, 1);\n\n        this._itp.forEach(function (p) {\n          if (i < p[0]) p[0]--;\n        });\n      }\n\n      return -1 < i;\n    };\n\n    function sharedGet(key) {\n      return this.has(key) ? this._values[i] : undefined;\n    }\n\n    function has(list, key) {\n      if (this.objectOnly && key !== Object(key)) throw new TypeError(\"Invalid value used as weak collection key\");\n\n      if (key != key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} else i = list.indexOf(key);\n      return -1 < i;\n    }\n\n    function setHas(value) {\n      return has.call(this, this._values, value);\n    }\n\n    function mapHas(value) {\n      return has.call(this, this._keys, value);\n    }\n\n    function sharedSet(key, value) {\n      this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;\n      return this;\n    }\n\n    function sharedAdd(value) {\n      if (!this.has(value)) this._values.push(value);\n      return this;\n    }\n\n    function sharedClear() {\n      (this._keys || 0).length = this._values.length = 0;\n    }\n\n    function sharedKeys() {\n      return sharedIterator(this._itp, this._keys);\n    }\n\n    function sharedValues() {\n      return sharedIterator(this._itp, this._values);\n    }\n\n    function mapEntries() {\n      return sharedIterator(this._itp, this._keys, this._values);\n    }\n\n    function setEntries() {\n      return sharedIterator(this._itp, this._values, this._values);\n    }\n\n    function sharedIterator(itp, array, array2) {\n      var _ref;\n\n      var p = [0],\n          done = false;\n      itp.push(p);\n      return _ref = {}, _ref[Symbol.iterator] = function () {\n        return this;\n      }, _ref.next = function next() {\n        var v,\n            k = p[0];\n        if (!done && k < array.length) {\n          v = array2 ? [array[k], array2[k]] : array[k];\n          p[0]++;\n        } else {\n          done = true;\n          itp.splice(itp.indexOf(p), 1);\n        }\n        return { done: done, value: v };\n      }, _ref;\n    }\n\n    function sharedSize() {\n      return this._values.length;\n    }\n\n    function sharedForEach(callback, context) {\n      var it = this.entries();\n      for (;;) {\n        var r = it.next();\n        if (r.done) break;\n        callback.call(context, r.value[1], r.value[0], this);\n      }\n    }\n  })(aurelia_pal__WEBPACK_IMPORTED_MODULE_0__[\"PLATFORM\"].global);\n}\n\nif (typeof FEATURE_NO_ES2015 === 'undefined') {\n  (function () {\n\n    var bind = Function.prototype.bind;\n\n    if (typeof aurelia_pal__WEBPACK_IMPORTED_MODULE_0__[\"PLATFORM\"].global.Reflect === 'undefined') {\n      aurelia_pal__WEBPACK_IMPORTED_MODULE_0__[\"PLATFORM\"].global.Reflect = {};\n    }\n\n    if (typeof Reflect.defineProperty !== 'function') {\n      Reflect.defineProperty = function (target, propertyKey, descriptor) {\n        if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' ? target === null : typeof target !== 'function') {\n          throw new TypeError('Reflect.defineProperty called on non-object');\n        }\n        try {\n          Object.defineProperty(target, propertyKey, descriptor);\n          return true;\n        } catch (e) {\n          return false;\n        }\n      };\n    }\n\n    if (typeof Reflect.construct !== 'function') {\n      Reflect.construct = function (Target, args) {\n        if (args) {\n          switch (args.length) {\n            case 0:\n              return new Target();\n            case 1:\n              return new Target(args[0]);\n            case 2:\n              return new Target(args[0], args[1]);\n            case 3:\n              return new Target(args[0], args[1], args[2]);\n            case 4:\n              return new Target(args[0], args[1], args[2], args[3]);\n          }\n        }\n\n        var a = [null];\n        a.push.apply(a, args);\n        return new (bind.apply(Target, a))();\n      };\n    }\n\n    if (typeof Reflect.ownKeys !== 'function') {\n      Reflect.ownKeys = function (o) {\n        return Object.getOwnPropertyNames(o).concat(Object.getOwnPropertySymbols(o));\n      };\n    }\n  })();\n}\n\nif (typeof FEATURE_NO_ESNEXT === 'undefined') {\n  (function () {\n\n    var emptyMetadata = Object.freeze({});\n    var metadataContainerKey = '__metadata__';\n\n    if (typeof Reflect.getOwnMetadata !== 'function') {\n      Reflect.getOwnMetadata = function (metadataKey, target, targetKey) {\n        if (target.hasOwnProperty(metadataContainerKey)) {\n          return (target[metadataContainerKey][targetKey] || emptyMetadata)[metadataKey];\n        }\n      };\n    }\n\n    if (typeof Reflect.defineMetadata !== 'function') {\n      Reflect.defineMetadata = function (metadataKey, metadataValue, target, targetKey) {\n        var metadataContainer = target.hasOwnProperty(metadataContainerKey) ? target[metadataContainerKey] : target[metadataContainerKey] = {};\n        var targetContainer = metadataContainer[targetKey] || (metadataContainer[targetKey] = {});\n        targetContainer[metadataKey] = metadataValue;\n      };\n    }\n\n    if (typeof Reflect.metadata !== 'function') {\n      Reflect.metadata = function (metadataKey, metadataValue) {\n        return function (target, targetKey) {\n          Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);\n        };\n      };\n    }\n  })();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUS81cC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLXBvbHlmaWxscy9kaXN0L25hdGl2ZS1tb2R1bGVzL2F1cmVsaWEtcG9seWZpbGxzLmpzPzQzZmUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmltcG9ydCB7IFBMQVRGT1JNIH0gZnJvbSAnYXVyZWxpYS1wYWwnO1xuXG5pZiAodHlwZW9mIEZFQVRVUkVfTk9fRVMyMDE1ID09PSAndW5kZWZpbmVkJykge1xuXG4gIChmdW5jdGlvbiAoT2JqZWN0LCBHT1BTKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKEdPUFMgaW4gT2JqZWN0KSByZXR1cm47XG5cbiAgICB2YXIgc2V0RGVzY3JpcHRvcixcbiAgICAgICAgRyA9IFBMQVRGT1JNLmdsb2JhbCxcbiAgICAgICAgaWQgPSAwLFxuICAgICAgICByYW5kb20gPSAnJyArIE1hdGgucmFuZG9tKCksXG4gICAgICAgIHByZWZpeCA9ICdfX1xceDAxc3ltYm9sOicsXG4gICAgICAgIHByZWZpeExlbmd0aCA9IHByZWZpeC5sZW5ndGgsXG4gICAgICAgIGludGVybmFsU3ltYm9sID0gJ19fXFx4MDFzeW1ib2xAQCcgKyByYW5kb20sXG4gICAgICAgIERQID0gJ2RlZmluZVByb3BlcnR5JyxcbiAgICAgICAgRFBpZXMgPSAnZGVmaW5lUHJvcGVydGllcycsXG4gICAgICAgIEdPUE4gPSAnZ2V0T3duUHJvcGVydHlOYW1lcycsXG4gICAgICAgIEdPUEQgPSAnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJyxcbiAgICAgICAgUElFID0gJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgICAgICAgZ09QTiA9IE9iamVjdFtHT1BOXSxcbiAgICAgICAgZ09QRCA9IE9iamVjdFtHT1BEXSxcbiAgICAgICAgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSxcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzLFxuICAgICAgICBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdFtEUF0sXG4gICAgICAgICRkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0W0RQaWVzXSxcbiAgICAgICAgZGVzY3JpcHRvciA9IGdPUEQoT2JqZWN0LCBHT1BOKSxcbiAgICAgICAgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBoT1AgPSBPYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgcElFID0gT2JqZWN0UHJvdG9bUElFXSxcbiAgICAgICAgdG9TdHJpbmcgPSBPYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mIHx8IGZ1bmN0aW9uICh2KSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGg7IGktLSAmJiB0aGlzW2ldICE9PSB2Oykge31cbiAgICAgIHJldHVybiBpO1xuICAgIH0sXG4gICAgICAgIGFkZEludGVybmFsSWZOZWVkZWQgPSBmdW5jdGlvbiBhZGRJbnRlcm5hbElmTmVlZGVkKG8sIHVpZCwgZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoT1AuY2FsbChvLCBpbnRlcm5hbFN5bWJvbCkpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkobywgaW50ZXJuYWxTeW1ib2wsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBvW2ludGVybmFsU3ltYm9sXVsnQEAnICsgdWlkXSA9IGVudW1lcmFibGU7XG4gICAgfSxcbiAgICAgICAgY3JlYXRlV2l0aFN5bWJvbHMgPSBmdW5jdGlvbiBjcmVhdGVXaXRoU3ltYm9scyhwcm90bywgZGVzY3JpcHRvcnMpIHtcbiAgICAgIHZhciBzZWxmID0gY3JlYXRlKHByb3RvKTtcbiAgICAgIGlmIChkZXNjcmlwdG9ycyAhPT0gbnVsbCAmJiAodHlwZW9mIGRlc2NyaXB0b3JzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihkZXNjcmlwdG9ycykpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBnT1BOKGRlc2NyaXB0b3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBpZiAocHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChkZXNjcmlwdG9ycywga2V5KSkge1xuICAgICAgICAgICAgJGRlZmluZVByb3BlcnR5KHNlbGYsIGtleSwgZGVzY3JpcHRvcnNba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG4gICAgICAgIGNvcHlBc05vbkVudW1lcmFibGUgPSBmdW5jdGlvbiBjb3B5QXNOb25FbnVtZXJhYmxlKGRlc2NyaXB0b3IpIHtcbiAgICAgIHZhciBuZXdEZXNjcmlwdG9yID0gY3JlYXRlKGRlc2NyaXB0b3IpO1xuICAgICAgbmV3RGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZmFsc2U7XG4gICAgICByZXR1cm4gbmV3RGVzY3JpcHRvcjtcbiAgICB9LFxuICAgICAgICBnZXQgPSBmdW5jdGlvbiBnZXQoKSB7fSxcbiAgICAgICAgb25seU5vblN5bWJvbHMgPSBmdW5jdGlvbiBvbmx5Tm9uU3ltYm9scyhuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZSAhPSBpbnRlcm5hbFN5bWJvbCAmJiAhaE9QLmNhbGwoc291cmNlLCBuYW1lKTtcbiAgICB9LFxuICAgICAgICBvbmx5U3ltYm9scyA9IGZ1bmN0aW9uIG9ubHlTeW1ib2xzKG5hbWUpIHtcbiAgICAgIHJldHVybiBuYW1lICE9IGludGVybmFsU3ltYm9sICYmIGhPUC5jYWxsKHNvdXJjZSwgbmFtZSk7XG4gICAgfSxcbiAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgICAgIHZhciB1aWQgPSAnJyArIGtleTtcbiAgICAgIHJldHVybiBvbmx5U3ltYm9scyh1aWQpID8gaE9QLmNhbGwodGhpcywgdWlkKSAmJiB0aGlzW2ludGVybmFsU3ltYm9sXSAmJiB0aGlzW2ludGVybmFsU3ltYm9sXVsnQEAnICsgdWlkXSA6IHBJRS5jYWxsKHRoaXMsIGtleSk7XG4gICAgfSxcbiAgICAgICAgc2V0QW5kR2V0U3ltYm9sID0gZnVuY3Rpb24gc2V0QW5kR2V0U3ltYm9sKHVpZCkge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZ2V0LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHNldERlc2NyaXB0b3IodGhpcywgdWlkLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWRkSW50ZXJuYWxJZk5lZWRlZCh0aGlzLCB1aWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG8sIHVpZCwgZGVzY3JpcHRvcik7XG4gICAgICByZXR1cm4gc291cmNlW3VpZF0gPSBkZWZpbmVQcm9wZXJ0eShPYmplY3QodWlkKSwgJ2NvbnN0cnVjdG9yJywgc291cmNlQ29uc3RydWN0b3IpO1xuICAgIH0sXG4gICAgICAgIF9TeW1ib2wgPSBmdW5jdGlvbiBfU3ltYm9sMihkZXNjcmlwdGlvbikge1xuICAgICAgaWYgKHRoaXMgJiYgdGhpcyAhPT0gRykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRBbmRHZXRTeW1ib2wocHJlZml4LmNvbmNhdChkZXNjcmlwdGlvbiB8fCAnJywgcmFuZG9tLCArK2lkKSk7XG4gICAgfSxcbiAgICAgICAgc291cmNlID0gY3JlYXRlKG51bGwpLFxuICAgICAgICBzb3VyY2VDb25zdHJ1Y3RvciA9IHsgdmFsdWU6IF9TeW1ib2wgfSxcbiAgICAgICAgc291cmNlTWFwID0gZnVuY3Rpb24gc291cmNlTWFwKHVpZCkge1xuICAgICAgcmV0dXJuIHNvdXJjZVt1aWRdO1xuICAgIH0sXG4gICAgICAgICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3Aobywga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgICB2YXIgdWlkID0gJycgKyBrZXk7XG4gICAgICBpZiAob25seVN5bWJvbHModWlkKSkge1xuICAgICAgICBzZXREZXNjcmlwdG9yKG8sIHVpZCwgZGVzY3JpcHRvci5lbnVtZXJhYmxlID8gY29weUFzTm9uRW51bWVyYWJsZShkZXNjcmlwdG9yKSA6IGRlc2NyaXB0b3IpO1xuICAgICAgICBhZGRJbnRlcm5hbElmTmVlZGVkKG8sIHVpZCwgISFkZXNjcmlwdG9yLmVudW1lcmFibGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkobywga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvO1xuICAgIH0sXG4gICAgICAgICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMobykge1xuICAgICAgdmFyIGNvZiA9IHRvU3RyaW5nLmNhbGwobyk7XG4gICAgICBvID0gY29mID09PSAnW29iamVjdCBTdHJpbmddJyA/IG8uc3BsaXQoJycpIDogT2JqZWN0KG8pO1xuICAgICAgcmV0dXJuIGdPUE4obykuZmlsdGVyKG9ubHlTeW1ib2xzKS5tYXAoc291cmNlTWFwKTtcbiAgICB9O1xuXG4gICAgZGVzY3JpcHRvci52YWx1ZSA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgICBkZWZpbmVQcm9wZXJ0eShPYmplY3QsIERQLCBkZXNjcmlwdG9yKTtcblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuICAgIGRlZmluZVByb3BlcnR5KE9iamVjdCwgR09QUywgZGVzY3JpcHRvcik7XG5cbiAgICB2YXIgY2FjaGVkV2luZG93TmFtZXMgPSAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yod2luZG93KSkgPT09ICdvYmplY3QnID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuICAgIHZhciBvcmlnaW5hbE9iamVjdEdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhvKSB7XG4gICAgICBpZiAodG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgV2luZG93XScpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWxPYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzKG8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChbXSwgY2FjaGVkV2luZG93TmFtZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZ09QTihvKS5maWx0ZXIob25seU5vblN5bWJvbHMpO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydHkoT2JqZWN0LCBHT1BOLCBkZXNjcmlwdG9yKTtcblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKG8sIGRlc2NyaXB0b3JzKSB7XG4gICAgICB2YXIgc3ltYm9scyA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZGVzY3JpcHRvcnMpO1xuICAgICAgaWYgKHN5bWJvbHMubGVuZ3RoKSB7XG4gICAgICAgIGtleXMoZGVzY3JpcHRvcnMpLmNvbmNhdChzeW1ib2xzKS5mb3JFYWNoKGZ1bmN0aW9uICh1aWQpIHtcbiAgICAgICAgICBpZiAocHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChkZXNjcmlwdG9ycywgdWlkKSkge1xuICAgICAgICAgICAgJGRlZmluZVByb3BlcnR5KG8sIHVpZCwgZGVzY3JpcHRvcnNbdWlkXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRkZWZpbmVQcm9wZXJ0aWVzKG8sIGRlc2NyaXB0b3JzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydHkoT2JqZWN0LCBEUGllcywgZGVzY3JpcHRvcik7XG5cbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gcHJvcGVydHlJc0VudW1lcmFibGU7XG4gICAgZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG8sIFBJRSwgZGVzY3JpcHRvcik7XG5cbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gX1N5bWJvbDtcbiAgICBkZWZpbmVQcm9wZXJ0eShHLCAnU3ltYm9sJywgZGVzY3JpcHRvcik7XG5cbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIHVpZCA9IHByZWZpeC5jb25jYXQocHJlZml4LCBrZXksIHJhbmRvbSk7XG4gICAgICByZXR1cm4gdWlkIGluIE9iamVjdFByb3RvID8gc291cmNlW3VpZF0gOiBzZXRBbmRHZXRTeW1ib2wodWlkKTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnR5KF9TeW1ib2wsICdmb3InLCBkZXNjcmlwdG9yKTtcblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoc3ltYm9sKSB7XG4gICAgICByZXR1cm4gaE9QLmNhbGwoc291cmNlLCBzeW1ib2wpID8gc3ltYm9sLnNsaWNlKHByZWZpeExlbmd0aCAqIDIsIC1yYW5kb20ubGVuZ3RoKSA6IHZvaWQgMDtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnR5KF9TeW1ib2wsICdrZXlGb3InLCBkZXNjcmlwdG9yKTtcblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobywga2V5KSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IGdPUEQobywga2V5KTtcbiAgICAgIGlmIChkZXNjcmlwdG9yICYmIG9ubHlTeW1ib2xzKGtleSkpIHtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvLCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0eShPYmplY3QsIEdPUEQsIGRlc2NyaXB0b3IpO1xuXG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uIChwcm90bywgZGVzY3JpcHRvcnMpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gY3JlYXRlKHByb3RvKSA6IGNyZWF0ZVdpdGhTeW1ib2xzKHByb3RvLCBkZXNjcmlwdG9ycyk7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0eShPYmplY3QsICdjcmVhdGUnLCBkZXNjcmlwdG9yKTtcblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RyID0gdG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiBzdHIgPT09ICdbb2JqZWN0IFN0cmluZ10nICYmIG9ubHlTeW1ib2xzKHRoaXMpID8gJ1tvYmplY3QgU3ltYm9sXScgOiBzdHI7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0eShPYmplY3RQcm90bywgJ3RvU3RyaW5nJywgZGVzY3JpcHRvcik7XG5cbiAgICB0cnkge1xuICAgICAgc2V0RGVzY3JpcHRvciA9IGNyZWF0ZShkZWZpbmVQcm9wZXJ0eSh7fSwgcHJlZml4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcmVmaXgsIHsgdmFsdWU6IGZhbHNlIH0pW3ByZWZpeF07XG4gICAgICAgIH1cbiAgICAgIH0pKVtwcmVmaXhdIHx8IGRlZmluZVByb3BlcnR5O1xuICAgIH0gY2F0Y2ggKG9fTykge1xuICAgICAgc2V0RGVzY3JpcHRvciA9IGZ1bmN0aW9uIHNldERlc2NyaXB0b3Iobywga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgICAgIHZhciBwcm90b0Rlc2NyaXB0b3IgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICAgICAgICBkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkobywga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjcmlwdG9yKTtcbiAgICAgIH07XG4gICAgfVxuICB9KShPYmplY3QsICdnZXRPd25Qcm9wZXJ0eVN5bWJvbHMnKTtcblxuICAoZnVuY3Rpb24gKE8sIFMpIHtcbiAgICB2YXIgZFAgPSBPLmRlZmluZVByb3BlcnR5LFxuICAgICAgICBPYmplY3RQcm90byA9IE8ucHJvdG90eXBlLFxuICAgICAgICB0b1N0cmluZyA9IE9iamVjdFByb3RvLnRvU3RyaW5nLFxuICAgICAgICB0b1N0cmluZ1RhZyA9ICd0b1N0cmluZ1RhZycsXG4gICAgICAgIGRlc2NyaXB0b3I7XG4gICAgWydpdGVyYXRvcicsICdtYXRjaCcsICdyZXBsYWNlJywgJ3NlYXJjaCcsICdzcGxpdCcsICdoYXNJbnN0YW5jZScsICdpc0NvbmNhdFNwcmVhZGFibGUnLCAndW5zY29wYWJsZXMnLCAnc3BlY2llcycsICd0b1ByaW1pdGl2ZScsIHRvU3RyaW5nVGFnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAoIShuYW1lIGluIFN5bWJvbCkpIHtcbiAgICAgICAgZFAoU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiBTeW1ib2wobmFtZSkgfSk7XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgIGNhc2UgdG9TdHJpbmdUYWc6XG4gICAgICAgICAgICBkZXNjcmlwdG9yID0gTy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0UHJvdG8sICd0b1N0cmluZycpO1xuICAgICAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHN0ciA9IHRvU3RyaW5nLmNhbGwodGhpcyksXG4gICAgICAgICAgICAgICAgICB0c3QgPSB0eXBlb2YgdGhpcyA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcyA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRoaXNbU3ltYm9sLnRvU3RyaW5nVGFnXTtcbiAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0c3QgPT09ICd1bmRlZmluZWQnID8gc3RyIDogJ1tvYmplY3QgJyArIHRzdCArICddJztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkUChPYmplY3RQcm90bywgJ3RvU3RyaW5nJywgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KShPYmplY3QsIFN5bWJvbCk7XG5cbiAgKGZ1bmN0aW9uIChTaSwgQVAsIFNQKSB7XG5cbiAgICBmdW5jdGlvbiByZXR1cm5UaGlzKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCFBUFtTaV0pIEFQW1NpXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICBpdGVyYXRvciA9IHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB2YXIgZG9uZSA9IHNlbGYubGVuZ3RoIDw9IGk7XG4gICAgICAgICAgcmV0dXJuIGRvbmUgPyB7IGRvbmU6IGRvbmUgfSA6IHsgZG9uZTogZG9uZSwgdmFsdWU6IHNlbGZbaSsrXSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaXRlcmF0b3JbU2ldID0gcmV0dXJuVGhpcztcbiAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9O1xuXG4gICAgaWYgKCFTUFtTaV0pIFNQW1NpXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQsXG4gICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGgsXG4gICAgICAgICAgaXRlcmF0b3IgPSB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgdmFyIGRvbmUgPSBsZW5ndGggPD0gaSxcbiAgICAgICAgICAgICAgYyA9IGRvbmUgPyAnJyA6IGZyb21Db2RlUG9pbnQoc2VsZi5jb2RlUG9pbnRBdChpKSk7XG4gICAgICAgICAgaSArPSBjLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gZG9uZSA/IHsgZG9uZTogZG9uZSB9IDogeyBkb25lOiBkb25lLCB2YWx1ZTogYyB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaXRlcmF0b3JbU2ldID0gcmV0dXJuVGhpcztcbiAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9O1xuICB9KShTeW1ib2wuaXRlcmF0b3IsIEFycmF5LnByb3RvdHlwZSwgU3RyaW5nLnByb3RvdHlwZSk7XG59XG5cbmlmICh0eXBlb2YgRkVBVFVSRV9OT19FUzIwMTUgPT09ICd1bmRlZmluZWQnKSB7XG5cbiAgTnVtYmVyLmlzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG4gIH07XG5cbiAgTnVtYmVyLmlzRmluaXRlID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsdWUpO1xuICB9O1xufVxuXG5pZiAoIVN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGggfHwgZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHJldHVybiAhXCJhYlwiLmVuZHNXaXRoKFwiYVwiLCAxKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59KCkpIHtcbiAgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aCA9IGZ1bmN0aW9uIChzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgdmFyIHN1YmplY3RTdHJpbmcgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicgfHwgIWlzRmluaXRlKHBvc2l0aW9uKSB8fCBNYXRoLmZsb29yKHBvc2l0aW9uKSAhPT0gcG9zaXRpb24gfHwgcG9zaXRpb24gPiBzdWJqZWN0U3RyaW5nLmxlbmd0aCkge1xuICAgICAgcG9zaXRpb24gPSBzdWJqZWN0U3RyaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgcG9zaXRpb24gLT0gc2VhcmNoU3RyaW5nLmxlbmd0aDtcbiAgICB2YXIgbGFzdEluZGV4ID0gc3ViamVjdFN0cmluZy5pbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pO1xuICAgIHJldHVybiBsYXN0SW5kZXggIT09IC0xICYmIGxhc3RJbmRleCA9PT0gcG9zaXRpb247XG4gIH07XG59XG5cbmlmICghU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoIHx8IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gIVwiYWJcIi5zdGFydHNXaXRoKFwiYlwiLCAxKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59KCkpIHtcbiAgU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoID0gZnVuY3Rpb24gKHNlYXJjaFN0cmluZywgcG9zaXRpb24pIHtcbiAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIHx8IDA7XG4gICAgcmV0dXJuIHRoaXMuc3Vic3RyKHBvc2l0aW9uLCBzZWFyY2hTdHJpbmcubGVuZ3RoKSA9PT0gc2VhcmNoU3RyaW5nO1xuICB9O1xufVxuXG5pZiAodHlwZW9mIEZFQVRVUkVfTk9fRVMyMDE1ID09PSAndW5kZWZpbmVkJykge1xuXG4gIGlmICghQXJyYXkuZnJvbSkge1xuICAgIEFycmF5LmZyb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdG9JbnRlZ2VyID0gZnVuY3Rpb24gdG9JbnRlZ2VyKGl0KSB7XG4gICAgICAgIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IE1hdGguZmxvb3IgOiBNYXRoLmNlaWwpKGl0KTtcbiAgICAgIH07XG4gICAgICB2YXIgdG9MZW5ndGggPSBmdW5jdGlvbiB0b0xlbmd0aChpdCkge1xuICAgICAgICByZXR1cm4gaXQgPiAwID8gTWF0aC5taW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwO1xuICAgICAgfTtcbiAgICAgIHZhciBpdGVyQ2FsbCA9IGZ1bmN0aW9uIGl0ZXJDYWxsKGl0ZXIsIGZuLCB2YWwsIGluZGV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGZuKHZhbCwgaW5kZXgpO1xuICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpdGVyLnJldHVybiA9PSAnZnVuY3Rpb24nKSBpdGVyLnJldHVybigpO1xuICAgICAgICAgIHRocm93IEU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZSkge1xuICAgICAgICB2YXIgTyA9IE9iamVjdChhcnJheUxpa2UpLFxuICAgICAgICAgICAgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXksXG4gICAgICAgICAgICBhTGVuID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIG1hcGZuID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgIGl0ZXJGbiA9IE9bU3ltYm9sLml0ZXJhdG9yXSxcbiAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgIHN0ZXAsXG4gICAgICAgICAgICBpdGVyYXRvcjtcbiAgICAgICAgaWYgKG1hcHBpbmcpIG1hcGZuID0gbWFwZm4uYmluZChhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICFBcnJheS5pc0FycmF5KGFycmF5TGlrZSkpIHtcbiAgICAgICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDKCk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IG1hcHBpbmcgPyBpdGVyQ2FsbChpdGVyYXRvciwgbWFwZm4sIHN0ZXAudmFsdWUsIGluZGV4KSA6IHN0ZXAudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgICAgICBmb3IgKHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KCk7XG4gIH1cblxuICBpZiAoIUFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSwgJ2ZpbmQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHByZWRpY2F0ZSkge1xuICAgICAgICBpZiAodGhpcyA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5maW5kIGNhbGxlZCBvbiBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJlZGljYXRlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGggPj4+IDA7XG4gICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhbHVlID0gbGlzdFtpXTtcbiAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywgdmFsdWUsIGksIGxpc3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIUFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXkucHJvdG90eXBlLCAnZmluZEluZGV4Jywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShwcmVkaWNhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZmluZEluZGV4IGNhbGxlZCBvbiBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJlZGljYXRlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGggPj4+IDA7XG4gICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhbHVlID0gbGlzdFtpXTtcbiAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywgdmFsdWUsIGksIGxpc3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmlmICh0eXBlb2YgRkVBVFVSRV9OT19FUzIwMTYgPT09ICd1bmRlZmluZWQnICYmICFBcnJheS5wcm90b3R5cGUuaW5jbHVkZXMpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSwgJ2luY2x1ZGVzJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoc2VhcmNoRWxlbWVudCkge1xuICAgICAgdmFyIE8gPSBPYmplY3QodGhpcyk7XG4gICAgICB2YXIgbGVuID0gcGFyc2VJbnQoTy5sZW5ndGgpIHx8IDA7XG4gICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBuID0gcGFyc2VJbnQoYXJndW1lbnRzWzFdKSB8fCAwO1xuICAgICAgdmFyIGs7XG4gICAgICBpZiAobiA+PSAwKSB7XG4gICAgICAgIGsgPSBuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgayA9IGxlbiArIG47XG4gICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgIGsgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY3VycmVudEVsZW1lbnQ7XG4gICAgICB3aGlsZSAoayA8IGxlbikge1xuICAgICAgICBjdXJyZW50RWxlbWVudCA9IE9ba107XG4gICAgICAgIGlmIChzZWFyY2hFbGVtZW50ID09PSBjdXJyZW50RWxlbWVudCB8fCBzZWFyY2hFbGVtZW50ICE9PSBzZWFyY2hFbGVtZW50ICYmIGN1cnJlbnRFbGVtZW50ICE9PSBjdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGsrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xufVxuXG5pZiAodHlwZW9mIEZFQVRVUkVfTk9fRVMyMDE1ID09PSAndW5kZWZpbmVkJykge1xuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5lZWRzRml4ID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHMgPSBPYmplY3Qua2V5cygnYScpO1xuICAgICAgbmVlZHNGaXggPSBzLmxlbmd0aCAhPT0gMSB8fCBzWzBdICE9PSAnMCc7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbmVlZHNGaXggPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChuZWVkc0ZpeCkge1xuICAgICAgT2JqZWN0LmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICAgICAgICBoYXNEb250RW51bUJ1ZyA9ICF7IHRvU3RyaW5nOiBudWxsIH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyksXG4gICAgICAgICAgICBkb250RW51bXMgPSBbJ3RvU3RyaW5nJywgJ3RvTG9jYWxlU3RyaW5nJywgJ3ZhbHVlT2YnLCAnaGFzT3duUHJvcGVydHknLCAnaXNQcm90b3R5cGVPZicsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdjb25zdHJ1Y3RvciddLFxuICAgICAgICAgICAgZG9udEVudW1zTGVuZ3RoID0gZG9udEVudW1zLmxlbmd0aDtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb2JqID0gT2JqZWN0KG9iaik7XG5cbiAgICAgICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYXNEb250RW51bUJ1Zykge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRvbnRFbnVtc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgZG9udEVudW1zW2ldKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRvbnRFbnVtc1tpXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfSgpO1xuICAgIH1cbiAgfSkoKTtcblxuICAoZnVuY3Rpb24gKE8pIHtcbiAgICBpZiAoJ2Fzc2lnbicgaW4gTykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIE8uZGVmaW5lUHJvcGVydHkoTywgJ2Fzc2lnbicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdPUFMgPSBPLmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICAgICAgICAgIHBJRSA9IE8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgICAgICAgICBmaWx0ZXJPUyA9IGdPUFMgPyBmdW5jdGlvbiAoc2VsZikge1xuICAgICAgICAgIHJldHVybiBnT1BTKHNlbGYpLmZpbHRlcihwSUUsIHNlbGYpO1xuICAgICAgICB9IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFzc2lnbih3aGVyZSkge1xuICAgICAgICAgIGlmIChnT1BTICYmICEod2hlcmUgaW5zdGFuY2VvZiBPKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdwcm9ibGVtYXRpYyBTeW1ib2xzJywgd2hlcmUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHNldChrZXlPclN5bWJvbCkge1xuICAgICAgICAgICAgd2hlcmVba2V5T3JTeW1ib2xdID0gYXJnW2tleU9yU3ltYm9sXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMSwgaWkgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICAgICAgaWYgKGFyZyA9PT0gbnVsbCB8fCBhcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTy5rZXlzKGFyZykuY29uY2F0KGZpbHRlck9TKGFyZykpLmZvckVhY2goc2V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd2hlcmU7XG4gICAgICAgIH07XG4gICAgICB9KClcbiAgICB9KTtcbiAgfSkoT2JqZWN0KTtcblxuICBpZiAoIU9iamVjdC5pcykge1xuICAgIE9iamVjdC5pcyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuaWYgKHR5cGVvZiBGRUFUVVJFX05PX0VTMjAxNSA9PT0gJ3VuZGVmaW5lZCcpIHtcblxuICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgIHZhciBpO1xuXG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICAgICAgICBpcyA9IGZ1bmN0aW9uIGlzKGEsIGIpIHtcbiAgICAgIHJldHVybiBhID09PSBiIHx8IGEgIT09IGEgJiYgYiAhPT0gYjtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBXZWFrTWFwID09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwuV2Vha01hcCA9IGNyZWF0ZUNvbGxlY3Rpb24oe1xuICAgICAgICAnZGVsZXRlJzogc2hhcmVkRGVsZXRlLFxuXG4gICAgICAgIGNsZWFyOiBzaGFyZWRDbGVhcixcblxuICAgICAgICBnZXQ6IHNoYXJlZEdldCxcblxuICAgICAgICBoYXM6IG1hcEhhcyxcblxuICAgICAgICBzZXQ6IHNoYXJlZFNldFxuICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBNYXAgPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIG5ldyBNYXAoKS52YWx1ZXMgIT09ICdmdW5jdGlvbicgfHwgIW5ldyBNYXAoKS52YWx1ZXMoKS5uZXh0KSB7XG4gICAgICB2YXIgX2NyZWF0ZUNvbGxlY3Rpb247XG5cbiAgICAgIGdsb2JhbC5NYXAgPSBjcmVhdGVDb2xsZWN0aW9uKChfY3JlYXRlQ29sbGVjdGlvbiA9IHtcbiAgICAgICAgJ2RlbGV0ZSc6IHNoYXJlZERlbGV0ZSxcblxuICAgICAgICBoYXM6IG1hcEhhcyxcblxuICAgICAgICBnZXQ6IHNoYXJlZEdldCxcblxuICAgICAgICBzZXQ6IHNoYXJlZFNldCxcblxuICAgICAgICBrZXlzOiBzaGFyZWRLZXlzLFxuXG4gICAgICAgIHZhbHVlczogc2hhcmVkVmFsdWVzLFxuXG4gICAgICAgIGVudHJpZXM6IG1hcEVudHJpZXMsXG5cbiAgICAgICAgZm9yRWFjaDogc2hhcmVkRm9yRWFjaCxcblxuICAgICAgICBjbGVhcjogc2hhcmVkQ2xlYXJcbiAgICAgIH0sIF9jcmVhdGVDb2xsZWN0aW9uW1N5bWJvbC5pdGVyYXRvcl0gPSBtYXBFbnRyaWVzLCBfY3JlYXRlQ29sbGVjdGlvbikpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgU2V0ID09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBuZXcgU2V0KCkudmFsdWVzICE9PSAnZnVuY3Rpb24nIHx8ICFuZXcgU2V0KCkudmFsdWVzKCkubmV4dCkge1xuICAgICAgdmFyIF9jcmVhdGVDb2xsZWN0aW9uMjtcblxuICAgICAgZ2xvYmFsLlNldCA9IGNyZWF0ZUNvbGxlY3Rpb24oKF9jcmVhdGVDb2xsZWN0aW9uMiA9IHtcbiAgICAgICAgaGFzOiBzZXRIYXMsXG5cbiAgICAgICAgYWRkOiBzaGFyZWRBZGQsXG5cbiAgICAgICAgJ2RlbGV0ZSc6IHNoYXJlZERlbGV0ZSxcblxuICAgICAgICBjbGVhcjogc2hhcmVkQ2xlYXIsXG5cbiAgICAgICAga2V5czogc2hhcmVkVmFsdWVzLFxuICAgICAgICB2YWx1ZXM6IHNoYXJlZFZhbHVlcyxcblxuICAgICAgICBlbnRyaWVzOiBzZXRFbnRyaWVzLFxuXG4gICAgICAgIGZvckVhY2g6IHNoYXJlZEZvckVhY2hcbiAgICAgIH0sIF9jcmVhdGVDb2xsZWN0aW9uMltTeW1ib2wuaXRlcmF0b3JdID0gc2hhcmVkVmFsdWVzLCBfY3JlYXRlQ29sbGVjdGlvbjIpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFdlYWtTZXQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdsb2JhbC5XZWFrU2V0ID0gY3JlYXRlQ29sbGVjdGlvbih7XG4gICAgICAgICdkZWxldGUnOiBzaGFyZWREZWxldGUsXG5cbiAgICAgICAgYWRkOiBzaGFyZWRBZGQsXG5cbiAgICAgICAgY2xlYXI6IHNoYXJlZENsZWFyLFxuXG4gICAgICAgIGhhczogc2V0SGFzXG4gICAgICB9LCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDb2xsZWN0aW9uKHByb3RvLCBvYmplY3RPbmx5KSB7XG4gICAgICBmdW5jdGlvbiBDb2xsZWN0aW9uKGEpIHtcbiAgICAgICAgaWYgKCF0aGlzIHx8IHRoaXMuY29uc3RydWN0b3IgIT09IENvbGxlY3Rpb24pIHJldHVybiBuZXcgQ29sbGVjdGlvbihhKTtcbiAgICAgICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faXRwID0gW107XG4gICAgICAgIHRoaXMub2JqZWN0T25seSA9IG9iamVjdE9ubHk7XG5cbiAgICAgICAgaWYgKGEpIGluaXQuY2FsbCh0aGlzLCBhKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvYmplY3RPbmx5KSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KHByb3RvLCAnc2l6ZScsIHtcbiAgICAgICAgICBnZXQ6IHNoYXJlZFNpemVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvLmNvbnN0cnVjdG9yID0gQ29sbGVjdGlvbjtcbiAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlID0gcHJvdG87XG5cbiAgICAgIHJldHVybiBDb2xsZWN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXQoYSkge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGlmICh0aGlzLmFkZCkgYS5mb3JFYWNoKHRoaXMuYWRkLCB0aGlzKTtlbHNlIGEuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHRoaXMuc2V0KGFbMF0sIGFbMV0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaGFyZWREZWxldGUoa2V5KSB7XG4gICAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICB0aGlzLl9rZXlzLnNwbGljZShpLCAxKTtcbiAgICAgICAgdGhpcy5fdmFsdWVzLnNwbGljZShpLCAxKTtcblxuICAgICAgICB0aGlzLl9pdHAuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIGlmIChpIDwgcFswXSkgcFswXS0tO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC0xIDwgaTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gc2hhcmVkR2V0KGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKGtleSkgPyB0aGlzLl92YWx1ZXNbaV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzKGxpc3QsIGtleSkge1xuICAgICAgaWYgKHRoaXMub2JqZWN0T25seSAmJiBrZXkgIT09IE9iamVjdChrZXkpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB2YWx1ZSB1c2VkIGFzIHdlYWsgY29sbGVjdGlvbiBrZXlcIik7XG5cbiAgICAgIGlmIChrZXkgIT0ga2V5IHx8IGtleSA9PT0gMCkgZm9yIChpID0gbGlzdC5sZW5ndGg7IGktLSAmJiAhaXMobGlzdFtpXSwga2V5KTspIHt9IGVsc2UgaSA9IGxpc3QuaW5kZXhPZihrZXkpO1xuICAgICAgcmV0dXJuIC0xIDwgaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRIYXModmFsdWUpIHtcbiAgICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLCB0aGlzLl92YWx1ZXMsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXBIYXModmFsdWUpIHtcbiAgICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLCB0aGlzLl9rZXlzLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hhcmVkU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuaGFzKGtleSkgPyB0aGlzLl92YWx1ZXNbaV0gPSB2YWx1ZSA6IHRoaXMuX3ZhbHVlc1t0aGlzLl9rZXlzLnB1c2goa2V5KSAtIDFdID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaGFyZWRBZGQodmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB0aGlzLl92YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaGFyZWRDbGVhcigpIHtcbiAgICAgICh0aGlzLl9rZXlzIHx8IDApLmxlbmd0aCA9IHRoaXMuX3ZhbHVlcy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNoYXJlZEtleXMoKSB7XG4gICAgICByZXR1cm4gc2hhcmVkSXRlcmF0b3IodGhpcy5faXRwLCB0aGlzLl9rZXlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaGFyZWRWYWx1ZXMoKSB7XG4gICAgICByZXR1cm4gc2hhcmVkSXRlcmF0b3IodGhpcy5faXRwLCB0aGlzLl92YWx1ZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcEVudHJpZXMoKSB7XG4gICAgICByZXR1cm4gc2hhcmVkSXRlcmF0b3IodGhpcy5faXRwLCB0aGlzLl9rZXlzLCB0aGlzLl92YWx1ZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEVudHJpZXMoKSB7XG4gICAgICByZXR1cm4gc2hhcmVkSXRlcmF0b3IodGhpcy5faXRwLCB0aGlzLl92YWx1ZXMsIHRoaXMuX3ZhbHVlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hhcmVkSXRlcmF0b3IoaXRwLCBhcnJheSwgYXJyYXkyKSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgdmFyIHAgPSBbMF0sXG4gICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgaXRwLnB1c2gocCk7XG4gICAgICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSwgX3JlZi5uZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdmFyIHYsXG4gICAgICAgICAgICBrID0gcFswXTtcbiAgICAgICAgaWYgKCFkb25lICYmIGsgPCBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICB2ID0gYXJyYXkyID8gW2FycmF5W2tdLCBhcnJheTJba11dIDogYXJyYXlba107XG4gICAgICAgICAgcFswXSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgIGl0cC5zcGxpY2UoaXRwLmluZGV4T2YocCksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbmU6IGRvbmUsIHZhbHVlOiB2IH07XG4gICAgICB9LCBfcmVmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNoYXJlZFNpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWVzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaGFyZWRGb3JFYWNoKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICB2YXIgaXQgPSB0aGlzLmVudHJpZXMoKTtcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgdmFyIHIgPSBpdC5uZXh0KCk7XG4gICAgICAgIGlmIChyLmRvbmUpIGJyZWFrO1xuICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIHIudmFsdWVbMV0sIHIudmFsdWVbMF0sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSkoUExBVEZPUk0uZ2xvYmFsKTtcbn1cblxuaWYgKHR5cGVvZiBGRUFUVVJFX05PX0VTMjAxNSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgKGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ7XG5cbiAgICBpZiAodHlwZW9mIFBMQVRGT1JNLmdsb2JhbC5SZWZsZWN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgUExBVEZPUk0uZ2xvYmFsLlJlZmxlY3QgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcikge1xuICAgICAgICBpZiAoKHR5cGVvZiB0YXJnZXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHRhcmdldCkpID09PSAnb2JqZWN0JyA/IHRhcmdldCA9PT0gbnVsbCA6IHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWZsZWN0LmRlZmluZVByb3BlcnR5IGNhbGxlZCBvbiBub24tb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0LmNvbnN0cnVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QgPSBmdW5jdGlvbiAoVGFyZ2V0LCBhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldCgpO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gbmV3IChiaW5kLmFwcGx5KFRhcmdldCwgYSkpKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgUmVmbGVjdC5vd25LZXlzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBSZWZsZWN0Lm93bktleXMgPSBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobykuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobykpO1xuICAgICAgfTtcbiAgICB9XG4gIH0pKCk7XG59XG5cbmlmICh0eXBlb2YgRkVBVFVSRV9OT19FU05FWFQgPT09ICd1bmRlZmluZWQnKSB7XG4gIChmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgZW1wdHlNZXRhZGF0YSA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgIHZhciBtZXRhZGF0YUNvbnRhaW5lcktleSA9ICdfX21ldGFkYXRhX18nO1xuXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0LmdldE93bk1ldGFkYXRhICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBSZWZsZWN0LmdldE93bk1ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHRhcmdldEtleSkge1xuICAgICAgICBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KG1ldGFkYXRhQ29udGFpbmVyS2V5KSkge1xuICAgICAgICAgIHJldHVybiAodGFyZ2V0W21ldGFkYXRhQ29udGFpbmVyS2V5XVt0YXJnZXRLZXldIHx8IGVtcHR5TWV0YWRhdGEpW21ldGFkYXRhS2V5XTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEgPSBmdW5jdGlvbiAobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgdGFyZ2V0S2V5KSB7XG4gICAgICAgIHZhciBtZXRhZGF0YUNvbnRhaW5lciA9IHRhcmdldC5oYXNPd25Qcm9wZXJ0eShtZXRhZGF0YUNvbnRhaW5lcktleSkgPyB0YXJnZXRbbWV0YWRhdGFDb250YWluZXJLZXldIDogdGFyZ2V0W21ldGFkYXRhQ29udGFpbmVyS2V5XSA9IHt9O1xuICAgICAgICB2YXIgdGFyZ2V0Q29udGFpbmVyID0gbWV0YWRhdGFDb250YWluZXJbdGFyZ2V0S2V5XSB8fCAobWV0YWRhdGFDb250YWluZXJbdGFyZ2V0S2V5XSA9IHt9KTtcbiAgICAgICAgdGFyZ2V0Q29udGFpbmVyW21ldGFkYXRhS2V5XSA9IG1ldGFkYXRhVmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgUmVmbGVjdC5tZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0S2V5KSB7XG4gICAgICAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCB0YXJnZXRLZXkpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG4gIH0pKCk7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///Q/5p\n");

/***/ })

}]);