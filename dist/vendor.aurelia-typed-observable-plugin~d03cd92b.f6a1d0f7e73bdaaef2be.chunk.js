(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendor.aurelia-typed-observable-plugin~d03cd92b"],{

/***/ "aVCK":
/*!***********************************************************************************!*\
  !*** ./node_modules/aurelia-typed-observable-plugin/dist/native-modules/index.js ***!
  \***********************************************************************************/
/*! exports provided: bindable, usePropertyTypeForBindable, createTypedBindable, observable, usePropertyTypeForObservable, createTypedObservable, coerceFunctions, coerceFunctionMap, mapCoerceFunction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bindable\", function() { return bindable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"usePropertyTypeForBindable\", function() { return usePropertyType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createTypedBindable\", function() { return createTypedBindable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"observable\", function() { return observable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"usePropertyTypeForObservable\", function() { return usePropertyType$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createTypedObservable\", function() { return createTypedObservable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"coerceFunctions\", function() { return coerceFunctions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"coerceFunctionMap\", function() { return coerceFunctionMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapCoerceFunction\", function() { return mapCoerceFunction; });\n/* harmony import */ var aurelia_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-logging */ \"MP1E\");\n/* harmony import */ var aurelia_templating__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aurelia-templating */ \"hij8\");\n/* harmony import */ var aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aurelia-metadata */ \"qrcG\");\n\n\n\n\nvar coerceFunctions = {\n    none: function (a) {\n        return a;\n    },\n    number: function (a) {\n        return Number(a);\n    },\n    string: function (a) {\n        return '' + a;\n    },\n    boolean: function (a) {\n        return !!a;\n    },\n    booleanAttr: function (val) {\n        return val || val === '' ? true : false;\n    },\n    date: function (val) {\n        // Invalid date instances are quite problematic\n        // so we need to deal with it properly by default\n        if (val === null || val === undefined) {\n            return null;\n        }\n        var d = new Date(val);\n        return isNaN(d.getTime()) ? null : d;\n    }\n};\nvar coerceFunctionMap = new Map([\n    [Boolean, 'boolean'],\n    [String, 'string'],\n    [Date, 'date'],\n    [Number, 'number'],\n]);\n/**\n * Map a class to a string for typescript property coerce\n * @param type the property class to register\n * @param strType the string that represents class in the lookup\n * @param coerceFunction coerce function to register with param strType\n */\nfunction mapCoerceFunction(type, strType, coerceFunction) {\n    coerceFunction = coerceFunction || type.coerce;\n    if (typeof strType !== 'string' || typeof coerceFunction !== 'function') {\n        Object(aurelia_logging__WEBPACK_IMPORTED_MODULE_0__[\"getLogger\"])('map-coerce-function')\n            .warn(\"Bad attempt at mapping coerce function for type: \" + type.name + \" to: \" + strType);\n        return;\n    }\n    coerceFunctions[strType] = coerceFunction;\n    coerceFunctionMap.set(type, strType);\n}\n\n// tslint:disable: interface-name no-invalid-this no-non-null-assertion\naurelia_templating__WEBPACK_IMPORTED_MODULE_1__[\"BehaviorPropertyObserver\"].prototype.setCoerce = function (coerce) {\n    this.coerce = typeof coerce === 'function' ? coerce : coerceFunctions[coerce];\n    if (this.coerce === undefined) {\n        Object(aurelia_logging__WEBPACK_IMPORTED_MODULE_0__[\"getLogger\"])('behavior-property-observer')\n            .warn(\"Invalid coerce instruction. Should be either one of \" + Object.keys(coerceFunctions) + \" or a function.\");\n    }\n};\n/**\n * Slightly override the builtin implementation that will handle coercion\n */\naurelia_templating__WEBPACK_IMPORTED_MODULE_1__[\"BehaviorPropertyObserver\"].prototype.setValue = function (newValue) {\n    var oldValue = this.currentValue;\n    var coercedValue = this.coerce === undefined ? newValue : this.coerce(newValue);\n    if (oldValue !== coercedValue) {\n        this.oldValue = oldValue;\n        this.currentValue = coercedValue;\n        if (this.publishing && this.notqueued) {\n            if (this.taskQueue.flushing) {\n                this.call();\n            }\n            else {\n                this.notqueued = false;\n                this.taskQueue.queueMicroTask(this);\n            }\n        }\n    }\n};\naurelia_templating__WEBPACK_IMPORTED_MODULE_1__[\"BindableProperty\"].prototype.createObserver = function (viewModel) {\n    var selfSubscriber = null;\n    var defaultValue = this.defaultValue;\n    var changeHandlerName = this.changeHandler;\n    var name = this.name;\n    var initialValue;\n    if (this.hasOptions) {\n        return undefined;\n    }\n    if (changeHandlerName in viewModel) {\n        if ('propertyChanged' in viewModel) {\n            selfSubscriber = function (newValue, oldValue) {\n                viewModel[changeHandlerName](newValue, oldValue);\n                viewModel.propertyChanged(name, newValue, oldValue);\n            };\n        }\n        else {\n            selfSubscriber = function (newValue, oldValue) { return viewModel[changeHandlerName](newValue, oldValue); };\n        }\n    }\n    else if ('propertyChanged' in viewModel) {\n        selfSubscriber = function (newValue, oldValue) { return viewModel.propertyChanged(name, newValue, oldValue); };\n    }\n    else if (changeHandlerName !== null) {\n        throw new Error(\"Change handler \" + changeHandlerName + \" was specified but not declared on the class.\");\n    }\n    if (defaultValue !== undefined) {\n        initialValue = typeof defaultValue === 'function' ? defaultValue.call(viewModel) : defaultValue;\n    }\n    var observer = new aurelia_templating__WEBPACK_IMPORTED_MODULE_1__[\"BehaviorPropertyObserver\"](this.owner.taskQueue, viewModel, this.name, selfSubscriber, initialValue);\n    if (this.coerce !== undefined) {\n        observer.setCoerce(this.coerce);\n        observer.currentValue = observer.oldValue = observer.coerce === undefined ? observer.currentValue : observer.coerce(initialValue);\n    }\n    return observer;\n};\naurelia_templating__WEBPACK_IMPORTED_MODULE_1__[\"BindableProperty\"].prototype._createDynamicProperty = function (viewModel, observerLookup, behaviorHandlesBind, name, attribute, boundProperties) {\n    var changeHandlerName = name + \"Changed\";\n    var selfSubscriber = null;\n    var observer;\n    var info;\n    if (changeHandlerName in viewModel) {\n        if ('propertyChanged' in viewModel) {\n            selfSubscriber = function (newValue, oldValue) {\n                viewModel[changeHandlerName](newValue, oldValue);\n                viewModel.propertyChanged(name, newValue, oldValue);\n            };\n        }\n        else {\n            selfSubscriber = function (newValue, oldValue) { return viewModel[changeHandlerName](newValue, oldValue); };\n        }\n    }\n    else if ('propertyChanged' in viewModel) {\n        selfSubscriber = function (newValue, oldValue) { return viewModel.propertyChanged(name, newValue, oldValue); };\n    }\n    observer = observerLookup[name] = new aurelia_templating__WEBPACK_IMPORTED_MODULE_1__[\"BehaviorPropertyObserver\"](this.owner.taskQueue, viewModel, name, selfSubscriber, undefined);\n    observer.setCoerce(this.coerce);\n    observer.currentValue = observer.oldValue = observer.coerce === undefined ? observer.currentValue : observer.coerce(undefined);\n    Object.defineProperty(viewModel, name, {\n        configurable: true,\n        enumerable: true,\n        get: observer.getValue.bind(observer),\n        set: observer.setValue.bind(observer)\n    });\n    if (behaviorHandlesBind) {\n        observer.selfSubscriber = null;\n    }\n    if (typeof attribute === 'string') {\n        viewModel[name] = attribute;\n        observer.call();\n    }\n    else if (attribute) {\n        info = { observer: observer, binding: attribute.createBinding(viewModel) };\n        boundProperties.push(info);\n    }\n    observer.publishing = true;\n    observer.selfSubscriber = selfSubscriber;\n};\n\nvar _usePropertyType = false;\n/**\n * Decorator: Specifies that a property is bindable through HTML.\n * @param nameOrTargetOrConfig The name of the property, or a configuration object.\n * This has Object in its type to avoid breaking change.\n * Idealy it should be `string | BindablePropertyConfig`\n */\n// tslint:disable-next-line:no-shadowed-variable\nvar bindable = function bindable(nameOrTargetOrConfig, key, descriptor) {\n    var deco = function (target, key2, descriptor2) {\n        /**\n         * key2 = truthy => decorated on a class field\n         * key2 = falsy => decorated on a class\n         */\n        var actualTarget = key2 ? target.constructor : target;\n        var r = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__[\"metadata\"].getOrCreateOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__[\"metadata\"].resource, aurelia_templating__WEBPACK_IMPORTED_MODULE_1__[\"HtmlBehaviorResource\"], actualTarget);\n        var prop;\n        var propType;\n        if (key2) { //is it on a property or a class?\n            nameOrTargetOrConfig = nameOrTargetOrConfig || {};\n            nameOrTargetOrConfig.name = key2;\n            /**\n             * Support for Typescript decorator, with metadata on property type.\n             * Will check for typing only when user didn't explicitly set coerce + turn on the options\n             *\n             * If key 2 is truthy, it's a decorator on class field, which means target is prototype\n             */\n            if (nameOrTargetOrConfig.coerce === undefined && _usePropertyType) {\n                propType = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__[\"metadata\"].getOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__[\"metadata\"].propertyType, target, key2);\n                if (propType) {\n                    var coerceType = coerceFunctionMap.get(propType);\n                    if (coerceType === undefined) {\n                        Object(aurelia_logging__WEBPACK_IMPORTED_MODULE_0__[\"getLogger\"])('@bindable decorator')\n                            .warn(\"Invalid coerce instruction. Should be either one of \" + Object.keys(coerceFunctions) + \" or a function.\");\n                    }\n                    nameOrTargetOrConfig.coerce = coerceType || 'none';\n                }\n            }\n        }\n        prop = new aurelia_templating__WEBPACK_IMPORTED_MODULE_1__[\"BindableProperty\"](nameOrTargetOrConfig);\n        return prop.registerWith(actualTarget, r, descriptor2);\n    };\n    if (!nameOrTargetOrConfig) {\n        /**\n         * placed on property initializer with parens, without any params\n         * @example:\n         * class ViewModel {\n         *   @bindable() property\n         * }\n         * @bindable() class ViewModel {}\n         */\n        return deco;\n    }\n    if (key) {\n        /**\n         * placed on a property initializer without parens\n         * @example\n         * class ViewModel {\n         *   @bindable property\n         * }\n         *\n         */\n        var target = nameOrTargetOrConfig;\n        nameOrTargetOrConfig = undefined;\n        return deco(target, key, descriptor);\n    }\n    /**\n     * placed on a class with parens and config\n     * @example\n     * @bindable({ ... })\n     * class MyViewModel {}\n     */\n    return deco;\n};\n['string', 'number', 'boolean', 'booleanAttr', 'date'].forEach(createTypedBindable);\n/**\n * Used to allow user to automatically pickup property type\n * Can be used with typescript emit metadata in compiler settings, or with `Reflect.metadata('design:type', PropertyTypeClass)` decorator\n */\nfunction usePropertyType(shouldUsePropertyType) {\n    _usePropertyType = shouldUsePropertyType;\n}\n/**\n * Create a new fluent syntax bindable decorator  ex: builtin: `@bindable.string`, custom: `@bindable.customType`\n * Need to use together with setting the type in `coerceFunctions`:\n *\n * ```js\n * import {\n *  createTypedBindable,\n *  coerceFunctions\n * } from 'aurelia-framework'\n *\n * // create the typed bindable\n * createTypedBindable('point'); // => enable `@bindable.point`\n * // Set the instruction\n * coerceFunctions.point = function(value: string) {\n *   // convert to point from value\n * }\n * ```\n *\n * @param type The type to added to bindable for fluent syntax.\n */\nfunction createTypedBindable(type) {\n    /**\n     * There no attempts to protect user from mis-using the decorators.\n     * ex. @observable({}, accidentParam) class SomeClass {}\n     * If we have some flag to use in if block, which can be remove at build time, it would be great.\n     */\n    return bindable[type] = function (nameOrTargetOrConfig, key, descriptor) {\n        if (nameOrTargetOrConfig === undefined) {\n            /**\n             * MyClass {\n             *   @bindable.number() num\n             * }\n             */\n            return bindable({ coerce: type });\n        }\n        if (key === undefined) {\n            /**\n             * @bindable.number('num')\n             * class MyClass {}\n             *\n             * @bindable.number({...})\n             * class MyClass\n             *\n             * class MyClass {\n             *   @bindable.number({...})\n             *   num\n             * }\n             */\n            nameOrTargetOrConfig = typeof nameOrTargetOrConfig === 'string' ? { name: nameOrTargetOrConfig } : nameOrTargetOrConfig;\n            nameOrTargetOrConfig.coerce = type;\n            return bindable(nameOrTargetOrConfig);\n        }\n        /**\n         * class MyClass {\n         *   @bindable.number num\n         * }\n         */\n        return bindable({ coerce: type })(nameOrTargetOrConfig, key, descriptor);\n    };\n}\n\nvar observableLogger = Object(aurelia_logging__WEBPACK_IMPORTED_MODULE_0__[\"getLogger\"])('aurelia-observable-decorator');\n/**\n * Internal flag to turn on / off auto pickup property type from metadata\n */\nvar _usePropertyType$1 = false;\nvar observable = function observable(nameOrTargetOrConfig, key, descriptor) {\n    /**\n     * @param target The class decorated\n     * @param key The target class field of the decorator\n     * @param descriptor class field descriptor\n     * @param config user's config\n     */\n    function deco(target, key, descriptor, config) {\n        // Used to check if we should pickup the type from metadata\n        var coerce = config === undefined || typeof config === 'string' ? undefined : config.coerce;\n        var propType;\n        var coerceFunction;\n        if (coerce) {\n            switch (typeof coerce) {\n                case 'string':\n                    coerceFunction = coerceFunctions[coerce];\n                    break;\n                case 'function':\n                    coerceFunction = coerce;\n                    break;\n                default: break;\n            }\n            if (coerceFunction === undefined) {\n                observableLogger.warn(\"Invalid coerce instruction. Should be either one of \" + Object.keys(coerceFunctions) + \" or a function.\");\n            }\n        }\n        else if (_usePropertyType$1) {\n            propType = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__[\"metadata\"].getOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__[\"metadata\"].propertyType, target, key);\n            if (propType) {\n                coerceFunction = coerceFunctions[coerceFunctionMap.get(propType)];\n                if (coerceFunction === undefined) {\n                    observableLogger.warn(\"Unable to find coerce function for type \" + propType.name + \".\");\n                }\n            }\n        }\n        /**\n         * class decorator?\n         * @example\n         * @observable('firstName') MyClass {}\n         * @observable({ name: 'firstName' }) MyClass {}\n         */\n        var isClassDecorator = key === undefined;\n        if (isClassDecorator) {\n            target = target.prototype;\n            key = typeof config === 'string' ? config : config.name;\n        }\n        // use a convention to compute the inner property name\n        var innerPropertyName = \"_\" + key;\n        var innerPropertyDescriptor = {\n            configurable: true,\n            enumerable: false,\n            writable: true\n        };\n        if (config && 'defaultValue' in config) {\n            var initValue = config.defaultValue;\n            innerPropertyDescriptor.value = coerceFunction === undefined ? initValue : coerceFunction(initValue);\n        }\n        // determine callback name based on config or convention.\n        var callbackName = (config && config.changeHandler) || key + \"Changed\";\n        if (descriptor) {\n            // babel passes in the property descriptor with a method to get the initial value.\n            // set the initial value of the property if it is defined.\n            // also make sure it's coerced\n            if (typeof descriptor.initializer === 'function') {\n                var initValue = descriptor.initializer();\n                innerPropertyDescriptor.value = coerceFunction === undefined ? initValue : coerceFunction(initValue);\n            }\n        }\n        else {\n            // there is no descriptor if the target was a field in TS (although Babel provides one),\n            // or if the decorator was applied to a class.\n            descriptor = {};\n        }\n        // make the accessor enumerable by default, as fields are enumerable\n        if (!('enumerable' in descriptor)) {\n            descriptor.enumerable = true;\n        }\n        // we're adding a getter and setter which means the property descriptor\n        // cannot have a \"value\" or \"writable\" attribute\n        delete descriptor.value;\n        delete descriptor.writable;\n        delete descriptor.initializer;\n        // Add the inner property on the prototype.\n        Reflect.defineProperty(target, innerPropertyName, innerPropertyDescriptor);\n        // add the getter and setter to the property descriptor.\n        descriptor.get = function () { return this[innerPropertyName]; };\n        descriptor.set = function (newValue) {\n            var oldValue = this[innerPropertyName];\n            var coercedValue = coerceFunction === undefined ? newValue : coerceFunction(newValue);\n            if (coercedValue === oldValue) {\n                return;\n            }\n            // Add the inner property on the instance and make it nonenumerable.\n            this[innerPropertyName] = coercedValue;\n            Reflect.defineProperty(this, innerPropertyName, { enumerable: false });\n            if (this[callbackName]) {\n                this[callbackName](coercedValue, oldValue, key);\n            }\n        };\n        // make sure Aurelia doesn't use dirty-checking by declaring the property's\n        // dependencies. This is the equivalent of \"@computedFrom(...)\".\n        descriptor.get.dependencies = [innerPropertyName];\n        if (isClassDecorator) {\n            Reflect.defineProperty(target, key, descriptor);\n        }\n        else {\n            return descriptor;\n        }\n    }\n    /**\n     * Decorating with parens\n     * @example\n     * @observable MyClass {} <----- this breaks, but will go into this condition\n     * @observable('firstName') MyClass {}\n     * @observable({ name: 'firstName' }) MyClass {}\n     * class MyClass {\n     *   @observable() prop\n     * }\n     */\n    if (key === undefined) {\n        return function (t, k, d) { return deco(t, k, d, nameOrTargetOrConfig); };\n    }\n    /**\n     * Decorating on class field\n     * @example\n     * class MyClass {\n     *   @observable prop\n     * }\n     */\n    return deco(nameOrTargetOrConfig, key, descriptor);\n};\n['string', 'number', 'boolean', 'date'].forEach(createTypedObservable);\n/*\n          | typescript       | babel\n----------|------------------|-------------------------\nproperty  | config           | config\nw/parens  | target, key      | target, key, descriptor\n----------|------------------|-------------------------\nproperty  | target, key      | target, key, descriptor\nno parens | n/a              | n/a\n----------|------------------|-------------------------\nclass     | config           | config\n          | target           | target\n*/\n/**\n * Toggle the flag for observable to auto pickup property type from metadata\n * The reason is sometimes we may want to use prop type on bindable, but not observable\n * and vice versa\n */\nfunction usePropertyType$1(shouldUsePropType) {\n    _usePropertyType$1 = !!shouldUsePropType;\n}\n/**\n * Decorator: Creates a new observable decorator that can be used for fluent syntax purpose\n * @param type the type name that will be assign to observable decorator. `createTypedObservable('point') -> observable.point`\n */\nfunction createTypedObservable(type) {\n    return observable[type] = function (nameOrTargetOrConfig, key, descriptor) {\n        if (nameOrTargetOrConfig === undefined) {\n            /**\n             * MyClass {\n             *   @observable.number() num\n             * }\n             *\n             * This will breaks so need to check for proper error\n             * @observable.number()\n             * class MyClass {}\n             */\n            return observable({ coerce: type });\n        }\n        if (key === undefined) {\n            /**\n             * @observable.number('num')\n             * class MyClass {}\n             *\n             * @observable.number({...})\n             * class MyClass\n             *\n             * class MyClass {\n             *   @observable.number({...})\n             *   num\n             * }\n             */\n            nameOrTargetOrConfig = typeof nameOrTargetOrConfig === 'string' ? { name: nameOrTargetOrConfig } : nameOrTargetOrConfig;\n            nameOrTargetOrConfig.coerce = type;\n            return observable(nameOrTargetOrConfig);\n        }\n        /**\n         * class MyClass {\n         *   @observable.number num\n         * }\n         */\n        return observable({ coerce: type })(nameOrTargetOrConfig, key, descriptor);\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYVZDSy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hdXJlbGlhLXR5cGVkLW9ic2VydmFibGUtcGx1Z2luL2Rpc3QvbmF0aXZlLW1vZHVsZXMvaW5kZXguanM/Njk1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tICdhdXJlbGlhLWxvZ2dpbmcnO1xuaW1wb3J0IHsgQmVoYXZpb3JQcm9wZXJ0eU9ic2VydmVyLCBCaW5kYWJsZVByb3BlcnR5LCBIdG1sQmVoYXZpb3JSZXNvdXJjZSB9IGZyb20gJ2F1cmVsaWEtdGVtcGxhdGluZyc7XG5pbXBvcnQgeyBtZXRhZGF0YSB9IGZyb20gJ2F1cmVsaWEtbWV0YWRhdGEnO1xuXG52YXIgY29lcmNlRnVuY3Rpb25zID0ge1xuICAgIG5vbmU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH0sXG4gICAgbnVtYmVyOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKGEpO1xuICAgIH0sXG4gICAgc3RyaW5nOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gJycgKyBhO1xuICAgIH0sXG4gICAgYm9vbGVhbjogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuICEhYTtcbiAgICB9LFxuICAgIGJvb2xlYW5BdHRyOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgfHwgdmFsID09PSAnJyA/IHRydWUgOiBmYWxzZTtcbiAgICB9LFxuICAgIGRhdGU6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgLy8gSW52YWxpZCBkYXRlIGluc3RhbmNlcyBhcmUgcXVpdGUgcHJvYmxlbWF0aWNcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byBkZWFsIHdpdGggaXQgcHJvcGVybHkgYnkgZGVmYXVsdFxuICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKHZhbCk7XG4gICAgICAgIHJldHVybiBpc05hTihkLmdldFRpbWUoKSkgPyBudWxsIDogZDtcbiAgICB9XG59O1xudmFyIGNvZXJjZUZ1bmN0aW9uTWFwID0gbmV3IE1hcChbXG4gICAgW0Jvb2xlYW4sICdib29sZWFuJ10sXG4gICAgW1N0cmluZywgJ3N0cmluZyddLFxuICAgIFtEYXRlLCAnZGF0ZSddLFxuICAgIFtOdW1iZXIsICdudW1iZXInXSxcbl0pO1xuLyoqXG4gKiBNYXAgYSBjbGFzcyB0byBhIHN0cmluZyBmb3IgdHlwZXNjcmlwdCBwcm9wZXJ0eSBjb2VyY2VcbiAqIEBwYXJhbSB0eXBlIHRoZSBwcm9wZXJ0eSBjbGFzcyB0byByZWdpc3RlclxuICogQHBhcmFtIHN0clR5cGUgdGhlIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgY2xhc3MgaW4gdGhlIGxvb2t1cFxuICogQHBhcmFtIGNvZXJjZUZ1bmN0aW9uIGNvZXJjZSBmdW5jdGlvbiB0byByZWdpc3RlciB3aXRoIHBhcmFtIHN0clR5cGVcbiAqL1xuZnVuY3Rpb24gbWFwQ29lcmNlRnVuY3Rpb24odHlwZSwgc3RyVHlwZSwgY29lcmNlRnVuY3Rpb24pIHtcbiAgICBjb2VyY2VGdW5jdGlvbiA9IGNvZXJjZUZ1bmN0aW9uIHx8IHR5cGUuY29lcmNlO1xuICAgIGlmICh0eXBlb2Ygc3RyVHlwZSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGNvZXJjZUZ1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGdldExvZ2dlcignbWFwLWNvZXJjZS1mdW5jdGlvbicpXG4gICAgICAgICAgICAud2FybihcIkJhZCBhdHRlbXB0IGF0IG1hcHBpbmcgY29lcmNlIGZ1bmN0aW9uIGZvciB0eXBlOiBcIiArIHR5cGUubmFtZSArIFwiIHRvOiBcIiArIHN0clR5cGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvZXJjZUZ1bmN0aW9uc1tzdHJUeXBlXSA9IGNvZXJjZUZ1bmN0aW9uO1xuICAgIGNvZXJjZUZ1bmN0aW9uTWFwLnNldCh0eXBlLCBzdHJUeXBlKTtcbn1cblxuLy8gdHNsaW50OmRpc2FibGU6IGludGVyZmFjZS1uYW1lIG5vLWludmFsaWQtdGhpcyBuby1ub24tbnVsbC1hc3NlcnRpb25cbkJlaGF2aW9yUHJvcGVydHlPYnNlcnZlci5wcm90b3R5cGUuc2V0Q29lcmNlID0gZnVuY3Rpb24gKGNvZXJjZSkge1xuICAgIHRoaXMuY29lcmNlID0gdHlwZW9mIGNvZXJjZSA9PT0gJ2Z1bmN0aW9uJyA/IGNvZXJjZSA6IGNvZXJjZUZ1bmN0aW9uc1tjb2VyY2VdO1xuICAgIGlmICh0aGlzLmNvZXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGdldExvZ2dlcignYmVoYXZpb3ItcHJvcGVydHktb2JzZXJ2ZXInKVxuICAgICAgICAgICAgLndhcm4oXCJJbnZhbGlkIGNvZXJjZSBpbnN0cnVjdGlvbi4gU2hvdWxkIGJlIGVpdGhlciBvbmUgb2YgXCIgKyBPYmplY3Qua2V5cyhjb2VyY2VGdW5jdGlvbnMpICsgXCIgb3IgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxufTtcbi8qKlxuICogU2xpZ2h0bHkgb3ZlcnJpZGUgdGhlIGJ1aWx0aW4gaW1wbGVtZW50YXRpb24gdGhhdCB3aWxsIGhhbmRsZSBjb2VyY2lvblxuICovXG5CZWhhdmlvclByb3BlcnR5T2JzZXJ2ZXIucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy5jdXJyZW50VmFsdWU7XG4gICAgdmFyIGNvZXJjZWRWYWx1ZSA9IHRoaXMuY29lcmNlID09PSB1bmRlZmluZWQgPyBuZXdWYWx1ZSA6IHRoaXMuY29lcmNlKG5ld1ZhbHVlKTtcbiAgICBpZiAob2xkVmFsdWUgIT09IGNvZXJjZWRWYWx1ZSkge1xuICAgICAgICB0aGlzLm9sZFZhbHVlID0gb2xkVmFsdWU7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gY29lcmNlZFZhbHVlO1xuICAgICAgICBpZiAodGhpcy5wdWJsaXNoaW5nICYmIHRoaXMubm90cXVldWVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50YXNrUXVldWUuZmx1c2hpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubm90cXVldWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy50YXNrUXVldWUucXVldWVNaWNyb1Rhc2sodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuQmluZGFibGVQcm9wZXJ0eS5wcm90b3R5cGUuY3JlYXRlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAodmlld01vZGVsKSB7XG4gICAgdmFyIHNlbGZTdWJzY3JpYmVyID0gbnVsbDtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gdGhpcy5kZWZhdWx0VmFsdWU7XG4gICAgdmFyIGNoYW5nZUhhbmRsZXJOYW1lID0gdGhpcy5jaGFuZ2VIYW5kbGVyO1xuICAgIHZhciBuYW1lID0gdGhpcy5uYW1lO1xuICAgIHZhciBpbml0aWFsVmFsdWU7XG4gICAgaWYgKHRoaXMuaGFzT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoY2hhbmdlSGFuZGxlck5hbWUgaW4gdmlld01vZGVsKSB7XG4gICAgICAgIGlmICgncHJvcGVydHlDaGFuZ2VkJyBpbiB2aWV3TW9kZWwpIHtcbiAgICAgICAgICAgIHNlbGZTdWJzY3JpYmVyID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHZpZXdNb2RlbFtjaGFuZ2VIYW5kbGVyTmFtZV0obmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgICB2aWV3TW9kZWwucHJvcGVydHlDaGFuZ2VkKG5hbWUsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZlN1YnNjcmliZXIgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlKSB7IHJldHVybiB2aWV3TW9kZWxbY2hhbmdlSGFuZGxlck5hbWVdKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7IH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoJ3Byb3BlcnR5Q2hhbmdlZCcgaW4gdmlld01vZGVsKSB7XG4gICAgICAgIHNlbGZTdWJzY3JpYmVyID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkgeyByZXR1cm4gdmlld01vZGVsLnByb3BlcnR5Q2hhbmdlZChuYW1lLCBuZXdWYWx1ZSwgb2xkVmFsdWUpOyB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFuZ2VIYW5kbGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGFuZ2UgaGFuZGxlciBcIiArIGNoYW5nZUhhbmRsZXJOYW1lICsgXCIgd2FzIHNwZWNpZmllZCBidXQgbm90IGRlY2xhcmVkIG9uIHRoZSBjbGFzcy5cIik7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbml0aWFsVmFsdWUgPSB0eXBlb2YgZGVmYXVsdFZhbHVlID09PSAnZnVuY3Rpb24nID8gZGVmYXVsdFZhbHVlLmNhbGwodmlld01vZGVsKSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IEJlaGF2aW9yUHJvcGVydHlPYnNlcnZlcih0aGlzLm93bmVyLnRhc2tRdWV1ZSwgdmlld01vZGVsLCB0aGlzLm5hbWUsIHNlbGZTdWJzY3JpYmVyLCBpbml0aWFsVmFsdWUpO1xuICAgIGlmICh0aGlzLmNvZXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9ic2VydmVyLnNldENvZXJjZSh0aGlzLmNvZXJjZSk7XG4gICAgICAgIG9ic2VydmVyLmN1cnJlbnRWYWx1ZSA9IG9ic2VydmVyLm9sZFZhbHVlID0gb2JzZXJ2ZXIuY29lcmNlID09PSB1bmRlZmluZWQgPyBvYnNlcnZlci5jdXJyZW50VmFsdWUgOiBvYnNlcnZlci5jb2VyY2UoaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG9ic2VydmVyO1xufTtcbkJpbmRhYmxlUHJvcGVydHkucHJvdG90eXBlLl9jcmVhdGVEeW5hbWljUHJvcGVydHkgPSBmdW5jdGlvbiAodmlld01vZGVsLCBvYnNlcnZlckxvb2t1cCwgYmVoYXZpb3JIYW5kbGVzQmluZCwgbmFtZSwgYXR0cmlidXRlLCBib3VuZFByb3BlcnRpZXMpIHtcbiAgICB2YXIgY2hhbmdlSGFuZGxlck5hbWUgPSBuYW1lICsgXCJDaGFuZ2VkXCI7XG4gICAgdmFyIHNlbGZTdWJzY3JpYmVyID0gbnVsbDtcbiAgICB2YXIgb2JzZXJ2ZXI7XG4gICAgdmFyIGluZm87XG4gICAgaWYgKGNoYW5nZUhhbmRsZXJOYW1lIGluIHZpZXdNb2RlbCkge1xuICAgICAgICBpZiAoJ3Byb3BlcnR5Q2hhbmdlZCcgaW4gdmlld01vZGVsKSB7XG4gICAgICAgICAgICBzZWxmU3Vic2NyaWJlciA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2aWV3TW9kZWxbY2hhbmdlSGFuZGxlck5hbWVdKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdmlld01vZGVsLnByb3BlcnR5Q2hhbmdlZChuYW1lLCBuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGZTdWJzY3JpYmVyID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkgeyByZXR1cm4gdmlld01vZGVsW2NoYW5nZUhhbmRsZXJOYW1lXShuZXdWYWx1ZSwgb2xkVmFsdWUpOyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCdwcm9wZXJ0eUNoYW5nZWQnIGluIHZpZXdNb2RlbCkge1xuICAgICAgICBzZWxmU3Vic2NyaWJlciA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUpIHsgcmV0dXJuIHZpZXdNb2RlbC5wcm9wZXJ0eUNoYW5nZWQobmFtZSwgbmV3VmFsdWUsIG9sZFZhbHVlKTsgfTtcbiAgICB9XG4gICAgb2JzZXJ2ZXIgPSBvYnNlcnZlckxvb2t1cFtuYW1lXSA9IG5ldyBCZWhhdmlvclByb3BlcnR5T2JzZXJ2ZXIodGhpcy5vd25lci50YXNrUXVldWUsIHZpZXdNb2RlbCwgbmFtZSwgc2VsZlN1YnNjcmliZXIsIHVuZGVmaW5lZCk7XG4gICAgb2JzZXJ2ZXIuc2V0Q29lcmNlKHRoaXMuY29lcmNlKTtcbiAgICBvYnNlcnZlci5jdXJyZW50VmFsdWUgPSBvYnNlcnZlci5vbGRWYWx1ZSA9IG9ic2VydmVyLmNvZXJjZSA9PT0gdW5kZWZpbmVkID8gb2JzZXJ2ZXIuY3VycmVudFZhbHVlIDogb2JzZXJ2ZXIuY29lcmNlKHVuZGVmaW5lZCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZpZXdNb2RlbCwgbmFtZSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogb2JzZXJ2ZXIuZ2V0VmFsdWUuYmluZChvYnNlcnZlciksXG4gICAgICAgIHNldDogb2JzZXJ2ZXIuc2V0VmFsdWUuYmluZChvYnNlcnZlcilcbiAgICB9KTtcbiAgICBpZiAoYmVoYXZpb3JIYW5kbGVzQmluZCkge1xuICAgICAgICBvYnNlcnZlci5zZWxmU3Vic2NyaWJlciA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2aWV3TW9kZWxbbmFtZV0gPSBhdHRyaWJ1dGU7XG4gICAgICAgIG9ic2VydmVyLmNhbGwoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGluZm8gPSB7IG9ic2VydmVyOiBvYnNlcnZlciwgYmluZGluZzogYXR0cmlidXRlLmNyZWF0ZUJpbmRpbmcodmlld01vZGVsKSB9O1xuICAgICAgICBib3VuZFByb3BlcnRpZXMucHVzaChpbmZvKTtcbiAgICB9XG4gICAgb2JzZXJ2ZXIucHVibGlzaGluZyA9IHRydWU7XG4gICAgb2JzZXJ2ZXIuc2VsZlN1YnNjcmliZXIgPSBzZWxmU3Vic2NyaWJlcjtcbn07XG5cbnZhciBfdXNlUHJvcGVydHlUeXBlID0gZmFsc2U7XG4vKipcbiAqIERlY29yYXRvcjogU3BlY2lmaWVzIHRoYXQgYSBwcm9wZXJ0eSBpcyBiaW5kYWJsZSB0aHJvdWdoIEhUTUwuXG4gKiBAcGFyYW0gbmFtZU9yVGFyZ2V0T3JDb25maWcgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LCBvciBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICogVGhpcyBoYXMgT2JqZWN0IGluIGl0cyB0eXBlIHRvIGF2b2lkIGJyZWFraW5nIGNoYW5nZS5cbiAqIElkZWFseSBpdCBzaG91bGQgYmUgYHN0cmluZyB8IEJpbmRhYmxlUHJvcGVydHlDb25maWdgXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1zaGFkb3dlZC12YXJpYWJsZVxudmFyIGJpbmRhYmxlID0gZnVuY3Rpb24gYmluZGFibGUobmFtZU9yVGFyZ2V0T3JDb25maWcsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIHZhciBkZWNvID0gZnVuY3Rpb24gKHRhcmdldCwga2V5MiwgZGVzY3JpcHRvcjIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGtleTIgPSB0cnV0aHkgPT4gZGVjb3JhdGVkIG9uIGEgY2xhc3MgZmllbGRcbiAgICAgICAgICoga2V5MiA9IGZhbHN5ID0+IGRlY29yYXRlZCBvbiBhIGNsYXNzXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgYWN0dWFsVGFyZ2V0ID0ga2V5MiA/IHRhcmdldC5jb25zdHJ1Y3RvciA6IHRhcmdldDtcbiAgICAgICAgdmFyIHIgPSBtZXRhZGF0YS5nZXRPckNyZWF0ZU93bihtZXRhZGF0YS5yZXNvdXJjZSwgSHRtbEJlaGF2aW9yUmVzb3VyY2UsIGFjdHVhbFRhcmdldCk7XG4gICAgICAgIHZhciBwcm9wO1xuICAgICAgICB2YXIgcHJvcFR5cGU7XG4gICAgICAgIGlmIChrZXkyKSB7IC8vaXMgaXQgb24gYSBwcm9wZXJ0eSBvciBhIGNsYXNzP1xuICAgICAgICAgICAgbmFtZU9yVGFyZ2V0T3JDb25maWcgPSBuYW1lT3JUYXJnZXRPckNvbmZpZyB8fCB7fTtcbiAgICAgICAgICAgIG5hbWVPclRhcmdldE9yQ29uZmlnLm5hbWUgPSBrZXkyO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTdXBwb3J0IGZvciBUeXBlc2NyaXB0IGRlY29yYXRvciwgd2l0aCBtZXRhZGF0YSBvbiBwcm9wZXJ0eSB0eXBlLlxuICAgICAgICAgICAgICogV2lsbCBjaGVjayBmb3IgdHlwaW5nIG9ubHkgd2hlbiB1c2VyIGRpZG4ndCBleHBsaWNpdGx5IHNldCBjb2VyY2UgKyB0dXJuIG9uIHRoZSBvcHRpb25zXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSWYga2V5IDIgaXMgdHJ1dGh5LCBpdCdzIGEgZGVjb3JhdG9yIG9uIGNsYXNzIGZpZWxkLCB3aGljaCBtZWFucyB0YXJnZXQgaXMgcHJvdG90eXBlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChuYW1lT3JUYXJnZXRPckNvbmZpZy5jb2VyY2UgPT09IHVuZGVmaW5lZCAmJiBfdXNlUHJvcGVydHlUeXBlKSB7XG4gICAgICAgICAgICAgICAgcHJvcFR5cGUgPSBtZXRhZGF0YS5nZXRPd24obWV0YWRhdGEucHJvcGVydHlUeXBlLCB0YXJnZXQsIGtleTIpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29lcmNlVHlwZSA9IGNvZXJjZUZ1bmN0aW9uTWFwLmdldChwcm9wVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2VyY2VUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldExvZ2dlcignQGJpbmRhYmxlIGRlY29yYXRvcicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLndhcm4oXCJJbnZhbGlkIGNvZXJjZSBpbnN0cnVjdGlvbi4gU2hvdWxkIGJlIGVpdGhlciBvbmUgb2YgXCIgKyBPYmplY3Qua2V5cyhjb2VyY2VGdW5jdGlvbnMpICsgXCIgb3IgYSBmdW5jdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmFtZU9yVGFyZ2V0T3JDb25maWcuY29lcmNlID0gY29lcmNlVHlwZSB8fCAnbm9uZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb3AgPSBuZXcgQmluZGFibGVQcm9wZXJ0eShuYW1lT3JUYXJnZXRPckNvbmZpZyk7XG4gICAgICAgIHJldHVybiBwcm9wLnJlZ2lzdGVyV2l0aChhY3R1YWxUYXJnZXQsIHIsIGRlc2NyaXB0b3IyKTtcbiAgICB9O1xuICAgIGlmICghbmFtZU9yVGFyZ2V0T3JDb25maWcpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHBsYWNlZCBvbiBwcm9wZXJ0eSBpbml0aWFsaXplciB3aXRoIHBhcmVucywgd2l0aG91dCBhbnkgcGFyYW1zXG4gICAgICAgICAqIEBleGFtcGxlOlxuICAgICAgICAgKiBjbGFzcyBWaWV3TW9kZWwge1xuICAgICAgICAgKiAgIEBiaW5kYWJsZSgpIHByb3BlcnR5XG4gICAgICAgICAqIH1cbiAgICAgICAgICogQGJpbmRhYmxlKCkgY2xhc3MgVmlld01vZGVsIHt9XG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZGVjbztcbiAgICB9XG4gICAgaWYgKGtleSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogcGxhY2VkIG9uIGEgcHJvcGVydHkgaW5pdGlhbGl6ZXIgd2l0aG91dCBwYXJlbnNcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogY2xhc3MgVmlld01vZGVsIHtcbiAgICAgICAgICogICBAYmluZGFibGUgcHJvcGVydHlcbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRhcmdldCA9IG5hbWVPclRhcmdldE9yQ29uZmlnO1xuICAgICAgICBuYW1lT3JUYXJnZXRPckNvbmZpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGRlY28odGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBwbGFjZWQgb24gYSBjbGFzcyB3aXRoIHBhcmVucyBhbmQgY29uZmlnXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBAYmluZGFibGUoeyAuLi4gfSlcbiAgICAgKiBjbGFzcyBNeVZpZXdNb2RlbCB7fVxuICAgICAqL1xuICAgIHJldHVybiBkZWNvO1xufTtcblsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJywgJ2Jvb2xlYW5BdHRyJywgJ2RhdGUnXS5mb3JFYWNoKGNyZWF0ZVR5cGVkQmluZGFibGUpO1xuLyoqXG4gKiBVc2VkIHRvIGFsbG93IHVzZXIgdG8gYXV0b21hdGljYWxseSBwaWNrdXAgcHJvcGVydHkgdHlwZVxuICogQ2FuIGJlIHVzZWQgd2l0aCB0eXBlc2NyaXB0IGVtaXQgbWV0YWRhdGEgaW4gY29tcGlsZXIgc2V0dGluZ3MsIG9yIHdpdGggYFJlZmxlY3QubWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgUHJvcGVydHlUeXBlQ2xhc3MpYCBkZWNvcmF0b3JcbiAqL1xuZnVuY3Rpb24gdXNlUHJvcGVydHlUeXBlKHNob3VsZFVzZVByb3BlcnR5VHlwZSkge1xuICAgIF91c2VQcm9wZXJ0eVR5cGUgPSBzaG91bGRVc2VQcm9wZXJ0eVR5cGU7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBmbHVlbnQgc3ludGF4IGJpbmRhYmxlIGRlY29yYXRvciAgZXg6IGJ1aWx0aW46IGBAYmluZGFibGUuc3RyaW5nYCwgY3VzdG9tOiBgQGJpbmRhYmxlLmN1c3RvbVR5cGVgXG4gKiBOZWVkIHRvIHVzZSB0b2dldGhlciB3aXRoIHNldHRpbmcgdGhlIHR5cGUgaW4gYGNvZXJjZUZ1bmN0aW9uc2A6XG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7XG4gKiAgY3JlYXRlVHlwZWRCaW5kYWJsZSxcbiAqICBjb2VyY2VGdW5jdGlvbnNcbiAqIH0gZnJvbSAnYXVyZWxpYS1mcmFtZXdvcmsnXG4gKlxuICogLy8gY3JlYXRlIHRoZSB0eXBlZCBiaW5kYWJsZVxuICogY3JlYXRlVHlwZWRCaW5kYWJsZSgncG9pbnQnKTsgLy8gPT4gZW5hYmxlIGBAYmluZGFibGUucG9pbnRgXG4gKiAvLyBTZXQgdGhlIGluc3RydWN0aW9uXG4gKiBjb2VyY2VGdW5jdGlvbnMucG9pbnQgPSBmdW5jdGlvbih2YWx1ZTogc3RyaW5nKSB7XG4gKiAgIC8vIGNvbnZlcnQgdG8gcG9pbnQgZnJvbSB2YWx1ZVxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgdG8gYWRkZWQgdG8gYmluZGFibGUgZm9yIGZsdWVudCBzeW50YXguXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVkQmluZGFibGUodHlwZSkge1xuICAgIC8qKlxuICAgICAqIFRoZXJlIG5vIGF0dGVtcHRzIHRvIHByb3RlY3QgdXNlciBmcm9tIG1pcy11c2luZyB0aGUgZGVjb3JhdG9ycy5cbiAgICAgKiBleC4gQG9ic2VydmFibGUoe30sIGFjY2lkZW50UGFyYW0pIGNsYXNzIFNvbWVDbGFzcyB7fVxuICAgICAqIElmIHdlIGhhdmUgc29tZSBmbGFnIHRvIHVzZSBpbiBpZiBibG9jaywgd2hpY2ggY2FuIGJlIHJlbW92ZSBhdCBidWlsZCB0aW1lLCBpdCB3b3VsZCBiZSBncmVhdC5cbiAgICAgKi9cbiAgICByZXR1cm4gYmluZGFibGVbdHlwZV0gPSBmdW5jdGlvbiAobmFtZU9yVGFyZ2V0T3JDb25maWcsIGtleSwgZGVzY3JpcHRvcikge1xuICAgICAgICBpZiAobmFtZU9yVGFyZ2V0T3JDb25maWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNeUNsYXNzIHtcbiAgICAgICAgICAgICAqICAgQGJpbmRhYmxlLm51bWJlcigpIG51bVxuICAgICAgICAgICAgICogfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gYmluZGFibGUoeyBjb2VyY2U6IHR5cGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBiaW5kYWJsZS5udW1iZXIoJ251bScpXG4gICAgICAgICAgICAgKiBjbGFzcyBNeUNsYXNzIHt9XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGJpbmRhYmxlLm51bWJlcih7Li4ufSlcbiAgICAgICAgICAgICAqIGNsYXNzIE15Q2xhc3NcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBjbGFzcyBNeUNsYXNzIHtcbiAgICAgICAgICAgICAqICAgQGJpbmRhYmxlLm51bWJlcih7Li4ufSlcbiAgICAgICAgICAgICAqICAgbnVtXG4gICAgICAgICAgICAgKiB9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG5hbWVPclRhcmdldE9yQ29uZmlnID0gdHlwZW9mIG5hbWVPclRhcmdldE9yQ29uZmlnID09PSAnc3RyaW5nJyA/IHsgbmFtZTogbmFtZU9yVGFyZ2V0T3JDb25maWcgfSA6IG5hbWVPclRhcmdldE9yQ29uZmlnO1xuICAgICAgICAgICAgbmFtZU9yVGFyZ2V0T3JDb25maWcuY29lcmNlID0gdHlwZTtcbiAgICAgICAgICAgIHJldHVybiBiaW5kYWJsZShuYW1lT3JUYXJnZXRPckNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNsYXNzIE15Q2xhc3Mge1xuICAgICAgICAgKiAgIEBiaW5kYWJsZS5udW1iZXIgbnVtXG4gICAgICAgICAqIH1cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBiaW5kYWJsZSh7IGNvZXJjZTogdHlwZSB9KShuYW1lT3JUYXJnZXRPckNvbmZpZywga2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9O1xufVxuXG52YXIgb2JzZXJ2YWJsZUxvZ2dlciA9IGdldExvZ2dlcignYXVyZWxpYS1vYnNlcnZhYmxlLWRlY29yYXRvcicpO1xuLyoqXG4gKiBJbnRlcm5hbCBmbGFnIHRvIHR1cm4gb24gLyBvZmYgYXV0byBwaWNrdXAgcHJvcGVydHkgdHlwZSBmcm9tIG1ldGFkYXRhXG4gKi9cbnZhciBfdXNlUHJvcGVydHlUeXBlJDEgPSBmYWxzZTtcbnZhciBvYnNlcnZhYmxlID0gZnVuY3Rpb24gb2JzZXJ2YWJsZShuYW1lT3JUYXJnZXRPckNvbmZpZywga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHRhcmdldCBUaGUgY2xhc3MgZGVjb3JhdGVkXG4gICAgICogQHBhcmFtIGtleSBUaGUgdGFyZ2V0IGNsYXNzIGZpZWxkIG9mIHRoZSBkZWNvcmF0b3JcbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRvciBjbGFzcyBmaWVsZCBkZXNjcmlwdG9yXG4gICAgICogQHBhcmFtIGNvbmZpZyB1c2VyJ3MgY29uZmlnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVjbyh0YXJnZXQsIGtleSwgZGVzY3JpcHRvciwgY29uZmlnKSB7XG4gICAgICAgIC8vIFVzZWQgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHBpY2t1cCB0aGUgdHlwZSBmcm9tIG1ldGFkYXRhXG4gICAgICAgIHZhciBjb2VyY2UgPSBjb25maWcgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJyA/IHVuZGVmaW5lZCA6IGNvbmZpZy5jb2VyY2U7XG4gICAgICAgIHZhciBwcm9wVHlwZTtcbiAgICAgICAgdmFyIGNvZXJjZUZ1bmN0aW9uO1xuICAgICAgICBpZiAoY29lcmNlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjb2VyY2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICBjb2VyY2VGdW5jdGlvbiA9IGNvZXJjZUZ1bmN0aW9uc1tjb2VyY2VdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIGNvZXJjZUZ1bmN0aW9uID0gY29lcmNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2VyY2VGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2YWJsZUxvZ2dlci53YXJuKFwiSW52YWxpZCBjb2VyY2UgaW5zdHJ1Y3Rpb24uIFNob3VsZCBiZSBlaXRoZXIgb25lIG9mIFwiICsgT2JqZWN0LmtleXMoY29lcmNlRnVuY3Rpb25zKSArIFwiIG9yIGEgZnVuY3Rpb24uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF91c2VQcm9wZXJ0eVR5cGUkMSkge1xuICAgICAgICAgICAgcHJvcFR5cGUgPSBtZXRhZGF0YS5nZXRPd24obWV0YWRhdGEucHJvcGVydHlUeXBlLCB0YXJnZXQsIGtleSk7XG4gICAgICAgICAgICBpZiAocHJvcFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb2VyY2VGdW5jdGlvbiA9IGNvZXJjZUZ1bmN0aW9uc1tjb2VyY2VGdW5jdGlvbk1hcC5nZXQocHJvcFR5cGUpXTtcbiAgICAgICAgICAgICAgICBpZiAoY29lcmNlRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZhYmxlTG9nZ2VyLndhcm4oXCJVbmFibGUgdG8gZmluZCBjb2VyY2UgZnVuY3Rpb24gZm9yIHR5cGUgXCIgKyBwcm9wVHlwZS5uYW1lICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogY2xhc3MgZGVjb3JhdG9yP1xuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBAb2JzZXJ2YWJsZSgnZmlyc3ROYW1lJykgTXlDbGFzcyB7fVxuICAgICAgICAgKiBAb2JzZXJ2YWJsZSh7IG5hbWU6ICdmaXJzdE5hbWUnIH0pIE15Q2xhc3Mge31cbiAgICAgICAgICovXG4gICAgICAgIHZhciBpc0NsYXNzRGVjb3JhdG9yID0ga2V5ID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpc0NsYXNzRGVjb3JhdG9yKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICAgICAga2V5ID0gdHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycgPyBjb25maWcgOiBjb25maWcubmFtZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1c2UgYSBjb252ZW50aW9uIHRvIGNvbXB1dGUgdGhlIGlubmVyIHByb3BlcnR5IG5hbWVcbiAgICAgICAgdmFyIGlubmVyUHJvcGVydHlOYW1lID0gXCJfXCIgKyBrZXk7XG4gICAgICAgIHZhciBpbm5lclByb3BlcnR5RGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNvbmZpZyAmJiAnZGVmYXVsdFZhbHVlJyBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIHZhciBpbml0VmFsdWUgPSBjb25maWcuZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgaW5uZXJQcm9wZXJ0eURlc2NyaXB0b3IudmFsdWUgPSBjb2VyY2VGdW5jdGlvbiA9PT0gdW5kZWZpbmVkID8gaW5pdFZhbHVlIDogY29lcmNlRnVuY3Rpb24oaW5pdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZXRlcm1pbmUgY2FsbGJhY2sgbmFtZSBiYXNlZCBvbiBjb25maWcgb3IgY29udmVudGlvbi5cbiAgICAgICAgdmFyIGNhbGxiYWNrTmFtZSA9IChjb25maWcgJiYgY29uZmlnLmNoYW5nZUhhbmRsZXIpIHx8IGtleSArIFwiQ2hhbmdlZFwiO1xuICAgICAgICBpZiAoZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgLy8gYmFiZWwgcGFzc2VzIGluIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHdpdGggYSBtZXRob2QgdG8gZ2V0IHRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAgICAgICAgLy8gc2V0IHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBpZiBpdCBpcyBkZWZpbmVkLlxuICAgICAgICAgICAgLy8gYWxzbyBtYWtlIHN1cmUgaXQncyBjb2VyY2VkXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdFZhbHVlID0gZGVzY3JpcHRvci5pbml0aWFsaXplcigpO1xuICAgICAgICAgICAgICAgIGlubmVyUHJvcGVydHlEZXNjcmlwdG9yLnZhbHVlID0gY29lcmNlRnVuY3Rpb24gPT09IHVuZGVmaW5lZCA/IGluaXRWYWx1ZSA6IGNvZXJjZUZ1bmN0aW9uKGluaXRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBubyBkZXNjcmlwdG9yIGlmIHRoZSB0YXJnZXQgd2FzIGEgZmllbGQgaW4gVFMgKGFsdGhvdWdoIEJhYmVsIHByb3ZpZGVzIG9uZSksXG4gICAgICAgICAgICAvLyBvciBpZiB0aGUgZGVjb3JhdG9yIHdhcyBhcHBsaWVkIHRvIGEgY2xhc3MuXG4gICAgICAgICAgICBkZXNjcmlwdG9yID0ge307XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFrZSB0aGUgYWNjZXNzb3IgZW51bWVyYWJsZSBieSBkZWZhdWx0LCBhcyBmaWVsZHMgYXJlIGVudW1lcmFibGVcbiAgICAgICAgaWYgKCEoJ2VudW1lcmFibGUnIGluIGRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlJ3JlIGFkZGluZyBhIGdldHRlciBhbmQgc2V0dGVyIHdoaWNoIG1lYW5zIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yXG4gICAgICAgIC8vIGNhbm5vdCBoYXZlIGEgXCJ2YWx1ZVwiIG9yIFwid3JpdGFibGVcIiBhdHRyaWJ1dGVcbiAgICAgICAgZGVsZXRlIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgIGRlbGV0ZSBkZXNjcmlwdG9yLndyaXRhYmxlO1xuICAgICAgICBkZWxldGUgZGVzY3JpcHRvci5pbml0aWFsaXplcjtcbiAgICAgICAgLy8gQWRkIHRoZSBpbm5lciBwcm9wZXJ0eSBvbiB0aGUgcHJvdG90eXBlLlxuICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgaW5uZXJQcm9wZXJ0eU5hbWUsIGlubmVyUHJvcGVydHlEZXNjcmlwdG9yKTtcbiAgICAgICAgLy8gYWRkIHRoZSBnZXR0ZXIgYW5kIHNldHRlciB0byB0aGUgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAgICAgICAgZGVzY3JpcHRvci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW2lubmVyUHJvcGVydHlOYW1lXTsgfTtcbiAgICAgICAgZGVzY3JpcHRvci5zZXQgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXNbaW5uZXJQcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgdmFyIGNvZXJjZWRWYWx1ZSA9IGNvZXJjZUZ1bmN0aW9uID09PSB1bmRlZmluZWQgPyBuZXdWYWx1ZSA6IGNvZXJjZUZ1bmN0aW9uKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjb2VyY2VkVmFsdWUgPT09IG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBpbm5lciBwcm9wZXJ0eSBvbiB0aGUgaW5zdGFuY2UgYW5kIG1ha2UgaXQgbm9uZW51bWVyYWJsZS5cbiAgICAgICAgICAgIHRoaXNbaW5uZXJQcm9wZXJ0eU5hbWVdID0gY29lcmNlZFZhbHVlO1xuICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbm5lclByb3BlcnR5TmFtZSwgeyBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzW2NhbGxiYWNrTmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzW2NhbGxiYWNrTmFtZV0oY29lcmNlZFZhbHVlLCBvbGRWYWx1ZSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIEF1cmVsaWEgZG9lc24ndCB1c2UgZGlydHktY2hlY2tpbmcgYnkgZGVjbGFyaW5nIHRoZSBwcm9wZXJ0eSdzXG4gICAgICAgIC8vIGRlcGVuZGVuY2llcy4gVGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiBcIkBjb21wdXRlZEZyb20oLi4uKVwiLlxuICAgICAgICBkZXNjcmlwdG9yLmdldC5kZXBlbmRlbmNpZXMgPSBbaW5uZXJQcm9wZXJ0eU5hbWVdO1xuICAgICAgICBpZiAoaXNDbGFzc0RlY29yYXRvcikge1xuICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvcmF0aW5nIHdpdGggcGFyZW5zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBAb2JzZXJ2YWJsZSBNeUNsYXNzIHt9IDwtLS0tLSB0aGlzIGJyZWFrcywgYnV0IHdpbGwgZ28gaW50byB0aGlzIGNvbmRpdGlvblxuICAgICAqIEBvYnNlcnZhYmxlKCdmaXJzdE5hbWUnKSBNeUNsYXNzIHt9XG4gICAgICogQG9ic2VydmFibGUoeyBuYW1lOiAnZmlyc3ROYW1lJyB9KSBNeUNsYXNzIHt9XG4gICAgICogY2xhc3MgTXlDbGFzcyB7XG4gICAgICogICBAb2JzZXJ2YWJsZSgpIHByb3BcbiAgICAgKiB9XG4gICAgICovXG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodCwgaywgZCkgeyByZXR1cm4gZGVjbyh0LCBrLCBkLCBuYW1lT3JUYXJnZXRPckNvbmZpZyk7IH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29yYXRpbmcgb24gY2xhc3MgZmllbGRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNsYXNzIE15Q2xhc3Mge1xuICAgICAqICAgQG9ic2VydmFibGUgcHJvcFxuICAgICAqIH1cbiAgICAgKi9cbiAgICByZXR1cm4gZGVjbyhuYW1lT3JUYXJnZXRPckNvbmZpZywga2V5LCBkZXNjcmlwdG9yKTtcbn07XG5bJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbicsICdkYXRlJ10uZm9yRWFjaChjcmVhdGVUeXBlZE9ic2VydmFibGUpO1xuLypcbiAgICAgICAgICB8IHR5cGVzY3JpcHQgICAgICAgfCBiYWJlbFxuLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxucHJvcGVydHkgIHwgY29uZmlnICAgICAgICAgICB8IGNvbmZpZ1xudy9wYXJlbnMgIHwgdGFyZ2V0LCBrZXkgICAgICB8IHRhcmdldCwga2V5LCBkZXNjcmlwdG9yXG4tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5wcm9wZXJ0eSAgfCB0YXJnZXQsIGtleSAgICAgIHwgdGFyZ2V0LCBrZXksIGRlc2NyaXB0b3Jcbm5vIHBhcmVucyB8IG4vYSAgICAgICAgICAgICAgfCBuL2Fcbi0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNsYXNzICAgICB8IGNvbmZpZyAgICAgICAgICAgfCBjb25maWdcbiAgICAgICAgICB8IHRhcmdldCAgICAgICAgICAgfCB0YXJnZXRcbiovXG4vKipcbiAqIFRvZ2dsZSB0aGUgZmxhZyBmb3Igb2JzZXJ2YWJsZSB0byBhdXRvIHBpY2t1cCBwcm9wZXJ0eSB0eXBlIGZyb20gbWV0YWRhdGFcbiAqIFRoZSByZWFzb24gaXMgc29tZXRpbWVzIHdlIG1heSB3YW50IHRvIHVzZSBwcm9wIHR5cGUgb24gYmluZGFibGUsIGJ1dCBub3Qgb2JzZXJ2YWJsZVxuICogYW5kIHZpY2UgdmVyc2FcbiAqL1xuZnVuY3Rpb24gdXNlUHJvcGVydHlUeXBlJDEoc2hvdWxkVXNlUHJvcFR5cGUpIHtcbiAgICBfdXNlUHJvcGVydHlUeXBlJDEgPSAhIXNob3VsZFVzZVByb3BUeXBlO1xufVxuLyoqXG4gKiBEZWNvcmF0b3I6IENyZWF0ZXMgYSBuZXcgb2JzZXJ2YWJsZSBkZWNvcmF0b3IgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZmx1ZW50IHN5bnRheCBwdXJwb3NlXG4gKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBuYW1lIHRoYXQgd2lsbCBiZSBhc3NpZ24gdG8gb2JzZXJ2YWJsZSBkZWNvcmF0b3IuIGBjcmVhdGVUeXBlZE9ic2VydmFibGUoJ3BvaW50JykgLT4gb2JzZXJ2YWJsZS5wb2ludGBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHlwZWRPYnNlcnZhYmxlKHR5cGUpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZVt0eXBlXSA9IGZ1bmN0aW9uIChuYW1lT3JUYXJnZXRPckNvbmZpZywga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmIChuYW1lT3JUYXJnZXRPckNvbmZpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE15Q2xhc3Mge1xuICAgICAgICAgICAgICogICBAb2JzZXJ2YWJsZS5udW1iZXIoKSBudW1cbiAgICAgICAgICAgICAqIH1cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGlzIHdpbGwgYnJlYWtzIHNvIG5lZWQgdG8gY2hlY2sgZm9yIHByb3BlciBlcnJvclxuICAgICAgICAgICAgICogQG9ic2VydmFibGUubnVtYmVyKClcbiAgICAgICAgICAgICAqIGNsYXNzIE15Q2xhc3Mge31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmFibGUoeyBjb2VyY2U6IHR5cGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBvYnNlcnZhYmxlLm51bWJlcignbnVtJylcbiAgICAgICAgICAgICAqIGNsYXNzIE15Q2xhc3Mge31cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAb2JzZXJ2YWJsZS5udW1iZXIoey4uLn0pXG4gICAgICAgICAgICAgKiBjbGFzcyBNeUNsYXNzXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogY2xhc3MgTXlDbGFzcyB7XG4gICAgICAgICAgICAgKiAgIEBvYnNlcnZhYmxlLm51bWJlcih7Li4ufSlcbiAgICAgICAgICAgICAqICAgbnVtXG4gICAgICAgICAgICAgKiB9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG5hbWVPclRhcmdldE9yQ29uZmlnID0gdHlwZW9mIG5hbWVPclRhcmdldE9yQ29uZmlnID09PSAnc3RyaW5nJyA/IHsgbmFtZTogbmFtZU9yVGFyZ2V0T3JDb25maWcgfSA6IG5hbWVPclRhcmdldE9yQ29uZmlnO1xuICAgICAgICAgICAgbmFtZU9yVGFyZ2V0T3JDb25maWcuY29lcmNlID0gdHlwZTtcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlKG5hbWVPclRhcmdldE9yQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogY2xhc3MgTXlDbGFzcyB7XG4gICAgICAgICAqICAgQG9ic2VydmFibGUubnVtYmVyIG51bVxuICAgICAgICAgKiB9XG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZSh7IGNvZXJjZTogdHlwZSB9KShuYW1lT3JUYXJnZXRPckNvbmZpZywga2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBiaW5kYWJsZSwgdXNlUHJvcGVydHlUeXBlIGFzIHVzZVByb3BlcnR5VHlwZUZvckJpbmRhYmxlLCBjcmVhdGVUeXBlZEJpbmRhYmxlLCBvYnNlcnZhYmxlLCB1c2VQcm9wZXJ0eVR5cGUkMSBhcyB1c2VQcm9wZXJ0eVR5cGVGb3JPYnNlcnZhYmxlLCBjcmVhdGVUeXBlZE9ic2VydmFibGUsIGNvZXJjZUZ1bmN0aW9ucywgY29lcmNlRnVuY3Rpb25NYXAsIG1hcENvZXJjZUZ1bmN0aW9uIH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///aVCK\n");

/***/ })

}]);